<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>I3JS - Namespace</h1>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="AMFLoader">AMFLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AMFLoader AMFLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:AMFLoader AMFLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Group parse](  [param:ArrayBuffer data] ) <br />
			[method:AMFLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:AMFLoader setPath](  [param:string path] ) <br />
			[method:AMFLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:AMFLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:AMFLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ARButton">ARButton <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:HTMLElement createButton](  [param:WebGLRenderer renderer],  [param:any sessionInit]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="AdaptiveToneMappingPass">AdaptiveToneMappingPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AdaptiveToneMappingPass AdaptiveToneMappingPass](  [param:boolean adaptive]?,  [param:number resolution]? ) <br />
			[constructor:AdaptiveToneMappingPass AdaptiveToneMappingPass](  [param:boolean adaptive]?,  [param:number resolution]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object adaptLuminanceShader] -  The adapt luminance shader.<br />
			[property:boolean adaptive] -  The adaptive.<br />
			[property:boolean clear] -  The clear.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:WebGLRenderTarget currentLuminanceRT] -  The current luminance r t.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:WebGLRenderTarget luminanceRT] -  The luminance r t.<br />
			[property:ShaderMaterial materialAdaptiveLum] -  The material adaptive lum.<br />
			[property:ShaderMaterial materialCopy] -  The material copy.<br />
			[property:ShaderMaterial materialLuminance] -  The material luminance.<br />
			[property:ShaderMaterial materialToneMap] -  The material tone map.<br />
			[property:number needsInit] -  The needs init.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:WebGLRenderTarget previousLuminanceRT] -  The previous luminance r t.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:number resolution] -  The resolution.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void reset](  ) <br />
			[method:void setAdaptionRate](  [param:number rate] ) <br />
			[method:void setAdaptive](  [param:boolean adaptive] ) <br />
			[method:void setAverageLuminance](  [param:number avgLum] ) <br />
			[method:void setMaxLuminance](  [param:number maxLum] ) <br />
			[method:void setMiddleGrey](  [param:number middleGrey] ) <br />
			[method:void setMinLuminance](  [param:number minLum] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="AfterimagePass">AfterimagePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AfterimagePass AfterimagePass](  [param:number damp]? ) <br />
			[constructor:AfterimagePass AfterimagePass](  [param:number damp]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:object compFsQuad] -  The comp fs quad.<br />
			[property:object copyFsQuad] -  The copy fs quad.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object shader] -  The shader.<br />
			[property:ShaderMaterial shaderMaterial] -  The shader material.<br />
			[property:WebGLRenderTarget textureComp] -  The texture comp.<br />
			[property:WebGLRenderTarget textureOld] -  The texture old.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AfterimageShader">AfterimageShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Light] &rarr;

		<h3 id="AmbientLight">AmbientLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AmbientLight AmbientLight](  [param:ColorRepresentation color]?,  [param:number intensity]? ) - This creates a Ambientlight with a color.<br />
			[constructor:AmbientLight AmbientLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:AmbientLight AmbientLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:AmbientLight AmbientLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isAmbientLight] -  The is ambient light.<br />
			[property:any isLight] -  The is light.<br />
			[property:LightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:AmbientLight add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:AmbientLight applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:AmbientLight attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:AmbientLight clear](  ) - Removes all child objects.<br />
			[method:AmbientLight clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:AmbientLight copy](  [param:AmbientLight source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:AmbientLight remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:AmbientLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:AmbientLight rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:AmbientLight rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:AmbientLight rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:AmbientLight rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:AmbientLight rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:AmbientLight translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:AmbientLight translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:AmbientLight translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:AmbientLight translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			This light's color gets applied to all the objects in the scene globally.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Light] &rarr; [page:LightProbe] &rarr;

		<h3 id="AmbientLightProbe">AmbientLightProbe <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AmbientLightProbe AmbientLightProbe](  [param:ColorRepresentation color]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:AmbientLightProbe AmbientLightProbe](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:SphericalHarmonics3 sh]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:AmbientLightProbe AmbientLightProbe](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:SphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:AmbientLightProbe AmbientLightProbe](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:SphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:AmbientLightProbe AmbientLightProbe](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:SphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isAmbientLightProbe] -  The is ambient light probe.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isLightProbe] -  The is light probe.<br />
			[property:SphericalHarmonics3 sh] -  The sh.<br />
			[property:LightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:AmbientLightProbe add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:AmbientLightProbe applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:AmbientLightProbe attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:AmbientLightProbe clear](  ) - Removes all child objects.<br />
			[method:AmbientLightProbe clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:AmbientLightProbe copy](  [param:AmbientLightProbe source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:LightProbe fromJSON](  [param:object json] ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:AmbientLightProbe remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:AmbientLightProbe removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:AmbientLightProbe rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:AmbientLightProbe rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:AmbientLightProbe rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:AmbientLightProbe rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:AmbientLightProbe rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:AmbientLightProbe translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:AmbientLightProbe translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:AmbientLightProbe translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:AmbientLightProbe translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AmmoPhysics">AmmoPhysics <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AmmoPhysics AmmoPhysics](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addMesh](  [param:Mesh mesh],  [param:number mass] ) <br />
			[method:void setMeshPosition](  [param:Mesh mesh],  [param:Vector3 position],  [param:number index] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AnaglyphEffect">AnaglyphEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AnaglyphEffect AnaglyphEffect](  [param:WebGLRenderer renderer],  [param:number width]?,  [param:number height]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Matrix3 colorMatrixLeft] -  The color matrix left.<br />
			[property:Matrix3 colorMatrixRight] -  The color matrix right.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void render](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AnimationAction">AnimationAction <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AnimationAction AnimationAction](  [param:AnimationMixer mixer],  [param:AnimationClip clip],  [param:Object3D localRoot]?,  [param:AnimationBlendMode blendMode]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:AnimationBlendMode blendMode] -  The blend mode.<br />
			[property:boolean clampWhenFinished] -  The clamp when finished.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:AnimationActionLoopStyles loop] -  The loop.<br />
			[property:boolean paused] -  The paused.<br />
			[property:number repetitions] -  The repetitions.<br />
			[property:number time] -  The time.<br />
			[property:number timeScale] -  The time scale.<br />
			[property:number weight] -  The weight.<br />
			[property:boolean zeroSlopeAtEnd] -  The zero slope at end.<br />
			[property:boolean zeroSlopeAtStart] -  The zero slope at start.
		</p>
		<h4>Methods</h4>
		<p>
			[method:AnimationAction crossFadeFrom](  [param:AnimationAction fadeOutAction],  [param:number duration],  [param:boolean warp] ) <br />
			[method:AnimationAction crossFadeTo](  [param:AnimationAction fadeInAction],  [param:number duration],  [param:boolean warp] ) <br />
			[method:AnimationAction fadeIn](  [param:number duration] ) <br />
			[method:AnimationAction fadeOut](  [param:number duration] ) <br />
			[method:AnimationClip getClip](  ) <br />
			[method:number getEffectiveTimeScale](  ) <br />
			[method:number getEffectiveWeight](  ) <br />
			[method:AnimationMixer getMixer](  ) <br />
			[method:Object3D getRoot](  ) <br />
			[method:AnimationAction halt](  [param:number duration] ) <br />
			[method:boolean isRunning](  ) <br />
			[method:boolean isScheduled](  ) <br />
			[method:AnimationAction play](  ) <br />
			[method:AnimationAction reset](  ) <br />
			[method:AnimationAction setDuration](  [param:number duration] ) <br />
			[method:AnimationAction setEffectiveTimeScale](  [param:number timeScale] ) <br />
			[method:AnimationAction setEffectiveWeight](  [param:number weight] ) <br />
			[method:AnimationAction setLoop](  [param:AnimationActionLoopStyles mode],  [param:number repetitions] ) <br />
			[method:AnimationAction startAt](  [param:number time] ) <br />
			[method:AnimationAction stop](  ) <br />
			[method:AnimationAction stopFading](  ) <br />
			[method:AnimationAction stopWarping](  ) <br />
			[method:AnimationAction syncWith](  [param:AnimationAction action] ) <br />
			[method:AnimationAction warp](  [param:number statTimeScale],  [param:number endTimeScale],  [param:number duration] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AnimationClip">AnimationClip <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AnimationClip AnimationClip](  [param:string name]?,  [param:number duration]?,  [param:KeyframeTrack[] tracks]?,  [param:AnimationBlendMode blendMode]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:AnimationBlendMode blendMode] -  The blend mode.<br />
			[property:number duration] -  The duration.<br />
			[property:string name] -  The name.<br />
			[property:any[] results] -  The results.<br />
			[property:KeyframeTrack[] tracks] -  The tracks.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:AnimationClip[] CreateClipsFromMorphTargetSequences](  [param:MorphTarget[] morphTargets],  [param:number fps],  [param:boolean noLoop] ) <br />
			[method:AnimationClip CreateFromMorphTargetSequence](  [param:string name],  [param:MorphTarget[] morphTargetSequence],  [param:number fps],  [param:boolean noLoop] ) <br />
			[method:AnimationClip clone](  ) <br />
			[method:AnimationClip findByName](  [param:AnimationClip[] clipArray],  [param:string name] ) <br />
			[method:AnimationClip optimize](  ) <br />
			[method:AnimationClip parse](  [param:any json] ) <br />
			[method:AnimationClip parseAnimation](  [param:any animation],  [param:Bone[] bones] ) <br />
			[method:AnimationClip resetDuration](  ) <br />
			[method:any toJSON](  [param:AnimationClip clip] ) <br />
			[method:any toJSON](  [param:AnimationClip clip],  [param:AnimationClip clip] ) <br />
			[method:AnimationClip trim](  ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AnimationClipCreator">AnimationClipCreator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:AnimationClip CreateMaterialColorAnimation](  [param:number duration],  [param:number[] colors] ) <br />
			[method:AnimationClip CreatePulsationAnimation](  [param:number duration],  [param:number pulseScale] ) <br />
			[method:AnimationClip CreateRotationAnimation](  [param:number period],  [param:string axis] ) <br />
			[method:AnimationClip CreateScaleAxisAnimation](  [param:number period],  [param:string axis] ) <br />
			[method:AnimationClip CreateShakeAnimation](  [param:number duration],  [param:Vector3 shakeScale] ) <br />
			[method:AnimationClip CreateVisibilityAnimation](  [param:number duration] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="AnimationLoader">AnimationLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AnimationLoader AnimationLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:AnimationLoader AnimationLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:AnimationClip[] parse](  [param:any json] ) <br />
			[method:AnimationLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:AnimationLoader setPath](  [param:string path] ) <br />
			[method:AnimationLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:AnimationLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:AnimationLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="AnimationMixer">AnimationMixer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AnimationMixer AnimationMixer](  [param:AnimationObjectGroup|Object3D root] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:AnimationMixer AnimationMixer](  [param:AnimationObjectGroup|Object3D root] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number time] -  The time.<br />
			[property:number timeScale] -  The time scale.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:AnimationAction clipAction](  [param:AnimationClip clip],  [param:AnimationObjectGroup|Object3D root]?,  [param:AnimationBlendMode blendMode]? ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:AnimationAction existingAction](  [param:AnimationClip clip],  [param:AnimationObjectGroup|Object3D root]? ) <br />
			[method:AnimationObjectGroup|Object3D getRoot](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:AnimationMixer setTime](  [param:number timeInSeconds] ) <br />
			[method:AnimationMixer stopAllAction](  ) <br />
			[method:void uncacheAction](  [param:AnimationClip clip],  [param:AnimationObjectGroup|Object3D root]? ) <br />
			[method:void uncacheClip](  [param:AnimationClip clip] ) <br />
			[method:void uncacheRoot](  [param:AnimationObjectGroup|Object3D root] ) <br />
			[method:AnimationMixer update](  [param:number deltaTime] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AnimationObjectGroup">AnimationObjectGroup <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AnimationObjectGroup AnimationObjectGroup](  [param:any[] args] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isAnimationObjectGroup] -  The is animation object group.<br />
			[property:any stats] -  The stats.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void add](  [param:any[] args] ) <br />
			[method:void remove](  [param:any[] args] ) <br />
			[method:void uncache](  [param:any[] args] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AnimationUtils">AnimationUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:any arraySlice](  [param:any array],  [param:number from],  [param:number to] ) <br />
			[method:any convertArray](  [param:any array],  [param:any type],  [param:boolean forceClone] ) <br />
			[method:void flattenJSON](  [param:string[] jsonKeys],  [param:any[] times],  [param:any[] values],  [param:string valuePropertyName] ) <br />
			[method:number[] getKeyFrameOrder](  [param:number[] times] ) <br />
			[method:boolean isTypedArray](  [param:any object] ) <br />
			[method:AnimationClip makeClipAdditive](  [param:AnimationClip targetClip],  [param:number referenceFrame]?,  [param:AnimationClip referenceClip]?,  [param:number fps]? ) <br />
			[method:any[] sortedArray](  [param:any[] values],  [param:number stride],  [param:number[] order] ) <br />
			[method:AnimationClip subclip](  [param:AnimationClip sourceClip],  [param:string name],  [param:number startFrame],  [param:number endFrame],  [param:number fps]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr; [page:EllipseCurve] &rarr;

		<h3 id="ArcCurve">ArcCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ArcCurve ArcCurve](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[constructor:ArcCurve ArcCurve](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[constructor:ArcCurve ArcCurve](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean aClockwise] -  The a clockwise.<br />
			[property:number aEndAngle] -  The a end angle.<br />
			[property:number aRotation] -  The a rotation.<br />
			[property:number aStartAngle] -  The a start angle.<br />
			[property:number aX] -  The a x.<br />
			[property:number aY] -  The a y.<br />
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:number xRadius] -  The x radius.<br />
			[property:number yRadius] -  The y radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ArcCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ArcCurve copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:ArcCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="ArcballControls">ArcballControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ArcballControls ArcballControls](  [param:Camera camera],  [param:HTMLElement domElement],  [param:Scene scene]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:ArcballControls ArcballControls](  [param:Camera camera],  [param:HTMLElement domElement],  [param:Scene scene]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean adjustNearFar] -  The adjust near far.<br />
			[property:Camera camera] -  The camera.<br />
			[property:boolean cursorZoom] -  The cursor zoom.<br />
			[property:number dampingFactor] -  The damping factor.<br />
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:boolean enableAnimations] -  The enable animations.<br />
			[property:boolean enableGizmos] -  The enable gizmos.<br />
			[property:boolean enableGrid] -  The enable grid.<br />
			[property:boolean enablePan] -  The enable pan.<br />
			[property:boolean enableRotate] -  The enable rotate.<br />
			[property:boolean enableZoom] -  The enable zoom.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:number focusAnimationTime] -  The focus animation time.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number maxFov] -  The max fov.<br />
			[property:number maxZoom] -  The max zoom.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:number minFov] -  The min fov.<br />
			[property:number minZoom] -  The min zoom.<br />
			[property:number radiusFactor] -  The radius factor.<br />
			[property:number scaleFactor] -  The scale factor.<br />
			[property:Scene scene]? -  The scene.<br />
			[property:Vector3 target] -  The target.<br />
			[property:number wMax] -  The w max.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void activateGizmos](  [param:boolean isActive] ) <br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void copyState](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Raycaster getRaycaster](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void pasteState](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void reset](  ) <br />
			[method:void saveState](  ) <br />
			[method:void setCamera](  [param:Camera camera] ) <br />
			[method:void setGizmosVisible](  [param:boolean value] ) <br />
			[method:boolean setMouseAction](  [param:ArcballControlsMouseActionOperations operation],  [param:ArcballControlsMouseActionMouse mouse],  [param:ArcballControlsMouseActionKeys key]? ) <br />
			[method:void setTarget](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:void setTbRadius](  [param:number value] ) <br />
			[method:boolean unsetMouseAction](  [param:ArcballControlsMouseActionMouse mouse],  [param:ArcballControlsMouseActionKeys key]? ) <br />
			[method:void update](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Camera] &rarr; [page:PerspectiveCamera] &rarr;

		<h3 id="ArrayCamera">ArrayCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ArrayCamera ArrayCamera](  [param:PerspectiveCamera[] cameras]? ) <br />
			[constructor:ArrayCamera ArrayCamera](  [param:PerspectiveCamera[] cameras]?,  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) <br />
			[constructor:ArrayCamera ArrayCamera](  [param:PerspectiveCamera[] cameras]?,  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) - This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.<br />
			[constructor:ArrayCamera ArrayCamera](  [param:PerspectiveCamera[] cameras]?,  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) - The constructor takes no arguments.<br />
			[constructor:ArrayCamera ArrayCamera](  [param:PerspectiveCamera[] cameras]?,  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number aspect] - Camera frustum aspect ratio, window width divided by window height.<br />
			[property:PerspectiveCamera[] cameras] -  The cameras.<br />
			[property:number far] - Camera frustum far plane.<br />
			[property:number filmGauge] -  The film gauge.<br />
			[property:number filmOffset] -  The film offset.<br />
			[property:number focus] -  The focus.<br />
			[property:number fov] - Camera frustum vertical field of view, from bottom to top of view, in degrees.<br />
			[property:any isArrayCamera] -  The is array camera.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:any isPerspectiveCamera] -  The is perspective camera.<br />
			[property:Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:number near] - Camera frustum near plane.<br />
			[property:Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:any type] -  The type.<br />
			[property:any view] -  The view.<br />
			[property:number zoom] -  The zoom.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ArrayCamera add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:ArrayCamera applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:ArrayCamera attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:ArrayCamera clear](  ) - Removes all child objects.<br />
			[method:void clearViewOffset](  ) <br />
			[method:ArrayCamera clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:ArrayCamera copy](  [param:ArrayCamera source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:number getEffectiveFOV](  ) <br />
			[method:number getFilmHeight](  ) <br />
			[method:number getFilmWidth](  ) <br />
			[method:number getFocalLength](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) <br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:ArrayCamera remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:ArrayCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ArrayCamera rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ArrayCamera rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:ArrayCamera rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:ArrayCamera rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:ArrayCamera rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setFocalLength](  [param:number focalLength] ) <br />
			[method:void setLens](  [param:number focalLength],  [param:number frameHeight]? ) - deprecated - Use {@link PerspectiveCamera#setFocalLength .setFocalLength()} and {@link PerspectiveCamera#filmGauge .filmGauge} instead.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:void setViewOffset](  [param:number fullWidth],  [param:number fullHeight],  [param:number x],  [param:number y],  [param:number width],  [param:number height] ) - Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.<br />
			For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:<br />
			+---+---+---+<br />
			| A | B | C |<br />
			+---+---+---+<br />
			| D | E | F |<br />
			+---+---+---+<br />
			<br />
			then for each monitor you would call it like this:<br />
			<br />
			const w = 1920;<br />
			const h = 1080;<br />
			const fullWidth = w * 3;<br />
			const fullHeight = h * 2;<br />
			<br />
			// A<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h ) : this;<br />
			// B<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h ) : this;<br />
			// C<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h ) : this;<br />
			// D<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h ) : this;<br />
			// E<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h ) : this;<br />
			// F<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ) : this; Note there is no reason monitors have to be the same size or in a grid.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ArrayCamera translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ArrayCamera translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:ArrayCamera translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:ArrayCamera translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateProjectionMatrix](  ) - Updates the camera projection matrix. Must be called after change of parameters.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="ArrowHelper">ArrowHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ArrowHelper ArrowHelper](  [param:Vector3 dir]?,  [param:Vector3 origin]?,  [param:number length]?,  [param:ColorRepresentation color]?,  [param:number headLength]?,  [param:number headWidth]? ) <br />
			[constructor:ArrowHelper ArrowHelper](  [param:Vector3 dir]?,  [param:Vector3 origin]?,  [param:number length]?,  [param:ColorRepresentation color]?,  [param:number headLength]?,  [param:number headWidth]? ) - The constructor takes no arguments.<br />
			[constructor:ArrowHelper ArrowHelper](  [param:Vector3 dir]?,  [param:Vector3 origin]?,  [param:number length]?,  [param:ColorRepresentation color]?,  [param:number headLength]?,  [param:number headWidth]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Mesh cone] - Contains the cone part of the arrowHelper.<br />
			[property:Line line] - Contains the line part of the arrowHelper.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ArrowHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:ArrowHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:ArrowHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:ArrowHelper clear](  ) - Removes all child objects.<br />
			[method:ArrowHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:ArrowHelper copy](  [param:ArrowHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:ArrowHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:ArrowHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ArrowHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ArrowHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:ArrowHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:ArrowHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:ArrowHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setColor](  [param:ColorRepresentation color] ) <br />
			[method:void setDirection](  [param:Vector3 dir] ) <br />
			[method:void setLength](  [param:number length],  [param:number headLength]?,  [param:number headWidth]? ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ArrowHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ArrowHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:ArrowHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:ArrowHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AsciiEffect">AsciiEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsciiEffect AsciiEffect](  [param:WebGLRenderer renderer],  [param:string charSet]?,  [param:AsciiEffectOptions options]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AsciiEffectOptions">AsciiEffectOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean alpha]? -  The alpha.<br />
			[property:boolean block]? -  The block.<br />
			[property:boolean color]? -  The color.<br />
			[property:boolean invert]? -  The invert.<br />
			[property:number resolution]? -  The resolution.<br />
			[property:number scale]? -  The scale.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncDecompress">AsyncDecompress <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsyncDecompress AsyncDecompress](  [param:AsyncFlateStreamHandler cb]? ) - Creates an asynchronous decompression stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:AsyncFlateStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be decompressed
		</p>

		<p class="desc">
			Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncDeflate">AsyncDeflate <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsyncDeflate AsyncDeflate](  [param:DeflateOptions opts],  [param:AsyncFlateStreamHandler cb]? ) - Creates an asynchronous DEFLATE stream<br />
			[constructor:AsyncDeflate AsyncDeflate](  [param:DeflateOptions opts],  [param:AsyncFlateStreamHandler cb]?,  [param:AsyncFlateStreamHandler cb]? ) - Creates an asynchronous DEFLATE stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:AsyncFlateStreamHandler ondata] - The handler to call whenever data is available<br />
			[property:AsyncTerminable terminate] - A method to terminate the stream's internal worker. Subsequent calls to<br />
			push() will silently fail.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be deflated
		</p>

		<p class="desc">
			Asynchronous streaming DEFLATE compression
		</p>

		<hr class="interface-line"/>
		[page:DeflateOptions] &rarr;

		<h3 id="AsyncDeflateOptions">AsyncDeflateOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean consume]? - Whether or not to "consume" the source data. This will make the typed array/buffer you pass in<br />
			unusable but will increase performance and reduce memory usage.<br />
			[property:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' level]? - The level of compression to use, ranging from 0-9.<br />
			0 will store the data without compression.<br />
			1 is fastest but compresses the worst, 9 is slowest but compresses the best.<br />
			The default level is 6.<br />
			<br />
			Typically, binary data benefits much more from higher values than text data.<br />
			In both cases, higher values usually take disproportionately longer than the reduction in final size that results.<br />
			<br />
			For example, a 1 MB text file could:<br />
			- become 1.01 MB with level 0 in 1ms<br />
			- become 400 kB with level 1 in 10ms<br />
			- become 320 kB with level 9 in 100ms<br />
			[property:'0'|'1'|'2'|'3'|'4'|'10'|'5'|'6'|'7'|'8'|'9'|'11'|'12' mem]? - The memory level to use, ranging from 0-12. Increasing this increases speed and compression ratio at the cost of memory.<br />
			Note that this is exponential: while level 0 uses 4 kB, level 4 uses 64 kB, level 8 uses 1 MB, and level 12 uses 16 MB.<br />
			It is recommended not to lower the value below 4, since that tends to hurt performance.<br />
			In addition, values above 8 tend to help very little on most data and can even hurt performance.<br />
			<br />
			The default value is automatically determined based on the size of the input data.
		</p>

		<p class="desc">
			Options for compressing data asynchronously into a DEFLATE format
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncGunzip">AsyncGunzip <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsyncGunzip AsyncGunzip](  [param:AsyncFlateStreamHandler cb] ) - Creates an asynchronous GUNZIP stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:AsyncFlateStreamHandler ondata] - The handler to call whenever data is available<br />
			[property:AsyncTerminable terminate] - A method to terminate the stream's internal worker. Subsequent calls to<br />
			push() will silently fail.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be GUNZIPped
		</p>

		<p class="desc">
			Asynchronous streaming GZIP decompression
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncGzip">AsyncGzip <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsyncGzip AsyncGzip](  [param:GzipOptions opts],  [param:AsyncFlateStreamHandler cb]? ) - Creates an asynchronous GZIP stream<br />
			[constructor:AsyncGzip AsyncGzip](  [param:GzipOptions opts],  [param:AsyncFlateStreamHandler cb]?,  [param:AsyncFlateStreamHandler cb]? ) - Creates an asynchronous GZIP stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:AsyncFlateStreamHandler ondata] - The handler to call whenever data is available<br />
			[property:AsyncTerminable terminate] - A method to terminate the stream's internal worker. Subsequent calls to<br />
			push() will silently fail.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be GZIPped
		</p>

		<p class="desc">
			Asynchronous streaming GZIP compression
		</p>

		<hr class="interface-line"/>
		[page:DeflateOptions] &rarr; [page:GzipOptions] &rarr;

		<h3 id="AsyncGzipOptions">AsyncGzipOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean consume]? - Whether or not to "consume" the source data. This will make the typed array/buffer you pass in<br />
			unusable but will increase performance and reduce memory usage.<br />
			[property:string filename]? - The filename of the data. If the `gunzip` command is used to decompress the data, it will output a file<br />
			with this name instead of the name of the compressed file.<br />
			[property:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' level]? - The level of compression to use, ranging from 0-9.<br />
			0 will store the data without compression.<br />
			1 is fastest but compresses the worst, 9 is slowest but compresses the best.<br />
			The default level is 6.<br />
			<br />
			Typically, binary data benefits much more from higher values than text data.<br />
			In both cases, higher values usually take disproportionately longer than the reduction in final size that results.<br />
			<br />
			For example, a 1 MB text file could:<br />
			- become 1.01 MB with level 0 in 1ms<br />
			- become 400 kB with level 1 in 10ms<br />
			- become 320 kB with level 9 in 100ms<br />
			[property:'0'|'1'|'2'|'3'|'4'|'10'|'5'|'6'|'7'|'8'|'9'|'11'|'12' mem]? - The memory level to use, ranging from 0-12. Increasing this increases speed and compression ratio at the cost of memory.<br />
			Note that this is exponential: while level 0 uses 4 kB, level 4 uses 64 kB, level 8 uses 1 MB, and level 12 uses 16 MB.<br />
			It is recommended not to lower the value below 4, since that tends to hurt performance.<br />
			In addition, values above 8 tend to help very little on most data and can even hurt performance.<br />
			<br />
			The default value is automatically determined based on the size of the input data.<br />
			[property:string|number|Date mtime]? - When the file was last modified. Defaults to the current time.<br />
			Set this to 0 to avoid revealing a modification date entirely.
		</p>

		<p class="desc">
			Options for compressing data asynchronously into a GZIP format
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncInflate">AsyncInflate <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsyncInflate AsyncInflate](  [param:AsyncFlateStreamHandler cb]? ) - Creates an asynchronous inflation stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:AsyncFlateStreamHandler ondata] - The handler to call whenever data is available<br />
			[property:AsyncTerminable terminate] - A method to terminate the stream's internal worker. Subsequent calls to<br />
			push() will silently fail.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be inflated
		</p>

		<p class="desc">
			Asynchronous streaming DEFLATE decompression
		</p>

		<hr class="interface-line"/>
		[page:AsyncOptions] &rarr;

		<h3 id="AsyncInflateOptions">AsyncInflateOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean consume]? - Whether or not to "consume" the source data. This will make the typed array/buffer you pass in<br />
			unusable but will increase performance and reduce memory usage.<br />
			[property:number size]? - The original size of the data. Currently, the asynchronous API disallows<br />
			writing into a buffer you provide; the best you can do is provide the<br />
			size in bytes and be given back a new typed array.
		</p>

		<p class="desc">
			Options for decompressing DEFLATE data asynchronously
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncOptions">AsyncOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean consume]? - Whether or not to "consume" the source data. This will make the typed array/buffer you pass in<br />
			unusable but will increase performance and reduce memory usage.
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncUnzipInflate">AsyncUnzipInflate <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsyncUnzipInflate AsyncUnzipInflate](  [param:string _],  [param:number sz]? ) - Creates a DEFLATE decompression that can be used in ZIP archives
		</p>
		<h4>Properties</h4>
		<p>
			[property:number compression] -  The compression.<br />
			[property:AsyncFlateStreamHandler ondata] -  The ondata.<br />
			[property:AsyncTerminable terminate] -  The terminate.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array data],  [param:boolean final] ) 
		</p>

		<p class="desc">
			Asynchronous streaming DEFLATE decompression for ZIP archives
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncUnzlib">AsyncUnzlib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsyncUnzlib AsyncUnzlib](  [param:AsyncFlateStreamHandler cb]? ) - Creates an asynchronous Zlib decompression stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:AsyncFlateStreamHandler ondata] - The handler to call whenever data is available<br />
			[property:AsyncTerminable terminate] - A method to terminate the stream's internal worker. Subsequent calls to<br />
			push() will silently fail.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be decompressed from Zlib
		</p>

		<p class="desc">
			Asynchronous streaming Zlib decompression
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncZipDeflate">AsyncZipDeflate <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsyncZipDeflate AsyncZipDeflate](  [param:string filename],  [param:DeflateOptions opts]? ) - Creates a DEFLATE stream that can be added to ZIP archives
		</p>
		<h4>Properties</h4>
		<p>
			[property:number attrs]? -  The attrs.<br />
			[property:string comment]? -  The comment.<br />
			[property:number compression] -  The compression.<br />
			[property:number crc] -  The crc.<br />
			[property:Record extra]? -  The extra.<br />
			[property:string filename] -  The filename.<br />
			[property:'0'|'1'|'2'|'3' flag] -  The flag.<br />
			[property:string|number|Date mtime]? -  The mtime.<br />
			[property:AsyncFlateStreamHandler ondata] -  The ondata.<br />
			[property:number os]? -  The os.<br />
			[property:number size] -  The size.<br />
			[property:AsyncTerminable terminate] -  The terminate.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void process](  [param:Uint8Array chunk],  [param:boolean final] ) <br />
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be deflated
		</p>

		<p class="desc">
			Asynchronous streaming DEFLATE compression for ZIP archives
		</p>

		<hr class="interface-line"/>
		[page:DeflateOptions] &rarr; [page:AsyncDeflateOptions] &rarr;

		<h3 id="AsyncZipOptions">AsyncZipOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number attrs]? - The file's attributes. These are traditionally somewhat complicated<br />
			and platform-dependent, so using them is scarcely necessary. However,<br />
			here is a representation of what this is, bit by bit:<br />
			`TTTTugtrwxrwxrwx0000000000ADVSHR`<br />
			<br />
			TTTT = file type (rarely useful)<br />
			<br />
			u = setuid, g = setgid, t = sticky<br />
			<br />
			rwx = user permissions, rwx = group permissions, rwx = other permissions<br />
			<br />
			0000000000 = unused<br />
			<br />
			A = archive, D = directory, V = volume label, S = system file, H = hidden, R = read-only<br />
			<br />
			If you want to set the Unix permissions, for instance, just bit shift by 16, e.g. 0644 &lt;&lt; 16<br />
			[property:string comment]? - The comment to attach to the file. This field is defined by PKZIP's APPNOTE.txt,<br />
			section 4.4.26. The comment must be at most 65,535 bytes long UTF-8 encoded. This<br />
			field is not read by consumer software.<br />
			[property:boolean consume]? - Whether or not to "consume" the source data. This will make the typed array/buffer you pass in<br />
			unusable but will increase performance and reduce memory usage.<br />
			[property:Record extra]? - Extra metadata to add to the file. This field is defined by PKZIP's APPNOTE.txt,<br />
			section 4.4.28. At most 65,535 bytes may be used in each ID. The ID must be an<br />
			integer between 0 and 65,535, inclusive.<br />
			This field is incredibly rare and almost never needed except for compliance with<br />
			proprietary standards and software.<br />
			[property:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' level]? - The level of compression to use, ranging from 0-9.<br />
			0 will store the data without compression.<br />
			1 is fastest but compresses the worst, 9 is slowest but compresses the best.<br />
			The default level is 6.<br />
			<br />
			Typically, binary data benefits much more from higher values than text data.<br />
			In both cases, higher values usually take disproportionately longer than the reduction in final size that results.<br />
			<br />
			For example, a 1 MB text file could:<br />
			- become 1.01 MB with level 0 in 1ms<br />
			- become 400 kB with level 1 in 10ms<br />
			- become 320 kB with level 9 in 100ms<br />
			[property:'0'|'1'|'2'|'3'|'4'|'10'|'5'|'6'|'7'|'8'|'9'|'11'|'12' mem]? - The memory level to use, ranging from 0-12. Increasing this increases speed and compression ratio at the cost of memory.<br />
			Note that this is exponential: while level 0 uses 4 kB, level 4 uses 64 kB, level 8 uses 1 MB, and level 12 uses 16 MB.<br />
			It is recommended not to lower the value below 4, since that tends to hurt performance.<br />
			In addition, values above 8 tend to help very little on most data and can even hurt performance.<br />
			<br />
			The default value is automatically determined based on the size of the input data.<br />
			[property:string|number|Date mtime]? - When the file was last modified. Defaults to the current time.<br />
			[property:number os]? - The operating system of origin for this file. The value is defined<br />
			by PKZIP's APPNOTE.txt, section 4.4.2.2. For example, 0 (the default)<br />
			is MS/DOS, 3 is UNIX, 19 is macOS.
		</p>

		<p class="desc">
			Options for asynchronously creating a ZIP archive
		</p>


		<p class="desc">
			The complete directory structure of an asynchronously ZIPpable archive
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncZlib">AsyncZlib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AsyncZlib AsyncZlib](  [param:DeflateOptions opts],  [param:AsyncFlateStreamHandler cb]? ) - Creates an asynchronous DEFLATE stream<br />
			[constructor:AsyncZlib AsyncZlib](  [param:DeflateOptions opts],  [param:AsyncFlateStreamHandler cb]?,  [param:AsyncFlateStreamHandler cb]? ) - Creates an asynchronous DEFLATE stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:AsyncFlateStreamHandler ondata] - The handler to call whenever data is available<br />
			[property:AsyncTerminable terminate] - A method to terminate the stream's internal worker. Subsequent calls to<br />
			push() will silently fail.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be deflated
		</p>

		<p class="desc">
			Asynchronous streaming Zlib compression
		</p>

		<hr class="interface-line"/>
		[page:ZlibOptions] &rarr;

		<h3 id="AsyncZlibOptions">AsyncZlibOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean consume]? - Whether or not to "consume" the source data. This will make the typed array/buffer you pass in<br />
			unusable but will increase performance and reduce memory usage.<br />
			[property:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' level]? - The level of compression to use, ranging from 0-9.<br />
			0 will store the data without compression.<br />
			1 is fastest but compresses the worst, 9 is slowest but compresses the best.<br />
			The default level is 6.<br />
			<br />
			Typically, binary data benefits much more from higher values than text data.<br />
			In both cases, higher values usually take disproportionately longer than the reduction in final size that results.<br />
			<br />
			For example, a 1 MB text file could:<br />
			- become 1.01 MB with level 0 in 1ms<br />
			- become 400 kB with level 1 in 10ms<br />
			- become 320 kB with level 9 in 100ms<br />
			[property:'0'|'1'|'2'|'3'|'4'|'10'|'5'|'6'|'7'|'8'|'9'|'11'|'12' mem]? - The memory level to use, ranging from 0-12. Increasing this increases speed and compression ratio at the cost of memory.<br />
			Note that this is exponential: while level 0 uses 4 kB, level 4 uses 64 kB, level 8 uses 1 MB, and level 12 uses 16 MB.<br />
			It is recommended not to lower the value below 4, since that tends to hurt performance.<br />
			In addition, values above 8 tend to help very little on most data and can even hurt performance.<br />
			<br />
			The default value is automatically determined based on the size of the input data.
		</p>

		<p class="desc">
			Options for compressing data asynchronously into a Zlib format
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="AttributeNode">AttributeNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AttributeNode AttributeNode](  [param:string name],  [param:string type]? ) <br />
			[constructor:AttributeNode AttributeNode](  [param:string name],  [param:string type]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:AttributeNode AttributeNode](  [param:string name],  [param:string type]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:AttributeNode copy](  [param:AttributeNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getAttributeType](  [param:NodeBuilder builder] ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:AttributeNode setLabel](  [param:string name] ) <br />
			[method:AttributeNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Audio">Audio <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Audio Audio](  [param:AudioListener listener] ) - The constructor takes no arguments.<br />
			[constructor:Audio Audio](  [param:AudioListener listener] ) - The constructor takes no arguments.<br />
			[constructor:Audio Audio](  [param:AudioListener listener] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoplay] -  The autoplay.<br />
			[property:AudioBuffer buffer] -  The buffer.<br />
			[property:AudioContext context] -  The context.<br />
			[property:number detune] -  The detune.<br />
			[property:number duration] -  The duration.<br />
			[property:AudioNode[] filters] -  The filters.<br />
			[property:GainNode gain] -  The gain.<br />
			[property:boolean hasPlaybackControl] -  The has playback control.<br />
			[property:boolean isPlaying] -  The is playing.<br />
			[property:AudioListener listener] -  The listener.<br />
			[property:boolean loop] -  The loop.<br />
			[property:number loopEnd] -  The loop end.<br />
			[property:number loopStart] -  The loop start.<br />
			[property:number offset] -  The offset.<br />
			[property:number playbackRate] -  The playback rate.<br />
			[property:AudioBufferSourceNode source] -  The source.<br />
			[property:string sourceType] -  The source type.<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Audio add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Audio applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Audio attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Audio clear](  ) - Removes all child objects.<br />
			[method:Audio clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Audio connect](  ) <br />
			[method:Audio copy](  [param:Audio source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:Audio disconnect](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:number getDetune](  ) <br />
			[method:AudioNode getFilter](  ) <br />
			[method:AudioNode[] getFilters](  ) <br />
			[method:boolean getLoop](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:NodeType getOutput](  ) <br />
			[method:number getPlaybackRate](  ) <br />
			[method:number getVolume](  ) <br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Audio load](  [param:string file] ) - deprecated - Use {@link AudioLoader} instead.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onEnded](  ) <br />
			[method:Audio pause](  ) <br />
			[method:Audio play](  [param:number delay]? ) <br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:Audio remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Audio removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Audio rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Audio rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Audio rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Audio rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Audio rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:Audio setBuffer](  [param:AudioBuffer audioBuffer] ) <br />
			[method:Audio setDetune](  [param:number value] ) <br />
			[method:Audio setFilter](  [param:AudioNode filter] ) <br />
			[method:Audio setFilters](  [param:AudioNode[] value] ) <br />
			[method:Audio setLoop](  [param:boolean value] ) <br />
			[method:Audio setLoopEnd](  [param:number value] ) <br />
			[method:Audio setLoopStart](  [param:number value] ) <br />
			[method:Audio setMediaElementSource](  [param:HTMLMediaElement mediaElement] ) <br />
			[method:Audio setMediaStreamSource](  [param:MediaStream mediaStream] ) <br />
			[method:Audio setNodeSource](  [param:AudioBufferSourceNode audioNode] ) <br />
			[method:Audio setPlaybackRate](  [param:number value] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:Audio setVolume](  [param:number value] ) <br />
			[method:Audio stop](  ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Audio translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Audio translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Audio translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Audio translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AudioAnalyser">AudioAnalyser <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AudioAnalyser AudioAnalyser](  [param:Audio audio],  [param:number fftSize]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:AnalyserNode analyser] -  The analyser.<br />
			[property:Uint8Array data] -  The data.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number getAverageFrequency](  ) <br />
			[method:any getData](  [param:any file] ) - deprecated - Use {@link AudioAnalyser#getFrequencyData .getFrequencyData()} instead.<br />
			[method:Uint8Array getFrequencyData](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AudioContext">AudioContext <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number currentTime] -  The current time.<br />
			[property:AudioDestinationNode destination] -  The destination.<br />
			[property:AudioListener listener] -  The listener.<br />
			[property:number sampleRate] -  The sample rate.<br />
			[property:any state] -  The state.
		</p>
		<h4>Methods</h4>
		<p>
			[method:OscillatorNode createOscillator](  ) <br />
			[method:AudioContext getContext](  ) <br />
			[method:void setContext](  ) 
		</p>

		<p class="desc">
			see {@link https://github.com/mrdoob/three.js/blob/master/src/audio/AudioContext.js|src/audio/AudioContext.js}
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="AudioListener">AudioListener <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AudioListener AudioListener](  ) - The constructor takes no arguments.<br />
			[constructor:AudioListener AudioListener](  ) - The constructor takes no arguments.<br />
			[constructor:AudioListener AudioListener](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:AudioContext context] -  The context.<br />
			[property:any filter] -  The filter.<br />
			[property:GainNode gain] -  The gain.<br />
			[property:number timeDelta] -  The time delta.<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:AudioListener add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:AudioListener applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:AudioListener attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:AudioListener clear](  ) - Removes all child objects.<br />
			[method:AudioListener clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:AudioListener copy](  [param:AudioListener source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:any getFilter](  ) <br />
			[method:GainNode getInput](  ) <br />
			[method:number getMasterVolume](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:AudioListener remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:AudioListener removeFilter](  ) <br />
			[method:AudioListener removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:AudioListener rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:AudioListener rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:AudioListener rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:AudioListener rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:AudioListener rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:AudioListener setFilter](  [param:any value] ) <br />
			[method:AudioListener setMasterVolume](  [param:number value] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:AudioListener translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:AudioListener translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:AudioListener translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:AudioListener translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="AudioLoader">AudioLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AudioLoader AudioLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:AudioLoader AudioLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:AudioLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:AudioLoader setPath](  [param:string path] ) <br />
			[method:AudioLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:AudioLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:AudioLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AudioManager">AudioManager <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AudioManager AudioManager](  [param:Audio audio],  [param:AudioManagerParameter params]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Audio audio] -  The audio.<br />
			[property:number audioDuration] -  The audio duration.<br />
			[property:number currentTime] -  The current time.<br />
			[property:number delayTime] -  The delay time.<br />
			[property:number duration] -  The duration.<br />
			[property:number elapsedTime] -  The elapsed time.
		</p>
		<h4>Methods</h4>
		<p>
			[method:AudioManager control](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AudioManagerParameter">AudioManagerParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number delayTime]? -  The delay time.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="AxesHelper">AxesHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:AxesHelper AxesHelper](  [param:number size]? ) <br />
			[constructor:AxesHelper AxesHelper](  [param:number size]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:AxesHelper AxesHelper](  [param:number size]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:AxesHelper AxesHelper](  [param:number size]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:AxesHelper AxesHelper](  [param:number size]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:AxesHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:AxesHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:AxesHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:AxesHelper clear](  ) - Removes all child objects.<br />
			[method:AxesHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:AxesHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:AxesHelper copy](  [param:AxesHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:AxesHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:AxesHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:AxesHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:AxesHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:AxesHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:AxesHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:AxesHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:AxesHelper setColors](  [param:Color xAxisColor],  [param:Color yAxisColor],  [param:Color zAxisColor] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:AxesHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:AxesHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:AxesHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:AxesHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="BVHLoader">BVHLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BVHLoader BVHLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:BVHLoader BVHLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean animateBonePositions] -  The animate bone positions.<br />
			[property:boolean animateBoneRotations] -  The animate bone rotations.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:BVH parse](  [param:string text] ) <br />
			[method:BVHLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:BVHLoader setPath](  [param:string path] ) <br />
			[method:BVHLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:BVHLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:BVHLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BaseEvent">BaseEvent <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr;

		<h3 id="BasicNode">BasicNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BasicNode BasicNode](  ) <br />
			[constructor:BasicNode BasicNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode alpha] -  The alpha.<br />
			[property:NodeNode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:NodeNode mask] -  The mask.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:NodeNode position] -  The position.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder] ) <br />
			[method:BasicNode copy](  [param:BasicNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:BasicNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:ShaderMaterial] &rarr; [page:NodeMaterial] &rarr;

		<h3 id="BasicNodeMaterial">BasicNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BasicNodeMaterial BasicNodeMaterial](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:BasicNodeMaterial BasicNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:BasicNodeMaterial BasicNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:BasicNodeMaterial BasicNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:BasicNodeMaterial BasicNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode alpha] -  The alpha.<br />
			[property:NodeNode color] -  The color.<br />
			[property:NodeNode|RawNode fragment] -  The fragment.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:NodeNode mask] -  The mask.<br />
			[property:NodeNode position] -  The position.<br />
			[property:object properties] -  The properties.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:NodeNode|RawNode vertex] -  The vertex.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:BasicNodeMaterial build](  [param:NodeMaterialBuildParams params]? ) <br />
			[method:BasicNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:BasicNodeMaterial copy](  [param:NodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BasicShader">BasicShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="BasisTextureLoader">BasisTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BasisTextureLoader BasisTextureLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:BasisTextureLoader BasisTextureLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayBuffer transcoderBinary] -  The transcoder binary.<br />
			[property:string transcoderPath] -  The transcoder path.<br />
			[property:Promise transcoderPending] -  The transcoder pending.<br />
			[property:any workerConfig] -  The worker config.<br />
			[property:number workerLimit] -  The worker limit.<br />
			[property:number workerNextTaskID] -  The worker next task i d.<br />
			[property:object[] workerPool] -  The worker pool.<br />
			[property:string workerSourceURL] -  The worker source u r l.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BasisTextureLoader detectSupport](  [param:WebGLRenderer renderer] ) <br />
			[method:void dispose](  ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:BasisTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:BasisTextureLoader setPath](  [param:string path] ) <br />
			[method:BasisTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:BasisTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:BasisTextureLoader setTranscoderPath](  [param:string path] ) <br />
			[method:BasisTextureLoader setWithCredentials](  [param:boolean value] ) <br />
			[method:BasisTextureLoader setWorkerLimit](  [param:number workerLimit] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BleachBypassShader">BleachBypassShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BlendShader">BlendShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="BloomPass">BloomPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BloomPass BloomPass](  [param:number strength]?,  [param:number kernelSize]?,  [param:number sigma]?,  [param:number resolution]? ) <br />
			[constructor:BloomPass BloomPass](  [param:number strength]?,  [param:number kernelSize]?,  [param:number sigma]?,  [param:number resolution]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:object convolutionUniforms] -  The convolution uniforms.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ShaderMaterial materialConvolution] -  The material convolution.<br />
			[property:ShaderMaterial materialCopy] -  The material copy.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:WebGLRenderTarget renderTargetX] -  The render target x.<br />
			[property:WebGLRenderTarget renderTargetY] -  The render target y.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="BlurNode">BlurNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BlurNode BlurNode](  [param:TextureNode value],  [param:UVNode uv]?,  [param:number radius]?,  [param:Vector2 size]? ) <br />
			[constructor:BlurNode BlurNode](  [param:TextureNode value],  [param:UVNode uv]?,  [param:number radius]?,  [param:Vector2 size]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:BlurNode BlurNode](  [param:TextureNode value],  [param:UVNode uv]?,  [param:number radius]?,  [param:Vector2 size]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:boolean blurX] -  The blur x.<br />
			[property:boolean blurY] -  The blur y.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:FloatNode horizontal] -  The horizontal.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:Vector2Node radius] -  The radius.<br />
			[property:boolean shared] -  The shared.<br />
			[property:Vector2 size] -  The size.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:UVNode uv] -  The uv.<br />
			[property:TextureNode value] -  The value.<br />
			[property:FloatNode vertical] -  The vertical.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:BlurNode copy](  [param:BlurNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:BlurNode setLabel](  [param:string name] ) <br />
			[method:BlurNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BlurShaderUtils">BlurShaderUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void configure](  [param:Material configure],  [param:number kernelRadius],  [param:number stdDev],  [param:Vector2 uvIncrement] ) <br />
			[method:Vector2[] createSampleOffsets](  [param:number kernelRadius],  [param:Vector2 uvIncrement] ) <br />
			[method:number[] createSampleWeights](  [param:number kernelRadius],  [param:number stdDev] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BokehDepthShader">BokehDepthShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="BokehPass">BokehPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BokehPass BokehPass](  [param:Scene scene],  [param:Camera camera],  [param:BokehPassParamters params] ) <br />
			[constructor:BokehPass BokehPass](  [param:Scene scene],  [param:Camera camera],  [param:BokehPassParamters params] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Camera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ShaderMaterial materialBokeh] -  The material bokeh.<br />
			[property:MeshDepthMaterial materialDepth] -  The material depth.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:Color oldClearColor] -  The old clear color.<br />
			[property:WebGLRenderTarget renderTargetColor] -  The render target color.<br />
			[property:WebGLRenderTarget renderTargetDepth] -  The render target depth.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:Scene scene] -  The scene.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BokehPassParamters">BokehPassParamters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number aperture]? -  The aperture.<br />
			[property:number aspect]? -  The aspect.<br />
			[property:number focus]? -  The focus.<br />
			[property:number height]? -  The height.<br />
			[property:number maxblur]? -  The maxblur.<br />
			[property:number width]? -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BokehShader">BokehShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Bone">Bone <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Bone Bone](  ) - Creates a new Bone.<br />
			[constructor:Bone Bone](  ) - The constructor takes no arguments.<br />
			[constructor:Bone Bone](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isBone] -  The is bone.<br />
			[property:any type] - Set to 'Bone', this can be used to find all Bones in a scene.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Bone add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Bone applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Bone attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Bone clear](  ) - Removes all child objects.<br />
			[method:Bone clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Bone copy](  [param:Bone source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:Bone remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Bone removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Bone rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Bone rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Bone rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Bone rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Bone rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Bone translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Bone translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Bone translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Bone translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			A bone which is part of a [Skeleton](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Skeleton). The skeleton in turn is used by the [SkinnedMesh](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/SkinnedMesh).<br />
			Bones are almost identical to a blank [Object3D](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Object3D).<br />
			<code data-type="javascript"><br />
			const root = new THREE.Bone();<br />
			const child = new THREE.Bone();<br />
			root.add( child );<br />
			child.position.y = 5;<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="BoolNode">BoolNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BoolNode BoolNode](  [param:boolean value]? ) <br />
			[constructor:BoolNode BoolNode](  [param:boolean value]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:BoolNode BoolNode](  [param:boolean value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:BoolNode BoolNode](  [param:boolean value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:BoolNode copy](  [param:BoolNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:BoolNode setLabel](  [param:string name] ) <br />
			[method:BoolNode setName](  [param:string name] ) <br />
			[method:BoolNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:KeyframeTrack] &rarr;

		<h3 id="BooleanKeyframeTrack">BooleanKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BooleanKeyframeTrack BooleanKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values] ) <br />
			[constructor:BooleanKeyframeTrack BooleanKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:string name],  [param:ArrayLike times],  [param:ArrayLike values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:LinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:CubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:BooleanKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:KeyframeTrack optimize](  ) <br />
			[method:KeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:KeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:KeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:any toJSON](  [param:KeyframeTrack track] ) <br />
			[method:KeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Box2">Box2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Box2 Box2](  [param:Vector2 min]?,  [param:Vector2 max]? ) - Creates a Box2 bounded by min and max.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Vector2 max] - [page:Vector2 Vector2] representing the lower upper (x, y) boundary of the box.<br />
			Default is ( - Infinity, - Infinity ).<br />
			[property:Vector2 min] - [page:Vector2 Vector2] representing the lower (x, y) boundary of the box.<br />
			Default is ( + Infinity, + Infinity ).
		</p>
		<h4>Methods</h4>
		<p>
			[method:Vector2 clampPoint](  [param:Vector2 point],  [param:Vector2 target] ) - [link:https://en.wikipedia.org/wiki/Clamping_(graphics Clamps]) the [page:Vector2 point] within the bounds of this box.<br />
			[method:Box2 clone](  ) - Returns : Returns a new [page:Box2 Box2] with the same *.min* and *.max* as this one.<br />
			[method:boolean containsBox](  [param:Box2 box] ) - Returns : Returns true if this box includes the entirety of [page:Box2 box]. If this and [page:Box2 box] are identical,  this function also returns true.<br />
			[method:boolean containsPoint](  [param:Vector2 point] ) - Returns true if the specified point lies within or on the boundaries of this box.<br />
			<br />
			Returns : Returns true if the specified [page:Vector2 point] lies within or on the boundaries of this box.<br />
			[method:Box2 copy](  [param:Box2 box] ) - Copies the *.min* and *.max* from [page:Box2 box] to this box.<br />
			[method:number distanceToPoint](  [param:Vector2 point] ) - If the [point](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Vector2) lies inside of this box, the distance will be 0.<br />
			<br />
			Returns : Returns the distance from any edge of this box to the specified point.<br />
			[method:any empty](  ) - deprecated - Use {@link Box2#isEmpty .isEmpty()} instead.<br />
			[method:boolean equals](  [param:Box2 box] ) - Returns : Returns true if this box and [page:Box2 box] share the same lower and upper bounds.<br />
			[method:Box2 expandByPoint](  [param:Vector2 point] ) - Expands the boundaries of this box to include [page:Vector2 point].<br />
			[method:Box2 expandByScalar](  [param:number scalar] ) - Expands each dimension of the box by [page:Float scalar]. If negative, the dimensions of the box will be contracted.<br />
			[method:Box2 expandByVector](  [param:Vector2 vector] ) - Expands this box equilaterally by [page:Vector2 vector]. The width of this box will be expanded by the x component of [page:Vector2 vector] in both directions. The height of this box will be expanded by the y component of [page:Vector2 vector] in both directions.<br />
			[method:Vector2 getCenter](  [param:Vector2 target] ) - Returns : Returns the center point of the box as a [page:Vector2 Vector2].<br />
			[method:Vector2 getParameter](  [param:Vector2 point],  [param:Vector2 target] ) - Returns : Returns a point as a proportion of this box's width and height.<br />
			[method:Vector2 getSize](  [param:Vector2 target] ) - Returns : Returns the width and height of this box.<br />
			[method:Box2 intersect](  [param:Box2 box] ) - Returns : Returns the intersection of this and [page:Box2 box], setting the upper bound of this box to the lesser of the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' lower bounds.<br />
			[method:boolean intersectsBox](  [param:Box2 box] ) - Determines whether or not this box intersects [page:Box2 box].<br />
			[method:boolean isEmpty](  ) - Returns : Returns true if this box includes zero points within its bounds.<br />
			Note that a box with equal lower and upper bounds still includes one point, the one both bounds share.<br />
			[method:any isIntersectionBox](  [param:any b] ) - deprecated - Use {@link Box2#intersectsBox .intersectsBox()} instead.<br />
			[method:Box2 makeEmpty](  ) - Makes this box empty.<br />
			[method:Box2 set](  [param:Vector2 min],  [param:Vector2 max] ) - Sets the lower and upper (x, y) boundaries of this box.<br />
			Please note that this method only copies the values from the given objects.<br />
			[method:Box2 setFromCenterAndSize](  [param:Vector2 center],  [param:Vector2 size] ) - Centers this box on [page:Vector2 center] and sets this box's width and height to the values specified in [page:Vector2 size].<br />
			[method:Box2 setFromPoints](  [param:Vector2[] points] ) - Sets the upper and lower bounds of this box to include all of the points in [page:Array points].<br />
			[method:Box2 translate](  [param:Vector2 offset] ) - Adds [page:Vector2 offset] to both the upper and lower bounds of this box, effectively moving this box [page:Vector2 offset] units in 2D space.<br />
			[method:Box2 union](  [param:Box2 box] ) - Unions this box with [page:Box2 box], setting the upper bound of this box to the greater of the two boxes' upper bounds and the lower bound of this box to the lesser of the two boxes' lower bounds.
		</p>

		<p class="desc">
			Represents an axis-aligned bounding box (AABB) in 2D space.
		</p>

		<hr class="interface-line"/>
		<h3 id="Box3">Box3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Box3 Box3](  [param:Vector3 min]?,  [param:Vector3 max]? ) - Creates a Box3 bounded by min and max.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isBox3] -  The is box3.<br />
			[property:Vector3 max] - [page:Vector3 Vector3] representing the upper (x, y, z) boundary of the box.<br />
			Default is ( - Infinity, - Infinity, - Infinity ).<br />
			[property:Vector3 min] - [page:Vector3 Vector3] representing the lower (x, y, z) boundary of the box.<br />
			Default is ( + Infinity, + Infinity, + Infinity ).
		</p>
		<h4>Methods</h4>
		<p>
			[method:Box3 applyMatrix4](  [param:Matrix4 matrix] ) <br />
			[method:Vector3 clampPoint](  [param:Vector3 point],  [param:Vector3 target] ) - [link:https://en.wikipedia.org/wiki/Clamping_(graphics Clamps]) the [page:Vector3 point] within the bounds of this box.<br />
			[method:Box3 clone](  ) - Returns : Returns a new [page:Box3 Box3] with the same *.min* and *.max* as this one.<br />
			[method:boolean containsBox](  [param:Box3 box] ) - Returns : Returns true if this box includes the entirety of [page:Box3 box]. If this and [page:Box3 box] are identical,  this function also returns true.<br />
			[method:boolean containsPoint](  [param:Vector3 point] ) - Expands the boundaries of this box to include [page:Vector3 point].<br />
			[method:Box3 copy](  [param:Box3 box] ) - Copies the *.min* and *.max* from [page:Box3 box] to this box.<br />
			[method:number distanceToPoint](  [param:Vector3 point] ) - If the [point](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Vector3) lies inside of this box, the distance will be 0.<br />
			<br />
			Returns : Returns the distance from any edge of this box to the specified point.<br />
			[method:any empty](  ) - deprecated - Use {@link Box3#isEmpty .isEmpty()} instead.<br />
			[method:boolean equals](  [param:Box3 box] ) - Returns : Returns true if this box and [page:Box3 box] share the same lower and upper bounds.<br />
			[method:Box3 expandByObject](  [param:Object3D object] ) - Expands the boundaries of this box to include [page:Object3D object] and its children, accounting for the object's, and children's, world transforms.<br />
			The function may result in a larger box than strictly necessary.<br />
			[method:Box3 expandByPoint](  [param:Vector3 point] ) - Returns : by point<br />
			[method:Box3 expandByScalar](  [param:number scalar] ) - Expands each dimension of the box by [page:Float scalar]. If negative, the dimensions of the box will be contracted.<br />
			[method:Box3 expandByVector](  [param:Vector3 vector] ) - Expands this box equilaterally by [page:Vector3 vector]. The width of this box will be expanded by the x component of [page:Vector3 vector] in both directions. The height of this box will be expanded by the y component of [page:Vector3 vector] in both directions.<br />
			The depth of this box will be expanded by the z component of *vector* in both directions.<br />
			[method:Sphere getBoundingSphere](  [param:Sphere target] ) - Gets a [page:Sphere Sphere] that bounds the box.<br />
			[method:Vector3 getCenter](  [param:Vector3 target] ) - Returns : Returns the center point of the box as a [page:Vector3 Vector3].<br />
			[method:Vector3 getParameter](  [param:Vector3 point],  [param:Vector3 target] ) - Returns : Returns a point as a proportion of this box's width, height and depth.<br />
			[method:Vector3 getSize](  [param:Vector3 target] ) - Returns : Returns the width, height and depth of this box.<br />
			[method:Box3 intersect](  [param:Box3 box] ) - Computes the intersection of this and [page:Box3 box], setting the upper bound of this box to the lesser of the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' lower bounds. If there's no overlap, makes this box empty.<br />
			[method:boolean intersectsBox](  [param:Box3 box] ) - Determines whether or not this box intersects [page:Box3 box].<br />
			[method:boolean intersectsPlane](  [param:Plane plane] ) - Determines whether or not this box intersects [page:Plane plane].<br />
			[method:boolean intersectsSphere](  [param:Sphere sphere] ) - Determines whether or not this box intersects [page:Sphere sphere].<br />
			[method:boolean intersectsTriangle](  [param:Triangle triangle] ) - Determines whether or not this box intersects [page:Triangle triangle].<br />
			[method:boolean isEmpty](  ) - Note that a box with equal lower and upper bounds still includes one point, the one both bounds share.<br />
			<br />
			Returns : Returns true if this box includes zero points within its bounds.<br />
			[method:any isIntersectionBox](  [param:any b] ) - deprecated - Use {@link Box3#intersectsBox .intersectsBox()} instead.<br />
			[method:any isIntersectionSphere](  [param:any s] ) - deprecated - Use {@link Box3#intersectsSphere .intersectsSphere()} instead.<br />
			[method:Box3 makeEmpty](  ) - Makes this box empty.<br />
			[method:Box3 set](  [param:Vector3 min],  [param:Vector3 max] ) - Sets the lower and upper (x, y, z) boundaries of this box.<br />
			Please note that this method only copies the values from the given objects.<br />
			[method:Box3 setFromArray](  [param:ArrayLike array] ) - Sets the upper and lower bounds of this box to include all of the data in *array*.<br />
			[method:Box3 setFromBufferAttribute](  [param:BufferAttribute bufferAttribute] ) - Sets the upper and lower bounds of this box to include all of the data in [page:BufferAttribute attribute].<br />
			[method:Box3 setFromCenterAndSize](  [param:Vector3 center],  [param:Vector3 size] ) - Centers this box on [page:Vector3 center] and sets this box's width, height and depth to the values specified  in [page:Vector3 size]<br />
			[method:Box3 setFromObject](  [param:Object3D object] ) - Computes the world-axis-aligned bounding box of an [page:Object3D Object3D] (including its children), accounting for the object's, and children's, world transforms.<br />
			The function may result in a larger box than strictly necessary.<br />
			[method:Box3 setFromPoints](  [param:Vector3[] points] ) - Sets the upper and lower bounds of this box to include all of the points in [page:Array points].<br />
			[method:Box3 translate](  [param:Vector3 offset] ) - Adds [page:Vector3 offset] to both the upper and lower bounds of this box, effectively moving this box [page:Vector3 offset] units in 3D space.<br />
			[method:Box3 union](  [param:Box3 box] ) - Computes the union of this box and [page:Box3 box], setting the upper bound of this box to the greater of the two boxes' upper bounds and the lower bound of this box to the lesser of the two boxes' lower bounds.
		</p>

		<p class="desc">
			Represents an axis-aligned bounding box (AABB) in 3D space.<br />
			<code data-type="javascript"><br />
			const box = new THREE.Box3();<br />
			const mesh = new THREE.Mesh( new THREE.SphereGeometry(), new THREE.MeshBasicMaterial() );<br />
			//  ensure the bounding box is computed for its geometry // this should be done only once (assuming static geometries)<br />
			mesh.geometry.computeBoundingBox();<br />
			//  ...<br />
			//  in the animation loop, compute the current bounding box with the world matrix<br />
			box.copy( mesh.geometry.boundingBox ).applyMatrix4( mesh.matrixWorld );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="Box3Helper">Box3Helper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Box3Helper Box3Helper](  [param:Box3 box],  [param:Color color]? ) <br />
			[constructor:Box3Helper Box3Helper](  [param:Box3 box],  [param:Color color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:Box3Helper Box3Helper](  [param:Box3 box],  [param:Color color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:Box3Helper Box3Helper](  [param:Box3 box],  [param:Color color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:Box3Helper Box3Helper](  [param:Box3 box],  [param:Color color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Box3 box] -  The box.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Box3Helper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Box3Helper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Box3Helper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Box3Helper clear](  ) - Removes all child objects.<br />
			[method:Box3Helper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Box3Helper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:Box3Helper copy](  [param:Box3Helper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:Box3Helper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Box3Helper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Box3Helper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Box3Helper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Box3Helper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Box3Helper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Box3Helper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Box3Helper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Box3Helper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Box3Helper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Box3Helper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="BoxGeometry">BoxGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BoxGeometry BoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) <br />
			[constructor:BoxGeometry BoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:BoxGeometry BoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:BoxGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BoxGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="BoxHelper">BoxHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BoxHelper BoxHelper](  [param:Object3D object],  [param:ColorRepresentation color]? ) <br />
			[constructor:BoxHelper BoxHelper](  [param:Object3D object],  [param:ColorRepresentation color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:BoxHelper BoxHelper](  [param:Object3D object],  [param:ColorRepresentation color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:BoxHelper BoxHelper](  [param:Object3D object],  [param:ColorRepresentation color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:BoxHelper BoxHelper](  [param:Object3D object],  [param:ColorRepresentation color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BoxHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:BoxHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:BoxHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:BoxHelper clear](  ) - Removes all child objects.<br />
			[method:BoxHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:BoxHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:BoxHelper copy](  [param:BoxHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:BoxHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BoxHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:BoxHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:BoxHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:BoxHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:BoxHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:BoxHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:BoxHelper setFromObject](  [param:Object3D object] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:BoxHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:BoxHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:BoxHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:BoxHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  [param:Object3D object]? ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="BoxLineGeometry">BoxLineGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BoxLineGeometry BoxLineGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:BoxLineGeometry BoxLineGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:BoxLineGeometry BoxLineGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:BoxLineGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BrightnessContrastShader">BrightnessContrastShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BufferAttribute">BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BufferAttribute BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			This class stores data for an attribute (such as vertex positions, face indices, normals, colors, UVs, and any custom attributes ) associated with a [page:BufferGeometry BufferGeometry], which allows for more efficient passing of data to the GPU. See that page for details and a usage example., cata is stored as vectors of any length (defined by [page:BufferAttribute.itemSize itemSize]), and in general in the methods outlined below if passing in an index, this is automatically multiplied by the vector length.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="BufferGeometry">BufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BufferGeometry BufferGeometry](  ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:BufferGeometry BufferGeometry](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number MaxIndex] -  The max index.<br />
			[property:any attributes] - This hashmap has as id the name of the attribute to be set and as value the [page:BufferAttribute buffer] to set it to.<br />
			Rather than accessing this property directly, use *.setAttribute* and *.getAttribute* to access attributes of this geometry.<br />
			[property:Box3 boundingBox] - Bounding box for the bufferGeometry, which can be calculated with *.computeBoundingBox*(). Default is *null*.<br />
			[property:Sphere boundingSphere] - Bounding sphere for the bufferGeometry, which can be calculated with *.computeBoundingSphere*(). Default is *null*.<br />
			[property:any drawRange] - Determines the part of the geometry to render. This should not be set directly, instead use *.setDrawRange*. Default is { start: 0, count: Infinity }<br />
			For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[property:any drawcalls] - deprecated - Use {@link BufferGeometry#groups .groups} instead.<br />
			[property:any groups] - Split the geometry into groups, each of which will be rendered in a separate WebGL draw call.<br />
			This allows an array of materials to be used with the bufferGeometry.<br />
			Each group is an object of the form: { start: Integer, count: Integer, materialIndex: Integer }<br />
			where start specifies the first element in this draw call  the first vertex for non-indexed geometry, otherwise the first triangle index. Count specifies how many vertices (or indices) are included, and materialIndex specifies the material array index to use.<br />
			Use *.addGroup* to add groups, rather than modifying this array directly.<br />
			[property:number id] - Unique number for this bufferGeometry instance.<br />
			[property:BufferAttribute index] - Allows for vertices to be re-used across multiple triangles; this is called using "indexed triangles".<br />
			Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face.<br />
			If this attribute is not set, the [page:WebGLRenderer renderer] assumes that each three contiguous positions represent a single triangle.<br />
			Default is *null*.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] - Hashmap of [page:BufferAttribute BufferAttribute]s holding details of the geometry's morph targets.<br />
			[property:boolean morphTargetsRelative] - Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals.<br />
			Default is *false*.<br />
			[property:string name] - Optional name for this bufferGeometry instance. Default is an empty string.<br />
			[property:any offsets] - deprecated - Use {@link BufferGeometry#groups .groups} instead.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the BufferGeometry. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - [link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID] of this object instance.<br />
			This gets automatically assigned and shouldn't be edited.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:BufferGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			A representation of mesh, line, or point geometry. Includes vertex positions, face indices, normals, colors, UVs, and custom attributes within buffers, reducing the cost of passing all this data to the GPU.<br />
			To read and edit data in BufferGeometry attributes, see [BufferAttribute](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/BufferAttribute) documentation.<br />
			[example:webgl_buffergeometry Mesh with non-indexed faces]<br />
			[example:webgl_buffergeometry_indexed Mesh with indexed faces]<br />
			[example:webgl_buffergeometry_lines Lines]<br />
			[example:webgl_buffergeometry_lines_indexed Indexed Lines]<br />
			[example:webgl_buffergeometry_custom_attributes_particles Particles]<br />
			[example:webgl_buffergeometry_rawshader Raw Shaders]<br />
			<br />
			<code data-type="javascript"><br />
			const geometry = new THREE.BufferGeometry();<br />
			//  create a simple square shape. We duplicate the top left and bottom right // vertices because each vertex needs to appear once per triangle.<br />
			const vertices = new Float32Array( [<br />
			 -1.0, -1.0,  1.0,<br />
			 1.0, -1.0,  1.0,<br />
			 1.0,  1.0,  1.0,<br />
			 1.0,  1.0,  1.0,<br />
			 -1.0,  1.0,  1.0,<br />
			 -1.0, -1.0,  1.0<br />
			] );<br />
			//  itemSize = 3 because there are 3 values (components) per vertex<br />
			geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );<br />
			const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );<br />
			const mesh = new THREE.Mesh( geometry, material );<br />
			<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="BufferGeometryLoader">BufferGeometryLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BufferGeometryLoader BufferGeometryLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:BufferGeometryLoader BufferGeometryLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:BufferGeometry|InstancedBufferGeometry parse](  [param:any json] ) <br />
			[method:BufferGeometryLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:BufferGeometryLoader setPath](  [param:string path] ) <br />
			[method:BufferGeometryLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:BufferGeometryLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:BufferGeometryLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="BufferGeometryUtils">BufferGeometryUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void computeTangents](  [param:BufferGeometry geometry] ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:BufferAttribute mergeBufferAttributes](  [param:BufferAttribute[] attributes] ) - Returns : buffer attributes<br />
			[method:BufferGeometry mergeBufferGeometries](  [param:BufferGeometry[] geometries] ) - Returns : buffer geometries
		</p>

		<p class="desc">
			see {@link https://github.com/mrdoob/three.js/blob/master/examples/jsm/utils/BufferGeometryUtils.js|examples/jsm/utils/BufferGeometryUtils.js}
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="BumpMapNode">BumpMapNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BumpMapNode BumpMapNode](  [param:TextureNode value],  [param:FloatNode scale]? ) <br />
			[constructor:BumpMapNode BumpMapNode](  [param:TextureNode value],  [param:FloatNode scale]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:BumpMapNode BumpMapNode](  [param:TextureNode value],  [param:FloatNode scale]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:FloatNode scale] -  The scale.<br />
			[property:boolean shared] -  The shared.<br />
			[property:boolean toNormalMap] -  The to normal map.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:TextureNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:BumpMapNode copy](  [param:BumpMapNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:BumpMapNode setLabel](  [param:string name] ) <br />
			[method:BumpMapNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr;

		<h3 id="BypassNode">BypassNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:BypassNode BypassNode](  [param:NodeNode code],  [param:NodeNode value]? ) <br />
			[constructor:BypassNode BypassNode](  [param:NodeNode code],  [param:NodeNode value]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode code] -  The code.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:NodeNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:BypassNode copy](  [param:BypassNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:BypassNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="CCDIKHelper">CCDIKHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CCDIKHelper CCDIKHelper](  [param:SkinnedMesh mesh],  [param:IKS[] iks] ) - The constructor takes no arguments.<br />
			[constructor:CCDIKHelper CCDIKHelper](  [param:SkinnedMesh mesh],  [param:IKS[] iks] ) - The constructor takes no arguments.<br />
			[constructor:CCDIKHelper CCDIKHelper](  [param:SkinnedMesh mesh],  [param:IKS[] iks] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CCDIKHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:CCDIKHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:CCDIKHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:CCDIKHelper clear](  ) - Removes all child objects.<br />
			[method:CCDIKHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:CCDIKHelper copy](  [param:CCDIKHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:CCDIKHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:CCDIKHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:CCDIKHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CCDIKHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:CCDIKHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:CCDIKHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:CCDIKHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:CCDIKHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CCDIKHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:CCDIKHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:CCDIKHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CCDIKSolver">CCDIKSolver <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CCDIKSolver CCDIKSolver](  [param:SkinnedMesh mesh],  [param:IKS[] iks] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:CCDIKHelper createHelper](  ) <br />
			[method:CCDIKSolver update](  ) <br />
			[method:CCDIKSolver updateOne](  [param:IKS iks] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CMSParameters">CMSParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Camera camera]? -  The camera.<br />
			[property:number cascades]? -  The cascades.<br />
			[property:Vector3 lightDirection]? -  The light direction.<br />
			[property:number lightFar]? -  The light far.<br />
			[property:number lightIntensity]? -  The light intensity.<br />
			[property:number lightMargin]? -  The light margin.<br />
			[property:number lightNear]? -  The light near.<br />
			[property:number maxFar]? -  The max far.<br />
			[property:CMSMode mode]? -  The mode.<br />
			[property:Object3D parent]? -  The parent.<br />
			[property:number shadowBias]? -  The shadow bias.<br />
			[property:number shadowMapSize]? -  The shadow map size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void customSplitsCallback](  [param:number cascades],  [param:number cameraNear],  [param:number cameraFar],  [param:number[] breaks] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CMYK">CMYK <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number c] -  The c.<br />
			[property:number k] -  The k.<br />
			[property:number m] -  The m.<br />
			[property:number y] -  The y.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CSMFrustum">CSMFrustum <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CSMFrustum CSMFrustum](  [param:CSMFrustumParameters data]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:CSMFrustumVerticies vertices] -  The vertices.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CSMFrustumVerticies setFromProjectionMatrix](  [param:Matrix4 projectionMatrix],  [param:number maxFar] ) <br />
			[method:void split](  [param:number[] breaks],  [param:CSMFrustum[] target] ) <br />
			[method:void toSpace](  [param:Matrix4 cameraMatrix],  [param:CSMFrustum target] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CSMFrustumParameters">CSMFrustumParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number maxFar]? -  The max far.<br />
			[property:Matrix4 projectionMatrix]? -  The projection matrix.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CSMFrustumVerticies">CSMFrustumVerticies <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Vector3[] far] -  The far.<br />
			[property:Vector3[] near] -  The near.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Group] &rarr;

		<h3 id="CSMHelper">CSMHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CSMHelper CSMHelper](  [param:TCSM csm] ) - The constructor takes no arguments.<br />
			[constructor:CSMHelper CSMHelper](  [param:TCSM csm] ) - The constructor takes no arguments.<br />
			[constructor:CSMHelper CSMHelper](  [param:TCSM csm] ) - The constructor takes no arguments.<br />
			[constructor:CSMHelper CSMHelper](  [param:TCSM csm] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Box3Helper[] cascadeLines] -  The cascade lines.<br />
			[property:Mesh[] cascadePlanes] -  The cascade planes.<br />
			[property:TCSM csm] -  The csm.<br />
			[property:boolean displayFrustum] -  The display frustum.<br />
			[property:boolean displayPlanes] -  The display planes.<br />
			[property:boolean displayShadowBounds] -  The display shadow bounds.<br />
			[property:LineSegments frustumLines] -  The frustum lines.<br />
			[property:Box3Helper[] shadowLines] -  The shadow lines.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CSMHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:CSMHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:CSMHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:CSMHelper clear](  ) - Removes all child objects.<br />
			[method:CSMHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:CSMHelper copy](  [param:CSMHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:CSMHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:CSMHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:CSMHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CSMHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:CSMHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:CSMHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:CSMHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:CSMHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CSMHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:CSMHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:CSMHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateVisibility](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CSMShader">CSMShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string lights_fragment_begin] -  The lights_fragment_begin.<br />
			[property:string lights_pars_begin] -  The lights_pars_begin.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="CSS2DObject">CSS2DObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CSS2DObject CSS2DObject](  [param:HTMLElement element] ) - The constructor takes no arguments.<br />
			[constructor:CSS2DObject CSS2DObject](  [param:HTMLElement element] ) - The constructor takes no arguments.<br />
			[constructor:CSS2DObject CSS2DObject](  [param:HTMLElement element] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement element] -  The element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CSS2DObject add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:CSS2DObject applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:CSS2DObject attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:CSS2DObject clear](  ) - Removes all child objects.<br />
			[method:CSS2DObject clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:CSS2DObject copy](  [param:CSS2DObject source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:unknown renderer],  [param:Scene scene],  [param:Camera camera] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:unknown renderer],  [param:Scene scene],  [param:Camera camera] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:CSS2DObject remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:CSS2DObject removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:CSS2DObject rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CSS2DObject rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:CSS2DObject rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:CSS2DObject rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:CSS2DObject rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:CSS2DObject translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CSS2DObject translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:CSS2DObject translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:CSS2DObject translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CSS2DRenderer">CSS2DRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CSS2DRenderer CSS2DRenderer](  [param:CSS2DParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void getSize](  ) <br />
			[method:void render](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="CSS3DObject">CSS3DObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CSS3DObject CSS3DObject](  [param:HTMLElement element] ) - The constructor takes no arguments.<br />
			[constructor:CSS3DObject CSS3DObject](  [param:HTMLElement element] ) - The constructor takes no arguments.<br />
			[constructor:CSS3DObject CSS3DObject](  [param:HTMLElement element] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement element] -  The element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CSS3DObject add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:CSS3DObject applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:CSS3DObject attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:CSS3DObject clear](  ) - Removes all child objects.<br />
			[method:CSS3DObject clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:CSS3DObject copy](  [param:CSS3DObject source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:unknown renderer],  [param:Scene scene],  [param:Camera camera] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:unknown renderer],  [param:Scene scene],  [param:Camera camera] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:CSS3DObject remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:CSS3DObject removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:CSS3DObject rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CSS3DObject rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:CSS3DObject rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:CSS3DObject rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:CSS3DObject rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:CSS3DObject translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CSS3DObject translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:CSS3DObject translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:CSS3DObject translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CSS3DRenderer">CSS3DRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CSS3DRenderer CSS3DRenderer](  [param:CSS3DParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void getSize](  ) <br />
			[method:void render](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:CSS3DObject] &rarr;

		<h3 id="CSS3DSprite">CSS3DSprite <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CSS3DSprite CSS3DSprite](  [param:HTMLElement element] ) - The constructor takes no arguments.<br />
			[constructor:CSS3DSprite CSS3DSprite](  [param:HTMLElement element],  [param:HTMLElement element] ) - The constructor takes no arguments.<br />
			[constructor:CSS3DSprite CSS3DSprite](  [param:HTMLElement element],  [param:HTMLElement element] ) - The constructor takes no arguments.<br />
			[constructor:CSS3DSprite CSS3DSprite](  [param:HTMLElement element],  [param:HTMLElement element] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement element] -  The element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CSS3DSprite add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:CSS3DSprite applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:CSS3DSprite attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:CSS3DSprite clear](  ) - Removes all child objects.<br />
			[method:CSS3DSprite clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:CSS3DSprite copy](  [param:CSS3DSprite source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:unknown renderer],  [param:Scene scene],  [param:Camera camera] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:unknown renderer],  [param:Scene scene],  [param:Camera camera] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:CSS3DSprite remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:CSS3DSprite removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:CSS3DSprite rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CSS3DSprite rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:CSS3DSprite rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:CSS3DSprite rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:CSS3DSprite rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:CSS3DSprite translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CSS3DSprite translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:CSS3DSprite translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:CSS3DSprite translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Cache">Cache <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean enabled] -  The enabled.<br />
			[property:any files] -  The files.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void add](  [param:string key],  [param:any file] ) <br />
			[method:void clear](  ) <br />
			[method:any get](  [param:string key] ) <br />
			[method:void remove](  [param:string key] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Camera">Camera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Camera Camera](  ) - This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.<br />
			[constructor:Camera Camera](  ) - The constructor takes no arguments.<br />
			[constructor:Camera Camera](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isCamera] -  The is camera.<br />
			[property:Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Camera add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Camera applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Camera attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Camera clear](  ) - Removes all child objects.<br />
			[method:Camera clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Camera copy](  [param:Camera source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) <br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:Camera remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Camera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Camera rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Camera rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Camera rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Camera rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Camera rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Camera translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Camera translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Camera translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Camera translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			Abstract base class for cameras. This class should always be inherited when you build a new camera.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="CameraHelper">CameraHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CameraHelper CameraHelper](  [param:Camera camera] ) <br />
			[constructor:CameraHelper CameraHelper](  [param:Camera camera],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:CameraHelper CameraHelper](  [param:Camera camera],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:CameraHelper CameraHelper](  [param:Camera camera],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:CameraHelper CameraHelper](  [param:Camera camera],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Camera camera] -  The camera.<br />
			[property:any pointMap] -  The point map.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CameraHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:CameraHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:CameraHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:CameraHelper clear](  ) - Removes all child objects.<br />
			[method:CameraHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:CameraHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:CameraHelper copy](  [param:CameraHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:CameraHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:CameraHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:CameraHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CameraHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:CameraHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:CameraHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:CameraHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:CameraHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CameraHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:CameraHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:CameraHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="CameraNode">CameraNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CameraNode CameraNode](  [param:string scope]?,  [param:Camera camera]? ) <br />
			[constructor:CameraNode CameraNode](  [param:string scope]?,  [param:Camera camera]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:CameraNode CameraNode](  [param:string scope]?,  [param:Camera camera]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string DEPTH] -  The d e p t h.<br />
			[property:any Nodes] -  The nodes.<br />
			[property:string POSITION] -  The p o s i t i o n.<br />
			[property:string TO_VERTEX] -  The t o_ v e r t e x.<br />
			[property:Camera camera] -  The camera.<br />
			[property:FloatNode far] -  The far.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:FloatNode near] -  The near.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean updateFrame] -  The update frame.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:CameraNode copy](  [param:CameraNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void onUpdateFrame](  [param:NodeFrame frame] ) <br />
			[method:void setCamera](  [param:Camera camera] ) <br />
			[method:CameraNode setLabel](  [param:string name] ) <br />
			[method:CameraNode setName](  [param:string name] ) <br />
			[method:void setScope](  [param:string scope] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CameraUtils">CameraUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void frameCorners](  [param:PerspectiveCamera camera],  [param:Vector3 bottomLeftCorner],  [param:Vector3 bottomRightCorner],  [param:Vector3 topLeftCorner],  [param:boolean estimateViewFrustum]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Texture] &rarr;

		<h3 id="CanvasTexture">CanvasTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CanvasTexture CanvasTexture](  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement|ImageBitmap canvas],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]? ) <br />
			[constructor:CanvasTexture CanvasTexture](  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement|ImageBitmap canvas],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:CanvasTexture CanvasTexture](  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement|ImageBitmap canvas],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any DEFAULT_IMAGE] -  The d e f a u l t_ i m a g e.<br />
			[property:any DEFAULT_MAPPING] -  The d e f a u l t_ m a p p i n g.<br />
			[property:number anisotropy] -  The anisotropy.<br />
			[property:Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isCanvasTexture] -  The is canvas texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:CanvasTexture clone](  ) <br />
			[method:CanvasTexture copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Capsule">Capsule <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Capsule Capsule](  [param:Vector3 start]?,  [param:Vector3 end]?,  [param:number radius]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Vector3 end] -  The end.<br />
			[property:number radius] -  The radius.<br />
			[property:Vector3 start] -  The start.
		</p>
		<h4>Methods</h4>
		<p>
			[method:boolean checkAABBAxis](  [param:number p1x],  [param:number p1y],  [param:number p2x],  [param:number p2y],  [param:number minx],  [param:number maxx],  [param:number miny],  [param:number maxy],  [param:number radius] ) <br />
			[method:Capsule clone](  ) <br />
			[method:Capsule copy](  [param:Capsule capsule] ) <br />
			[method:Vector3 getCenter](  [param:number target] ) <br />
			[method:boolean intersectsBox](  [param:Box3 box] ) <br />
			[method:Vector3[] lineLineMinimumPoints](  [param:Line3 line1],  [param:Line3 line2] ) <br />
			[method:Capsule set](  [param:Vector3 start],  [param:Vector3 end],  [param:number radius] ) <br />
			[method:Capsule translate](  [param:Vector3 v] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="CatmullRomCurve3">CatmullRomCurve3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CatmullRomCurve3 CatmullRomCurve3](  [param:Vector3[] points]?,  [param:boolean closed]?,  [param:string curveType]?,  [param:number tension]? ) <br />
			[constructor:CatmullRomCurve3 CatmullRomCurve3](  [param:Vector3[] points]?,  [param:boolean closed]?,  [param:string curveType]?,  [param:number tension]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:Vector3[] points] -  The points.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CatmullRomCurve3 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:CatmullRomCurve3 copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:CatmullRomCurve3 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector3 getPoint](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getPointAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector3 getTangent](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getTangentAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="CheckerNode">CheckerNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CheckerNode CheckerNode](  [param:UVNode|UVTransformNode uv]? ) <br />
			[constructor:CheckerNode CheckerNode](  [param:UVNode|UVTransformNode uv]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:CheckerNode CheckerNode](  [param:UVNode|UVTransformNode uv]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:UVNode|UVTransformNode uv] -  The uv.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:CheckerNode copy](  [param:CheckerNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:CheckerNode setLabel](  [param:string name] ) <br />
			[method:CheckerNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Chunk">Chunk <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Uint8Array data] -  The data.<br />
			[property:number[] palette] -  The palette.<br />
			[property:any size] -  The size.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Camera] &rarr; [page:PerspectiveCamera] &rarr;

		<h3 id="CinematicCamera">CinematicCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CinematicCamera CinematicCamera](  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far] ) <br />
			[constructor:CinematicCamera CinematicCamera](  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far],  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) <br />
			[constructor:CinematicCamera CinematicCamera](  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far],  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) - This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.<br />
			[constructor:CinematicCamera CinematicCamera](  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far],  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) - The constructor takes no arguments.<br />
			[constructor:CinematicCamera CinematicCamera](  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far],  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number aperture] -  The aperture.<br />
			[property:number coc] -  The coc.<br />
			[property:number fNumber] -  The f number.<br />
			[property:number filmGauge] -  The film gauge.<br />
			[property:number hyperFocal] -  The hyper focal.<br />
			[property:ShaderMaterial materialDepth] -  The material depth.<br />
			[property:any postprocessing] -  The postprocessing.<br />
			[property:any shaderSettings] -  The shader settings.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CinematicCamera add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:CinematicCamera applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:CinematicCamera attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:CinematicCamera clear](  ) - Removes all child objects.<br />
			[method:void clearViewOffset](  ) <br />
			[method:CinematicCamera clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:CinematicCamera copy](  [param:CinematicCamera source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void focusAt](  [param:number focusDistance] ) <br />
			[method:number getEffectiveFOV](  ) <br />
			[method:number getFilmHeight](  ) <br />
			[method:number getFilmWidth](  ) <br />
			[method:number getFocalLength](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) <br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void initPostProcessing](  ) <br />
			[method:number linearize](  [param:number depth] ) <br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:CinematicCamera remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:CinematicCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:void renderCinematic](  [param:Scene scene],  [param:WebGLRenderer renderer] ) <br />
			[method:CinematicCamera rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CinematicCamera rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:CinematicCamera rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:CinematicCamera rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:CinematicCamera rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:number saturate](  [param:number x] ) <br />
			[method:void setFocalLength](  [param:number focalLength] ) <br />
			[method:void setLens](  [param:number focalLength],  [param:number frameHeight]?,  [param:number fNumber]?,  [param:number coc]? ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:void setViewOffset](  [param:number fullWidth],  [param:number fullHeight],  [param:number x],  [param:number y],  [param:number width],  [param:number height] ) - Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.<br />
			For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:<br />
			+---+---+---+<br />
			| A | B | C |<br />
			+---+---+---+<br />
			| D | E | F |<br />
			+---+---+---+<br />
			<br />
			then for each monitor you would call it like this:<br />
			<br />
			const w = 1920;<br />
			const h = 1080;<br />
			const fullWidth = w * 3;<br />
			const fullHeight = h * 2;<br />
			<br />
			// A<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h ) : this;<br />
			// B<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h ) : this;<br />
			// C<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h ) : this;<br />
			// D<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h ) : this;<br />
			// E<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h ) : this;<br />
			// F<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ) : this; Note there is no reason monitors have to be the same size or in a grid.<br />
			[method:number smoothstep](  [param:number near],  [param:number far],  [param:number depth] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:CinematicCamera translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CinematicCamera translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:CinematicCamera translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:CinematicCamera translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateProjectionMatrix](  ) - Updates the camera projection matrix. Must be called after change of parameters.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="CircleBufferGeometry">CircleBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CircleGeometry CircleGeometry](  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:CircleGeometry CircleGeometry](  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:CircleGeometry CircleGeometry](  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:CircleGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:CircleGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="CircleGeometry">CircleGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CircleGeometry CircleGeometry](  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:CircleGeometry CircleGeometry](  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:CircleGeometry CircleGeometry](  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:CircleGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:CircleGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="ClearMaskPass">ClearMaskPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ClearMaskPass ClearMaskPass](  ) <br />
			[constructor:ClearMaskPass ClearMaskPass](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="ClearPass">ClearPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ClearPass ClearPass](  [param:ColorRepresentation clearColor]?,  [param:number clearAlpha]? ) <br />
			[constructor:ClearPass ClearPass](  [param:ColorRepresentation clearColor]?,  [param:number clearAlpha]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:number clearAlpha] -  The clear alpha.<br />
			[property:ColorRepresentation clearColor] -  The clear color.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Clock">Clock <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Clock Clock](  [param:boolean autoStart]? ) - autoStart - whether to automatically start the clock. Default is true.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoStart] - If set, starts the clock automatically when the first update is called. Default is true.<br />
			[property:number elapsedTime] - Keeps track of the total time that the clock has been running.<br />
			[property:number oldTime] - Holds the time at which the clock's [page:Clock.start start], [page:Clock.getElapsedTime getElapsedTime] or [page:Clock.getDelta getDelta] methods were last called.<br />
			[property:boolean running] - Whether the clock is running or not.<br />
			[property:number startTime] - Holds the time at which the clock's [page:Clock.start start] method was last called.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number getDelta](  ) - Get the seconds passed since the time [page:Clock.oldTime oldTime] was set and sets [page:Clock.oldTime oldTime] to the current time.<br />
			If [page:Clock.autoStart autoStart] is *true* and the clock is not running, also starts the clock.<br />
			[method:number getElapsedTime](  ) - Get the seconds passed since the clock started and sets [page:Clock.oldTime oldTime] to the current time.<br />
			If [page:Clock.autoStart autoStart] is *true* and the clock is not running, also starts the clock.<br />
			[method:void start](  ) - Starts clock. Also sets the [page:Clock.startTime startTime] and [page:Clock.oldTime oldTime]<br />
			to the current time, sets [page:Clock.elapsedTime elapsedTime] to *0* and [page:Clock.running running] to *true*.<br />
			[method:void stop](  ) - Stops clock and sets [page:Clock.oldTime oldTime] to the current time.
		</p>

		<p class="desc">
			Object for keeping track of time. This uses [link:https://developer.mozilla.org/en-US/docs/Web/API/Performance/now performance.now]<br />
			if it is available, otherwise it reverts to the less accurate [link:https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now Date.now].
		</p>

		<hr class="interface-line"/>
		<h3 id="Collada">Collada <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:object kinematics] -  The kinematics.<br />
			[property:object library] -  The library.<br />
			[property:Scene scene] -  The scene.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ColladaExporter">ColladaExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ColladaExporter ColladaExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:ColladaExporterResult parse](  [param:Object3D object],  [param:any onDone],  [param:ColladaExporterOptions options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ColladaExporterOptions">ColladaExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string author]? -  The author.<br />
			[property:string textureDirectory]? -  The texture directory.<br />
			[property:string version]? -  The version.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ColladaExporterResult">ColladaExporterResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string data] -  The data.<br />
			[property:object[] textures] -  The textures.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="ColladaLoader">ColladaLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ColladaLoader ColladaLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:ColladaLoader ColladaLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Collada parse](  [param:string text],  [param:string path] ) <br />
			[method:ColladaLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ColladaLoader setPath](  [param:string path] ) <br />
			[method:ColladaLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ColladaLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ColladaLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Color">Color <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Color Color](  [param:ColorRepresentation r]?,  [param:number g]?,  [param:number b]? ) - Note that standard method of specifying color in three.js is with a [hexadecimal triplet](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet), and that method is used throughout the rest of the documentation.<br />
			When all arguments are defined then [r](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Color_Hex_or_String) is the red component, [g](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Float) is the green component and [b](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Float) is the blue component of the color.<br />
			When only [r](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Color_Hex_or_String) is defined:<br />
			It can be a [link:https://en.wikipedia.org/wiki/Web_colors#Hex_triplet hexadecimal triplet] representing the color (recommended).<br />
			It can be an another Color instance.<br />
			It can be a CSS-style string. For example:<br />
			<br />
			'rgb(250, 0,0)', 'rgb(100%,0%,0%)', 'hsl(0, 100%, 50%)', '#ff0000', '#f00', 'red'
		</p>
		<h4>Properties</h4>
		<p>
			[property:Record NAMES] - List of X11 color names.<br />
			[property:number b] - Blue channel value between 0 and 1. Default is 1.<br />
			[property:number g] - Green channel value between 0 and 1. Default is 1.<br />
			[property:any isColor] -  The is color.<br />
			[property:number r] - Red channel value between 0 and 1. Default is 1.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Color add](  [param:Color color] ) - Adds the RGB values of [page:Color color] to the RGB values of this color.<br />
			[method:Color addColors](  [param:Color color1],  [param:Color color2] ) - Sets this color's RGB values to the sum of the RGB values of [page:Color color1] and [page:Color color2].<br />
			[method:Color addScalar](  [param:number s] ) - Adds [page:Number s] to the RGB values of this color.<br />
			[method:Color clone](  ) - Returns : Returns a new Color with the same *.r*, *.g* and *.b* values as this one.<br />
			[method:Color convertGammaToLinear](  [param:number gammaFactor]? ) - Converts this color from gamma space to linear space by taking *.r*, *.g* and *.b* to the power of [page:Float gammaFactor].<br />
			[method:Color convertLinearToGamma](  [param:number gammaFactor]? ) - Converts this color from linear space to gamma space by taking *.r*, *.g* and *.b* to the power of 1 / [page:Float gammaFactor].<br />
			[method:Color convertLinearToSRGB](  ) - Converts this color from linear to sRGB space.<br />
			[method:Color convertSRGBToLinear](  ) - Copies the given color into this color, and then converts this color from sRGB space to linear space.<br />
			[method:Color copy](  [param:Color color] ) - Copies the *.r*, *.g* and *.b* parameters from [page:Color color] in to this color.<br />
			[method:Color copyGammaToLinear](  [param:Color color],  [param:number gammaFactor]? ) - Copies the given color into this color, and then converts this color from gamma space to linear space by taking *.r*, *.g* and *.b* to the power of [page:Float gammaFactor].<br />
			[method:Color copyLinearToGamma](  [param:Color color],  [param:number gammaFactor]? ) - Copies the given color into this color, and then converts this color from linear space to gamma space by taking *.r*, *.g* and *.b* to the power of 1 / [page:Float gammaFactor].<br />
			[method:Color copyLinearToSRGB](  [param:Color color] ) - Copies the given color into this color, and then converts this color from linear space to sRGB space.<br />
			[method:Color copySRGBToLinear](  [param:Color color] ) - Converts this color from sRGB space to linear space.<br />
			[method:boolean equals](  [param:Color color] ) - Compares the RGB values of [page:Color color] with those of this object. Returns true if they are the same, false otherwise.<br />
			[method:Color fromArray](  [param:ArrayLike|number[] array],  [param:number offset]? ) - Sets this color's components based on an array formatted like [page:Float  [r], [page:Float g], [page:Float b] ].<br />
			[method:Color fromBufferAttribute](  [param:BufferAttribute attribute],  [param:number index] ) - Sets this color's components from the [page:BufferAttribute attribute].<br />
			[method:HSL getHSL](  [param:HSL target] ) - Convert this Color's *.r*, *.g* and *.b* values to [link:https://en.wikipedia.org/wiki/HSL_and_HSV HSL] format and returns an object of the form: { h: 0, s: 0, l: 0 }<br />
			[method:number getHex](  ) - Returns : Returns the hexadecimal value of this color.<br />
			[method:string getHexString](  ) - Returns : Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').<br />
			[method:string getStyle](  ) - Returns : Returns the value of this color as a CSS style string. Example: 'rgb(255,0,0)'.<br />
			[method:Color lerp](  [param:Color color],  [param:number alpha] ) - Linearly interpolates this color's RGB values toward the RGB values of the passed argument.<br />
			The alpha argument can be thought of as the ratio between the two colors, where 0.0 is this color and 1.0 is the first argument.<br />
			[method:Color lerpColors](  [param:Color color1],  [param:Color color2],  [param:number alpha] ) - Sets this color to be the color linearly interpolated between [page:Color color1] and [page:Color color2] where alpha is the percent distance along the line connecting the two colors - alpha = 0 will be [page:Color color1], and alpha = 1 will be [page:Color color2].<br />
			[method:Color lerpHSL](  [param:Color color],  [param:number alpha] ) - Linearly interpolates this color's HSL values toward the HSL values of the passed argument.<br />
			It differs from the classic *.lerp* by not interpolating straight from one color to the other, but instead going through all the hues in between those two colors.<br />
			The alpha argument can be thought of as the ratio between the two colors, where 0.0 is this color and 1.0 is the first argument.<br />
			[method:Color multiply](  [param:Color color] ) - Multiplies this color's RGB values by the given [page:Color color]'s RGB values.<br />
			[method:Color multiplyScalar](  [param:number s] ) - Multiplies this color's RGB values by [page:Number s].<br />
			[method:Color offsetHSL](  [param:number h],  [param:number s],  [param:number l] ) - Adds the given [page:Float h], [page:Float s], and [page:Float l] to this color's values.<br />
			Internally, this converts the color's *.r*, *.g* and *.b* values to HSL, adds [page:Float h], [page:Float s], and [page:Float l], and then converts the color back to RGB.<br />
			[method:Color set](  [param:ColorRepresentation color] ) - See the Constructor above for full details of what [link:https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Color_Hex_or_String value] can be.<br />
			Delegates to *.copy*, *.setStyle*, or *.setHex* depending on input type.<br />
			[method:Color setColorName](  [param:string style] ) - Sets this color from a color name. Faster than *.setStyle* method if you don't need the other CSS-style formats.<br />
			For convenience, the list of names is exposed in Color.NAMES as a hash:<br />
			Color.NAMES.aliceblue // returns 0xF0F8FF<br />
			[method:Color setHSL](  [param:number h],  [param:number s],  [param:number l] ) - Sets color from HSL values.<br />
			[method:Color setHex](  [param:number hex] ) - Sets this color from a hexadecimal value.<br />
			[method:Color setRGB](  [param:number r],  [param:number g],  [param:number b] ) - Sets this color from RGB values.<br />
			[method:Color setScalar](  [param:number scalar] ) - Sets all three color components to the value [page:Float scalar].<br />
			[method:Color setStyle](  [param:string style] ) - Sets this color from a CSS-style string. For example,  "rgb(250, 0,0)", "rgb(100%, 0%, 0%)", "hsl(0, 100%, 50%)", "#ff0000", "#f00", or "red" ( or any [link:https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart X11 color name] - all 140 color names are supported ).<br />
			Translucent colors such as "rgba(255, 0, 0, 0.5)" and "hsla(0, 100%, 50%, 0.5)" are also accepted, but the alpha-channel coordinate will be discarded.<br />
			Note that for X11 color names, multiple words such as Dark Orange become the string 'darkorange'.<br />
			[method:Color sub](  [param:Color color] ) - Subtracts the RGB components of the given color from the RGB components of this color.<br />
			If this results in a negative component, that component is set to zero.<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns an array [red, green, blue], or copies red, green and blue into the provided array.<br />
			<br />
			Returns : Returns an array of the form [ r, g, b ].
		</p>

		<p class="desc">
			Class representing a color.<br />
			A Color can be initialised in any of the following ways:<br />
			<code data-type="javascript"><br />
			// empty constructor - will default white<br />
			const color1 = new THREE.Color();<br />
			// Hexadecimal color (recommended)<br />
			const color2 = new THREE.Color( 0xff0000 );<br />
			// RGB string<br />
			const color3 = new THREE.Color("rgb(255, 0, 0)");<br />
			const color4 = new THREE.Color("rgb(100%, 0%, 0%)");<br />
			// X11 color name - all 140 color names are supported.<br />
			// Note the lack of CamelCase in the name<br />
			const color5 = new THREE.Color( 'skyblue' );<br />
			// HSL string<br />
			const color6 = new THREE.Color("hsl(0, 100%, 50%)");<br />
			// Separate RGB values between 0 and 1<br />
			const color7 = new THREE.Color( 1, 0, 0 );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="ColorAdjustmentNode">ColorAdjustmentNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ColorAdjustmentNode ColorAdjustmentNode](  [param:NodeNode rgb],  [param:FloatNode adjustment]?,  [param:string method]? ) <br />
			[constructor:ColorAdjustmentNode ColorAdjustmentNode](  [param:NodeNode rgb],  [param:FloatNode adjustment]?,  [param:string method]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ColorAdjustmentNode ColorAdjustmentNode](  [param:NodeNode rgb],  [param:FloatNode adjustment]?,  [param:string method]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string BRIGHTNESS] -  The b r i g h t n e s s.<br />
			[property:string CONTRAST] -  The c o n t r a s t.<br />
			[property:string HUE] -  The h u e.<br />
			[property:any Nodes] -  The nodes.<br />
			[property:string SATURATION] -  The s a t u r a t i o n.<br />
			[property:string VIBRANCE] -  The v i b r a n c e.<br />
			[property:FloatNode adjustment] -  The adjustment.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string method] -  The method.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:NodeNode rgb] -  The rgb.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ColorAdjustmentNode copy](  [param:ColorAdjustmentNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ColorAdjustmentNode setLabel](  [param:string name] ) <br />
			[method:ColorAdjustmentNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ColorConverter">ColorConverter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:CMYK getCMYK](  [param:Color color],  [param:CMYK target] ) <br />
			[method:HSL getHSV](  [param:Color color],  [param:HSL target] ) <br />
			[method:Color setCMYK](  [param:Color color],  [param:number c],  [param:number m],  [param:number y],  [param:number k] ) <br />
			[method:Color setHSV](  [param:Color color],  [param:number h],  [param:number s],  [param:number v] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ColorCorrectionShader">ColorCorrectionShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:KeyframeTrack] &rarr;

		<h3 id="ColorKeyframeTrack">ColorKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ColorKeyframeTrack ColorKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) <br />
			[constructor:ColorKeyframeTrack ColorKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]?,  [param:string name],  [param:ArrayLike times],  [param:ArrayLike values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:LinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:CubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:ColorKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:KeyframeTrack optimize](  ) <br />
			[method:KeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:KeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:KeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:any toJSON](  [param:KeyframeTrack track] ) <br />
			[method:KeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ColorMapKeywords">ColorMapKeywords <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any blackbody] -  The blackbody.<br />
			[property:any cooltowarm] -  The cooltowarm.<br />
			[property:any grayscale] -  The grayscale.<br />
			[property:any rainbow] -  The rainbow.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="ColorNode">ColorNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ColorNode ColorNode](  [param:ColorRepresentation color],  [param:number g]?,  [param:number b]? ) <br />
			[constructor:ColorNode ColorNode](  [param:ColorRepresentation color],  [param:number g]?,  [param:number b]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ColorNode ColorNode](  [param:ColorRepresentation color],  [param:number g]?,  [param:number b]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ColorNode ColorNode](  [param:ColorRepresentation color],  [param:number g]?,  [param:number b]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Color value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ColorNode copy](  [param:ColorNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ColorNode setLabel](  [param:string name] ) <br />
			[method:ColorNode setName](  [param:string name] ) <br />
			[method:ColorNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="ColorSpaceNode">ColorSpaceNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ColorSpaceNode ColorSpaceNode](  [param:NodeNode input],  [param:string method]? ) <br />
			[constructor:ColorSpaceNode ColorSpaceNode](  [param:NodeNode input],  [param:string method]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ColorSpaceNode ColorSpaceNode](  [param:NodeNode input],  [param:string method]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string GAMMA_TO_LINEAR] -  The g a m m a_ t o_ l i n e a r.<br />
			[property:string LINEAR_TO_GAMMA] -  The l i n e a r_ t o_ g a m m a.<br />
			[property:string LINEAR_TO_LINEAR] -  The l i n e a r_ t o_ l i n e a r.<br />
			[property:string LINEAR_TO_LOG_LUV] -  The l i n e a r_ t o_ l o g_ l u v.<br />
			[property:string LINEAR_TO_RGBD] -  The l i n e a r_ t o_ r g b d.<br />
			[property:string LINEAR_TO_RGBE] -  The l i n e a r_ t o_ r g b e.<br />
			[property:string LINEAR_TO_RGBM] -  The l i n e a r_ t o_ r g b m.<br />
			[property:string LINEAR_TO_SRGB] -  The l i n e a r_ t o_ s r g b.<br />
			[property:string LOG_LUV_TO_LINEAR] -  The l o g_ l u v_ t o_ l i n e a r.<br />
			[property:any Nodes] -  The nodes.<br />
			[property:string RGBD_TO_LINEAR] -  The r g b d_ t o_ l i n e a r.<br />
			[property:string RGBE_TO_LINEAR] -  The r g b e_ t o_ l i n e a r.<br />
			[property:string RGBM_TO_LINEAR] -  The r g b m_ t o_ l i n e a r.<br />
			[property:string SRGB_TO_LINEAR] -  The s r g b_ t o_ l i n e a r.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:NodeNode input] -  The input.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string method] -  The method.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ColorSpaceNode copy](  [param:ColorSpaceNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void fromDecoding](  [param:number encoding] ) <br />
			[method:void fromEncoding](  [param:number encoding] ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:any[] getEncodingComponents](  [param:number encoding] ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ColorSpaceNode setLabel](  [param:string name] ) <br />
			[method:ColorSpaceNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ColorifyShader">ColorifyShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="ColorsNode">ColorsNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ColorsNode ColorsNode](  [param:number index]? ) <br />
			[constructor:ColorsNode ColorsNode](  [param:number index]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ColorsNode ColorsNode](  [param:number index]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:number index] -  The index.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ColorsNode copy](  [param:ColorsNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ColorsNode setLabel](  [param:string name] ) <br />
			[method:ColorsNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Texture] &rarr;

		<h3 id="CompressedTexture">CompressedTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CompressedTexture CompressedTexture](  [param:ImageData[] mipmaps],  [param:number width],  [param:number height],  [param:CompressedPixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:CompressedTexture CompressedTexture](  [param:ImageData[] mipmaps],  [param:number width],  [param:number height],  [param:CompressedPixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:CompressedTexture CompressedTexture](  [param:ImageData[] mipmaps],  [param:number width],  [param:number height],  [param:CompressedPixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any DEFAULT_IMAGE] -  The d e f a u l t_ i m a g e.<br />
			[property:any DEFAULT_MAPPING] -  The d e f a u l t_ m a p p i n g.<br />
			[property:number anisotropy] -  The anisotropy.<br />
			[property:Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isCompressedTexture] -  The is compressed texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:ImageData[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:CompressedTexture clone](  ) <br />
			[method:CompressedTexture copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="CompressedTextureLoader">CompressedTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CompressedTextureLoader CompressedTextureLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:CompressedTextureLoader CompressedTextureLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:CompressedTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:CompressedTextureLoader setPath](  [param:string path] ) <br />
			[method:CompressedTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:CompressedTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:CompressedTextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="CondNode">CondNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CondNode CondNode](  [param:NodeNode a],  [param:NodeNode b],  [param:string op],  [param:NodeNode ifNode]?,  [param:NodeNode elseNode]? ) <br />
			[constructor:CondNode CondNode](  [param:NodeNode a],  [param:NodeNode b],  [param:string op],  [param:NodeNode ifNode]?,  [param:NodeNode elseNode]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:CondNode CondNode](  [param:NodeNode a],  [param:NodeNode b],  [param:string op],  [param:NodeNode ifNode]?,  [param:NodeNode elseNode]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string AND] -  The a n d.<br />
			[property:string EQUAL] -  The e q u a l.<br />
			[property:string GREATER] -  The g r e a t e r.<br />
			[property:string GREATER_EQUAL] -  The g r e a t e r_ e q u a l.<br />
			[property:string LESS] -  The l e s s.<br />
			[property:string LESS_EQUAL] -  The l e s s_ e q u a l.<br />
			[property:string NOT_EQUAL] -  The n o t_ e q u a l.<br />
			[property:string OR] -  The o r.<br />
			[property:NodeNode a] -  The a.<br />
			[property:NodeNode b] -  The b.<br />
			[property:NodeNode elseNode] -  The else node.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:NodeNode ifNode] -  The if node.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string op] -  The op.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:CondNode copy](  [param:CondNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getCondType](  [param:NodeBuilder builder] ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:CondNode setLabel](  [param:string name] ) <br />
			[method:CondNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:CylinderGeometry] &rarr;

		<h3 id="ConeBufferGeometry">ConeBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ConeGeometry ConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:ConeGeometry ConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:ConeGeometry ConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ConeGeometry ConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ConeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:ConeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:CylinderGeometry] &rarr;

		<h3 id="ConeGeometry">ConeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ConeGeometry ConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:ConeGeometry ConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:ConeGeometry ConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ConeGeometry ConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ConeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:ConeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="ConstNode">ConstNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ConstNode ConstNode](  [param:string src],  [param:boolean useDefine]? ) <br />
			[constructor:ConstNode ConstNode](  [param:string src],  [param:boolean useDefine]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ConstNode ConstNode](  [param:string src],  [param:boolean useDefine]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string EPSILON] -  The e p s i l o n.<br />
			[property:string LOG2] -  The l o g2.<br />
			[property:string PI] -  The p i.<br />
			[property:string PI2] -  The p i2.<br />
			[property:string RECIPROCAL_PI] -  The r e c i p r o c a l_ p i.<br />
			[property:string RECIPROCAL_PI2] -  The r e c i p r o c a l_ p i2.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string src] -  The src.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean useDefine] -  The use define.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:ConstNode copy](  [param:ConstNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src],  [param:boolean useDefine]? ) <br />
			[method:ConstNode setLabel](  [param:string name] ) <br />
			[method:ConstNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Constraint">Constraint <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Constraint Constraint](  [param:SkinnedMesh mesh],  [param:object world],  [param:RigidBody bodyA],  [param:RigidBody bodyB],  [param:object params],  [param:ResourceManager manager] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:RigidBody bodyA] -  The body a.<br />
			[property:RigidBody bodyB] -  The body b.<br />
			[property:ResourceManager manager] -  The manager.<br />
			[property:SkinnedMesh mesh] -  The mesh.<br />
			[property:object params] -  The params.<br />
			[property:object world] -  The world.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Constructor">Constructor <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:T T](  [param:any[] args] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:T prototype] -  The prototype.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="ConvexGeometry">ConvexGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ConvexGeometry ConvexGeometry](  [param:Vector3[] points] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ConvexGeometry ConvexGeometry](  [param:Vector3[] points] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ConvexGeometry ConvexGeometry](  [param:Vector3[] points] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ConvexGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ConvexHull">ConvexHull <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ConvexHull ConvexHull](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:VertexList assigned] -  The assigned.<br />
			[property:FaceEx[] faces] -  The faces.<br />
			[property:FaceEx[] newFaces] -  The new faces.<br />
			[property:number tolerance] -  The tolerance.<br />
			[property:VertexList unassigned] -  The unassigned.<br />
			[property:VertexNode[] vertices] -  The vertices.
		</p>
		<h4>Methods</h4>
		<p>
			[method:HalfEdge addAdjoiningFace](  [param:VertexNode eyeVertex],  [param:HalfEdge horizonEdge] ) <br />
			[method:ConvexHull addNewFaces](  [param:VertexNode eyeVertex],  [param:HalfEdge[] horizon] ) <br />
			[method:ConvexHull addVertexToFace](  [param:VertexNode vertex],  [param:FaceEx face] ) <br />
			[method:ConvexHull addVertexToHull](  [param:VertexNode eyeVertex] ) <br />
			[method:ConvexHull cleanup](  ) <br />
			[method:ConvexHull compute](  ) <br />
			[method:object computeExtremes](  ) <br />
			[method:ConvexHull computeHorizon](  [param:Vector3 eyePoint],  [param:HalfEdge crossEdge],  [param:FaceEx face],  [param:HalfEdge[] horizon] ) <br />
			[method:ConvexHull computeInitialHull](  ) <br />
			[method:boolean containsPoint](  [param:Vector3 point] ) <br />
			[method:ConvexHull deleteFaceVertices](  [param:FaceEx face],  [param:FaceEx absorbingFace] ) <br />
			[method:Vector3 intersectRay](  [param:Ray ray],  [param:Vector3 target] ) <br />
			[method:boolean intersectsRay](  [param:Ray ray] ) <br />
			[method:ConvexHull makeEmpty](  ) <br />
			[method:VertexNode nextVertexToAdd](  ) <br />
			[method:ConvexHull reindexFaces](  ) <br />
			[method:VertexNode removeAllVerticesFromFace](  [param:FaceEx face] ) <br />
			[method:ConvexHull removeVertexFromFace](  [param:VertexNode vertex],  [param:FaceEx face] ) <br />
			[method:ConvexHull resolveUnassignedPoints](  [param:FaceEx[] newFaces] ) <br />
			[method:ConvexHull setFromObject](  [param:Object3D object] ) <br />
			[method:ConvexHull setFromPoints](  [param:Vector3[] points] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ConvexObjectBreaker">ConvexObjectBreaker <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ConvexObjectBreaker ConvexObjectBreaker](  [param:number minSizeForBreak]?,  [param:number smallDelta]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:number cutByPlane](  [param:Object3D object],  [param:Plane plane],  [param:CutByPlaneOutput output] ) <br />
			[method:void prepareBreakableObject](  [param:Object3D object],  [param:number mass],  [param:Vector3 velocity],  [param:Vector3 angularVelocity],  [param:boolean breakable] ) <br />
			[method:Object3D[] subdivideByImpact](  [param:Object3D object],  [param:Vector3 pointOfImpact],  [param:Vector3 normal],  [param:number maxRadialIterations],  [param:number maxRandomIterations] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ConvolutionShader">ConvolutionShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number[] buildKernel](  [param:number sigma] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CopyShader">CopyShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="CubeCamera">CubeCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CubeCamera CubeCamera](  [param:number near],  [param:number far],  [param:WebGLCubeRenderTarget renderTarget] ) - The constructor takes no arguments.<br />
			[constructor:CubeCamera CubeCamera](  [param:number near],  [param:number far],  [param:WebGLCubeRenderTarget renderTarget] ) - The constructor takes no arguments.<br />
			[constructor:CubeCamera CubeCamera](  [param:number near],  [param:number far],  [param:WebGLCubeRenderTarget renderTarget] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:WebGLCubeRenderTarget renderTarget] -  The render target.<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CubeCamera add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:CubeCamera applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:CubeCamera attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:CubeCamera clear](  ) - Removes all child objects.<br />
			[method:CubeCamera clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:CubeCamera copy](  [param:CubeCamera source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:CubeCamera remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:CubeCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:CubeCamera rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CubeCamera rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:CubeCamera rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:CubeCamera rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:CubeCamera rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:CubeCamera translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:CubeCamera translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:CubeCamera translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:CubeCamera translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  [param:WebGLRenderer renderer],  [param:Scene scene] ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Texture] &rarr;

		<h3 id="CubeTexture">CubeTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CubeTexture CubeTexture](  [param:any[] images]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:CubeTexture CubeTexture](  [param:any[] images]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:CubeTexture CubeTexture](  [param:any[] images]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any DEFAULT_IMAGE] -  The d e f a u l t_ i m a g e.<br />
			[property:any DEFAULT_MAPPING] -  The d e f a u l t_ m a p p i n g.<br />
			[property:number anisotropy] -  The anisotropy.<br />
			[property:Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:any images] -  The images.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isCubeTexture] -  The is cube texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:CubeTexture clone](  ) <br />
			[method:CubeTexture copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="CubeTextureLoader">CubeTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CubeTextureLoader CubeTextureLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:CubeTextureLoader CubeTextureLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CubeTexture load](  [param:string[] urls],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:CubeTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:CubeTextureLoader setPath](  [param:string path] ) <br />
			[method:CubeTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:CubeTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:CubeTextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="CubeTextureNode">CubeTextureNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CubeTextureNode CubeTextureNode](  [param:CubeTexture value],  [param:NodeNode uv]?,  [param:NodeNode bias]? ) <br />
			[constructor:CubeTextureNode CubeTextureNode](  [param:CubeTexture value],  [param:NodeNode uv]?,  [param:NodeNode bias]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:CubeTextureNode CubeTextureNode](  [param:CubeTexture value],  [param:NodeNode uv]?,  [param:NodeNode bias]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:CubeTextureNode CubeTextureNode](  [param:CubeTexture value],  [param:NodeNode uv]?,  [param:NodeNode bias]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode bias] -  The bias.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:NodeNode uv] -  The uv.<br />
			[property:CubeTexture value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:CubeTextureNode copy](  [param:CubeTextureNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getTexture](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:CubeTextureNode setLabel](  [param:string name] ) <br />
			[method:CubeTextureNode setName](  [param:string name] ) <br />
			[method:CubeTextureNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="CubeTexturePass">CubeTexturePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CubeTexturePass CubeTexturePass](  [param:PerspectiveCamera camera],  [param:CubeTexture envMap]?,  [param:number opacity]? ) <br />
			[constructor:CubeTexturePass CubeTexturePass](  [param:PerspectiveCamera camera],  [param:CubeTexture envMap]?,  [param:number opacity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:PerspectiveCamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:PerspectiveCamera cubeCamera] -  The cube camera.<br />
			[property:Mesh cubeMesh] -  The cube mesh.<br />
			[property:Scene cubeScene] -  The cube scene.<br />
			[property:object cubeShader] -  The cube shader.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:CubeTexture envMap] -  The env map.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number opacity] -  The opacity.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="CubicBezierCurve">CubicBezierCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CubicBezierCurve CubicBezierCurve](  [param:Vector2 v0],  [param:Vector2 v1],  [param:Vector2 v2],  [param:Vector2 v3] ) <br />
			[constructor:CubicBezierCurve CubicBezierCurve](  [param:Vector2 v0],  [param:Vector2 v1],  [param:Vector2 v2],  [param:Vector2 v3] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:Vector2 v0] -  The v0.<br />
			[property:Vector2 v1] -  The v1.<br />
			[property:Vector2 v2] -  The v2.<br />
			[property:Vector2 v3] -  The v3.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CubicBezierCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:CubicBezierCurve copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:CubicBezierCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="CubicBezierCurve3">CubicBezierCurve3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CubicBezierCurve3 CubicBezierCurve3](  [param:Vector3 v0],  [param:Vector3 v1],  [param:Vector3 v2],  [param:Vector3 v3] ) <br />
			[constructor:CubicBezierCurve3 CubicBezierCurve3](  [param:Vector3 v0],  [param:Vector3 v1],  [param:Vector3 v2],  [param:Vector3 v3] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:Vector3 v0] -  The v0.<br />
			[property:Vector3 v1] -  The v1.<br />
			[property:Vector3 v2] -  The v2.<br />
			[property:Vector3 v3] -  The v3.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CubicBezierCurve3 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:CubicBezierCurve3 copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:CubicBezierCurve3 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector3 getPoint](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getPointAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector3 getTangent](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getTangentAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Interpolant] &rarr;

		<h3 id="CubicInterpolant">CubicInterpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CubicInterpolant CubicInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]? ) <br />
			[constructor:CubicInterpolant CubicInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]?,  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) - Note: This is not designed to be called directly.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] - array of positions<br />
			[property:any resultBuffer] - buffer to store the interpolation results.<br />
			[property:any sampleValues] - array of samples<br />
			[property:number valueSize] - number of samples
		</p>
		<h4>Methods</h4>
		<p>
			[method:number[] evaluate](  [param:number t] ) - Evaluate the interpolant at position *t*.<br />
			[method:any interpolate_](  [param:number i1],  [param:number t0],  [param:number t],  [param:number t1] ) 
		</p>

		<p class="desc">
			Cubic interpolant<br />
			<code data-type="javascript"><br />
			const interpolant = new THREE.CubicInterpolant(<br />
			new Float32Array( 2 ), new Float32Array( 2 ),, n, new Float32Array( 1 ) );<br />
			interpolant.evaluate( 0.5 );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		<h3 id="Curve">Curve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Curve Curve](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Curve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:Curve copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:Curve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:T getPoint](  [param:number t],  [param:T optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:T getPointAt](  [param:number u],  [param:T optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:T[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:T[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:T getTangent](  [param:number t],  [param:T optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:T getTangentAt](  [param:number u],  [param:T optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			An extensible curve object which contains methods for interpolation<br />
			class Curve&lt;T extends Vector&gt;
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="CurvePath">CurvePath <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CurvePath CurvePath](  ) <br />
			[constructor:CurvePath CurvePath](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:boolean autoClose] -  The auto close.<br />
			[property:Curve[] curves] -  The curves.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void add](  [param:Curve curve] ) <br />
			[method:CurvePath clone](  ) <br />
			[method:void closePath](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:CurvePath copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:CurvePath fromJSON](  [param:object json] ) <br />
			[method:number[] getCurveLengths](  ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:T getPoint](  [param:number t],  [param:T optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:T getPointAt](  [param:number u],  [param:T optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:T[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:T[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:T getTangent](  [param:number t],  [param:T optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:T getTangentAt](  [param:number u],  [param:T optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr; [page:CurvePath] &rarr;

		<h3 id="CurvePathVector2">CurvePathVector2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CurvePathVector2 CurvePathVector2](  ) <br />
			[constructor:CurvePathVector2 CurvePathVector2](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:boolean autoClose] -  The auto close.<br />
			[property:Curve[] curves] -  The curves.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void add](  [param:Curve curve] ) <br />
			[method:CurvePathVector2 clone](  ) <br />
			[method:void closePath](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:CurvePathVector2 copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:CurvePathVector2 fromJSON](  [param:object json] ) <br />
			[method:number[] getCurveLengths](  ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr; [page:CurvePath] &rarr;

		<h3 id="CurvePathVector3">CurvePathVector3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CurvePathVector3 CurvePathVector3](  ) <br />
			[constructor:CurvePathVector3 CurvePathVector3](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:boolean autoClose] -  The auto close.<br />
			[property:Curve[] curves] -  The curves.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void add](  [param:Curve curve] ) <br />
			[method:CurvePathVector3 clone](  ) <br />
			[method:void closePath](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:CurvePathVector3 copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:CurvePathVector3 fromJSON](  [param:object json] ) <br />
			[method:number[] getCurveLengths](  ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector3 getPoint](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getPointAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector3 getTangent](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getTangentAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CurveUtils">CurveUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:number interpolate](  [param:number p0],  [param:number p1],  [param:number p2],  [param:number p3],  [param:number t] ) <br />
			[method:number tangentCubicBezier](  [param:number t],  [param:number p0],  [param:number p1],  [param:number p2],  [param:number p3] ) <br />
			[method:number tangentQuadraticBezier](  [param:number t],  [param:number p0],  [param:number p1],  [param:number p2] ) <br />
			[method:number tangentSpline](  [param:number t],  [param:number p0],  [param:number p1],  [param:number p2],  [param:number p3] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="CurveVector2">CurveVector2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CurveVector2 CurveVector2](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CurveVector2 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:CurveVector2 copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:CurveVector2 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="CurveVector3">CurveVector3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CurveVector3 CurveVector3](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CurveVector3 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:CurveVector3 copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:CurveVector3 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector3 getPoint](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getPointAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector3 getTangent](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getTangentAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Curves">Curves <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ExampleCustomCurves CinquefoilKnot] -  The cinquefoil knot.<br />
			[property:ExampleCustomCurves DecoratedTorusKnot4a] -  The decorated torus knot4a.<br />
			[property:ExampleCustomCurves DecoratedTorusKnot4b] -  The decorated torus knot4b.<br />
			[property:ExampleCustomCurves DecoratedTorusKnot5a] -  The decorated torus knot5a.<br />
			[property:ExampleCustomCurves DecoratedTorusKnot5c] -  The decorated torus knot5c.<br />
			[property:ExampleCustomCurves FigureEightPolynomialKnot] -  The figure eight polynomial knot.<br />
			[property:ExampleCustomCurves GrannyKnot] -  The granny knot.<br />
			[property:ExampleCustomCurves HeartCurve] -  The heart curve.<br />
			[property:ExampleCustomCurves HelixCurve] -  The helix curve.<br />
			[property:ExampleCustomCurves KnotCurve] -  The knot curve.<br />
			[property:ExampleCustomCurves TorusKnot] -  The torus knot.<br />
			[property:ExampleCustomCurves TrefoilKnot] -  The trefoil knot.<br />
			[property:ExampleCustomCurves TrefoilPolynomialKnot] -  The trefoil polynomial knot.<br />
			[property:ExampleCustomCurves VivianiCurve] -  The viviani curve.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CutByPlaneOutput">CutByPlaneOutput <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Object3D object1] -  The object1.<br />
			[property:Object3D object2] -  The object2.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="CylinderBufferGeometry">CylinderBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CylinderGeometry CylinderGeometry](  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:CylinderGeometry CylinderGeometry](  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:CylinderGeometry CylinderGeometry](  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:CylinderGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:CylinderGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="CylinderGeometry">CylinderGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:CylinderGeometry CylinderGeometry](  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:CylinderGeometry CylinderGeometry](  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:CylinderGeometry CylinderGeometry](  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:CylinderGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:CylinderGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Cylindrical">Cylindrical <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Cylindrical Cylindrical](  [param:number radius]?,  [param:number theta]?,  [param:number y]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number radius] - distance from the origin to a point in the x-z plane. Default is *1.0*.<br />
			[property:number theta] - counterclockwise angle in the x-z plane measured in radians from the positive z-axis. Default is *0*.<br />
			[property:number y] - height above the x-z plane. Default is *0*.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Cylindrical clone](  ) - Returns : Returns a new cylindrical with the same *.radius*, *.theta* and *.y* properties as this one.<br />
			[method:Cylindrical copy](  [param:Cylindrical other] ) - Copies the values of the passed Cylindrical's *.radius*, *.theta* and *.y* properties to this cylindrical.<br />
			[method:Cylindrical set](  [param:number radius],  [param:number theta],  [param:number y] ) - Sets values of this cylindrical's *.radius*, *.theta* and *.y* properties.<br />
			[method:Cylindrical setFromCartesianCoords](  [param:number x],  [param:number y],  [param:number z] ) - Sets values of this cylindrical's *.radius*, *.theta* and *.y* properties from Cartesian coordinates.<br />
			[method:Cylindrical setFromVector3](  [param:Vector3 vec3] ) - Sets values of this cylindrical's *.radius*, *.theta* and *.y* properties from the [page:Vector3 Vector3].
		</p>

		<p class="desc">
			A point's [link:https://en.wikipedia.org/wiki/Cylindrical_coordinate_system cylindrical coordinates].
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr; [page:CompressedTextureLoader] &rarr;

		<h3 id="DDSLoader">DDSLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DDSLoader DDSLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:DDSLoader DDSLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) <br />
			[constructor:DDSLoader DDSLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:CompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:DDS parse](  [param:ArrayBuffer buffer],  [param:boolean loadMipmaps] ) <br />
			[method:DDSLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:DDSLoader setPath](  [param:string path] ) <br />
			[method:DDSLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:DDSLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:DDSLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="DOFMipMapShader">DOFMipMapShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="DOMPointInit">DOMPointInit <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number w]? -  The w.<br />
			[property:number x]? -  The x.<br />
			[property:number y]? -  The y.<br />
			[property:number z]? -  The z.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="DRACOExporter">DRACOExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DRACOExporter DRACOExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:Int8Array parse](  [param:Mesh|Points object],  [param:DRACOExporterOptions options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="DRACOExporterOptions">DRACOExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number decodeSpeed]? -  The decode speed.<br />
			[property:number encodeSpeed]? -  The encode speed.<br />
			[property:number encoderMethod]? -  The encoder method.<br />
			[property:boolean exportColor]? -  The export color.<br />
			[property:boolean exportNormals]? -  The export normals.<br />
			[property:boolean exportUvs]? -  The export uvs.<br />
			[property:number[] quantization]? -  The quantization.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="DRACOLoader">DRACOLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DRACOLoader DRACOLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:DRACOLoader DRACOLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:DRACOLoader dispose](  ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:DRACOLoader preload](  ) <br />
			[method:DRACOLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:DRACOLoader setDecoderConfig](  [param:object config] ) <br />
			[method:DRACOLoader setDecoderPath](  [param:string path] ) <br />
			[method:DRACOLoader setPath](  [param:string path] ) <br />
			[method:DRACOLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:DRACOLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:DRACOLoader setWithCredentials](  [param:boolean value] ) <br />
			[method:DRACOLoader setWorkerLimit](  [param:number workerLimit] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Texture] &rarr;

		<h3 id="DataTexture">DataTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DataTexture DataTexture](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:DataTexture DataTexture](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:DataTexture DataTexture](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any DEFAULT_IMAGE] -  The d e f a u l t_ i m a g e.<br />
			[property:any DEFAULT_MAPPING] -  The d e f a u l t_ m a p p i n g.<br />
			[property:number anisotropy] -  The anisotropy.<br />
			[property:Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:ImageData image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isDataTexture] -  The is data texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:DataTexture clone](  ) <br />
			[method:DataTexture copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Texture] &rarr;

		<h3 id="DataTexture2DArray">DataTexture2DArray <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DataTexture2DArray DataTexture2DArray](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:number depth]? ) <br />
			[constructor:DataTexture2DArray DataTexture2DArray](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:DataTexture2DArray DataTexture2DArray](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any DEFAULT_IMAGE] -  The d e f a u l t_ i m a g e.<br />
			[property:any DEFAULT_MAPPING] -  The d e f a u l t_ m a p p i n g.<br />
			[property:number anisotropy] -  The anisotropy.<br />
			[property:Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isDataTexture2DArray] -  The is data texture2 d array.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:boolean wrapR] -  The wrap r.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:DataTexture2DArray clone](  ) <br />
			[method:DataTexture2DArray copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Texture] &rarr;

		<h3 id="DataTexture3D">DataTexture3D <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DataTexture3D DataTexture3D](  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth] ) <br />
			[constructor:DataTexture3D DataTexture3D](  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth],  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:DataTexture3D DataTexture3D](  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth],  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any DEFAULT_IMAGE] -  The d e f a u l t_ i m a g e.<br />
			[property:any DEFAULT_MAPPING] -  The d e f a u l t_ m a p p i n g.<br />
			[property:number anisotropy] -  The anisotropy.<br />
			[property:Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isDataTexture3D] -  The is data texture3 d.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:boolean wrapR] -  The wrap r.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:DataTexture3D clone](  ) <br />
			[method:DataTexture3D copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="DataTextureLoader">DataTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DataTextureLoader DataTextureLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:DataTextureLoader DataTextureLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DataTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:DataTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:DataTextureLoader setPath](  [param:string path] ) <br />
			[method:DataTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:DataTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:DataTextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="DataUtils">DataUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:number toHalfFloat](  [param:number val] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="DecalGeometry">DecalGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DecalGeometry DecalGeometry](  [param:Mesh mesh],  [param:Vector3 position],  [param:Euler orientation],  [param:Vector3 size] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:DecalGeometry DecalGeometry](  [param:Mesh mesh],  [param:Vector3 position],  [param:Euler orientation],  [param:Vector3 size] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:DecalGeometry DecalGeometry](  [param:Mesh mesh],  [param:Vector3 position],  [param:Euler orientation],  [param:Vector3 size] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:DecalGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="DecalVertex">DecalVertex <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DecalVertex DecalVertex](  [param:Vector3 position],  [param:Vector3 normal] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:DecalVertex clone](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="DecodeUTF8">DecodeUTF8 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DecodeUTF8 DecodeUTF8](  [param:StringStreamHandler cb]? ) - Creates a UTF-8 decoding stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:StringStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be decoded from UTF-8 binary
		</p>

		<p class="desc">
			Streaming UTF-8 decoding
		</p>

		<hr class="interface-line"/>
		<h3 id="Decompress">Decompress <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Decompress Decompress](  [param:FlateStreamHandler cb]? ) - Creates a decompression stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:FlateStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be decompressed
		</p>

		<p class="desc">
			Streaming GZIP, Zlib, or raw DEFLATE decompression
		</p>

		<hr class="interface-line"/>
		<h3 id="Deflate">Deflate <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Deflate Deflate](  [param:DeflateOptions opts],  [param:FlateStreamHandler cb]? ) - Creates a DEFLATE stream<br />
			[constructor:Deflate Deflate](  [param:DeflateOptions opts],  [param:FlateStreamHandler cb]?,  [param:FlateStreamHandler cb]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:FlateStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be deflated
		</p>

		<p class="desc">
			Streaming DEFLATE compression
		</p>

		<hr class="interface-line"/>
		<h3 id="DeflateOptions">DeflateOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' level]? - The level of compression to use, ranging from 0-9.<br />
			0 will store the data without compression.<br />
			1 is fastest but compresses the worst, 9 is slowest but compresses the best.<br />
			The default level is 6.<br />
			<br />
			Typically, binary data benefits much more from higher values than text data.<br />
			In both cases, higher values usually take disproportionately longer than the reduction in final size that results.<br />
			<br />
			For example, a 1 MB text file could:<br />
			- become 1.01 MB with level 0 in 1ms<br />
			- become 400 kB with level 1 in 10ms<br />
			- become 320 kB with level 9 in 100ms<br />
			[property:'0'|'1'|'2'|'3'|'4'|'10'|'5'|'6'|'7'|'8'|'9'|'11'|'12' mem]? - The memory level to use, ranging from 0-12. Increasing this increases speed and compression ratio at the cost of memory.<br />
			Note that this is exponential: while level 0 uses 4 kB, level 4 uses 64 kB, level 8 uses 1 MB, and level 12 uses 16 MB.<br />
			It is recommended not to lower the value below 4, since that tends to hurt performance.<br />
			In addition, values above 8 tend to help very little on most data and can even hurt performance.<br />
			<br />
			The default value is automatically determined based on the size of the input data.
		</p>

		<p class="desc">
			Options for compressing data into a DEFLATE format
		</p>

		<hr class="interface-line"/>
		<h3 id="DepthLimitedBlurShader">DepthLimitedBlurShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Texture] &rarr;

		<h3 id="DepthTexture">DepthTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DepthTexture DepthTexture](  [param:number width],  [param:number height],  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]? ) <br />
			[constructor:DepthTexture DepthTexture](  [param:number width],  [param:number height],  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:DepthTexture DepthTexture](  [param:number width],  [param:number height],  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any DEFAULT_IMAGE] -  The d e f a u l t_ i m a g e.<br />
			[property:any DEFAULT_MAPPING] -  The d e f a u l t_ m a p p i n g.<br />
			[property:number anisotropy] -  The anisotropy.<br />
			[property:Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isDepthTexture] -  The is depth texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:DepthTexture clone](  ) <br />
			[method:DepthTexture copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="DigitalGlitch">DigitalGlitch <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Light] &rarr;

		<h3 id="DirectionalLight">DirectionalLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DirectionalLight DirectionalLight](  [param:ColorRepresentation color]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:DirectionalLight DirectionalLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:DirectionalLight DirectionalLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:DirectionalLight DirectionalLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number intensity] - Light's intensity.<br />
			[property:any isDirectionalLight] -  The is directional light.<br />
			[property:any isLight] -  The is light.<br />
			[property:Vector3 position] -  The position.<br />
			[property:DirectionalLightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:Object3D target] - Target used for shadow camera orientation.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DirectionalLight add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:DirectionalLight applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:DirectionalLight attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:DirectionalLight clear](  ) - Removes all child objects.<br />
			[method:DirectionalLight clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:DirectionalLight copy](  [param:DirectionalLight source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:DirectionalLight remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:DirectionalLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:DirectionalLight rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:DirectionalLight rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:DirectionalLight rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:DirectionalLight rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:DirectionalLight rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:DirectionalLight translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:DirectionalLight translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:DirectionalLight translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:DirectionalLight translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			see {@link https://github.com/mrdoob/three.js/blob/master/src/lights/DirectionalLight.js|src/lights/DirectionalLight.js}
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="DirectionalLightHelper">DirectionalLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DirectionalLightHelper DirectionalLightHelper](  [param:DirectionalLight light],  [param:number size]?,  [param:ColorRepresentation color]? ) <br />
			[constructor:DirectionalLightHelper DirectionalLightHelper](  [param:DirectionalLight light],  [param:number size]?,  [param:ColorRepresentation color]? ) - The constructor takes no arguments.<br />
			[constructor:DirectionalLightHelper DirectionalLightHelper](  [param:DirectionalLight light],  [param:number size]?,  [param:ColorRepresentation color]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:ColorRepresentation color] -  The color.<br />
			[property:DirectionalLight light] -  The light.<br />
			[property:Line lightPlane] -  The light plane.<br />
			[property:Matrix4 matrix] - The local transform matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:Line targetLine] -  The target line.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DirectionalLightHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:DirectionalLightHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:DirectionalLightHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:DirectionalLightHelper clear](  ) - Removes all child objects.<br />
			[method:DirectionalLightHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:DirectionalLightHelper copy](  [param:DirectionalLightHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:DirectionalLightHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:DirectionalLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:DirectionalLightHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:DirectionalLightHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:DirectionalLightHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:DirectionalLightHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:DirectionalLightHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:DirectionalLightHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:DirectionalLightHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:DirectionalLightHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:DirectionalLightHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:LightShadow] &rarr;

		<h3 id="DirectionalLightShadow">DirectionalLightShadow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DirectionalLightShadow DirectionalLightShadow](  [param:Camera camera] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:number bias] -  The bias.<br />
			[property:number blurSamples] -  The blur samples.<br />
			[property:OrthographicCamera camera] -  The camera.<br />
			[property:any isDirectionalLightShadow] -  The is directional light shadow.<br />
			[property:WebGLRenderTarget map] -  The map.<br />
			[property:WebGLRenderTarget mapPass] -  The map pass.<br />
			[property:Vector2 mapSize] -  The map size.<br />
			[property:Matrix4 matrix] -  The matrix.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number normalBias] -  The normal bias.<br />
			[property:number radius] -  The radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DirectionalLightShadow clone](  [param:boolean recursive]? ) <br />
			[method:DirectionalLightShadow copy](  [param:LightShadow source] ) <br />
			[method:void dispose](  ) <br />
			[method:Vector2 getFrameExtents](  ) <br />
			[method:number getFrustum](  ) <br />
			[method:Vector4 getViewport](  [param:number viewportIndex] ) <br />
			[method:any toJSON](  ) <br />
			[method:void updateMatrices](  [param:Light light],  [param:number viewportIndex]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Interpolant] &rarr;

		<h3 id="DiscreteInterpolant">DiscreteInterpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DiscreteInterpolant DiscreteInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]? ) <br />
			[constructor:DiscreteInterpolant DiscreteInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]?,  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) - Note: This is not designed to be called directly.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] - array of positions<br />
			[property:any resultBuffer] - buffer to store the interpolation results.<br />
			[property:any sampleValues] - array of samples<br />
			[property:number valueSize] - number of samples
		</p>
		<h4>Methods</h4>
		<p>
			[method:number[] evaluate](  [param:number t] ) - Evaluate the interpolant at position *t*.<br />
			[method:any interpolate_](  [param:number i1],  [param:number t0],  [param:number t],  [param:number t1] ) 
		</p>

		<p class="desc">
			Discrete Interpolant<br />
			<code data-type="javascript"><br />
			const interpolant = new THREE.DiscreteInterpolant(<br />
			new Float32Array( 2 ), new Float32Array( 2 ),, n, new Float32Array( 1 ) );<br />
			interpolant.evaluate( 0.5 );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:PolyhedronGeometry] &rarr;

		<h3 id="DodecahedronBufferGeometry">DodecahedronBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DodecahedronGeometry DodecahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:DodecahedronGeometry DodecahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:DodecahedronGeometry DodecahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:DodecahedronGeometry DodecahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:DodecahedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:DodecahedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:PolyhedronGeometry] &rarr;

		<h3 id="DodecahedronGeometry">DodecahedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DodecahedronGeometry DodecahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:DodecahedronGeometry DodecahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:DodecahedronGeometry DodecahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:DodecahedronGeometry DodecahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:DodecahedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:DodecahedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="DotScreenPass">DotScreenPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DotScreenPass DotScreenPass](  [param:Vector2 center]?,  [param:number angle]?,  [param:number scale]? ) <br />
			[constructor:DotScreenPass DotScreenPass](  [param:Vector2 center]?,  [param:number angle]?,  [param:number scale]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="DotScreenShader">DotScreenShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="DragControls">DragControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:DragControls DragControls](  [param:Object3D[] objects],  [param:Camera camera],  [param:HTMLElement domElement]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:DragControls DragControls](  [param:Object3D[] objects],  [param:Camera camera],  [param:HTMLElement domElement]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean enabled] -  The enabled.<br />
			[property:Camera object] -  The object.<br />
			[property:boolean transformGroup] -  The transform group.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void activate](  ) <br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void deactivate](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D[] getObjects](  ) <br />
			[method:Raycaster getRaycaster](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr; [page:DataTextureLoader] &rarr;

		<h3 id="EXRLoader">EXRLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:EXRLoader EXRLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:EXRLoader EXRLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) <br />
			[constructor:EXRLoader EXRLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:TextureDataType type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DataTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:EXR parse](  [param:ArrayBuffer buffer] ) <br />
			[method:EXRLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:EXRLoader setDataType](  [param:TextureDataType type] ) <br />
			[method:EXRLoader setPath](  [param:string path] ) <br />
			[method:EXRLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:EXRLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:EXRLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="EdgeSplitModifier">EdgeSplitModifier <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:EdgeSplitModifier EdgeSplitModifier](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry modify](  [param:BufferGeometry geometry],  [param:number cutOffPoint],  [param:boolean tryKeepNormals] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="EdgesGeometry">EdgesGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:EdgesGeometry EdgesGeometry](  [param:TBufferGeometry geometry]?,  [param:number thresholdAngle]? ) <br />
			[constructor:EdgesGeometry EdgesGeometry](  [param:TBufferGeometry geometry]?,  [param:number thresholdAngle]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:EdgesGeometry EdgesGeometry](  [param:TBufferGeometry geometry]?,  [param:number thresholdAngle]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:EdgesGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="EffectComposer">EffectComposer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:EffectComposer EffectComposer](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget renderTarget]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Clock clock] -  The clock.<br />
			[property:ShaderPass copyPass] -  The copy pass.<br />
			[property:Pass[] passes] -  The passes.<br />
			[property:WebGLRenderTarget readBuffer] -  The read buffer.<br />
			[property:WebGLRenderTarget renderTarget1] -  The render target1.<br />
			[property:WebGLRenderTarget renderTarget2] -  The render target2.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:WebGLRenderTarget writeBuffer] -  The write buffer.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addPass](  [param:Pass pass] ) <br />
			[method:void insertPass](  [param:Pass pass],  [param:number index] ) <br />
			[method:boolean isLastEnabledPass](  [param:number passIndex] ) <br />
			[method:void removePass](  [param:Pass pass] ) <br />
			[method:void render](  [param:number deltaTime]? ) <br />
			[method:void reset](  [param:WebGLRenderTarget renderTarget]? ) <br />
			[method:void setPixelRatio](  [param:number pixelRatio] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) <br />
			[method:void swapBuffers](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="EllipseCurve">EllipseCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:EllipseCurve EllipseCurve](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[constructor:EllipseCurve EllipseCurve](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean aClockwise] -  The a clockwise.<br />
			[property:number aEndAngle] -  The a end angle.<br />
			[property:number aRotation] -  The a rotation.<br />
			[property:number aStartAngle] -  The a start angle.<br />
			[property:number aX] -  The a x.<br />
			[property:number aY] -  The a y.<br />
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:number xRadius] -  The x radius.<br />
			[property:number yRadius] -  The y radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:EllipseCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:EllipseCurve copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:EllipseCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="EncodeUTF8">EncodeUTF8 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:EncodeUTF8 EncodeUTF8](  [param:FlateStreamHandler cb]? ) - Creates a UTF-8 decoding stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:FlateStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:string chunk],  [param:boolean final]? ) - Pushes a chunk to be encoded to UTF-8
		</p>

		<p class="desc">
			Streaming UTF-8 encoding
		</p>

		<hr class="interface-line"/>
		<h3 id="Euler">Euler <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Euler Euler](  [param:number x]?,  [param:number y]?,  [param:number z]?,  [param:string order]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string DefaultOrder] -  The default order.<br />
			[property:string[] RotationOrders] -  The rotation orders.<br />
			[property:any isEuler] -  The is euler.<br />
			[property:string order] - The order in which to apply rotations. Default is 'XYZ', which means that the object will first be rotated around its X axis, then its Y axis and finally its Z axis. Other possibilities are:<br />
			'YZX', 'ZXY', 'XZY', 'YXZ' and 'ZYX'. These must be in upper case.<br />
			Three.js uses &lt;em&gt;intrinsic&lt;/em&gt; Tait-Bryan angles. This means that rotations are performed with respect to the &lt;em&gt;local&lt;/em&gt; coordinate system. That is, for order 'XYZ', the rotation is first around the local-Xt axis (which is the same as the world-X axis), then around local-Y (which may now be different from the world Y-axis), then local-Z (which may be different from the world Z-axis).<br />
			[property:number x] - the angle of the x axis in radians. Default is *0*.<br />
			[property:number y] - the angle of the y axis in radians. Default is *0*.<br />
			[property:number z] - the angle of the z axis in radians. Default is *0*.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Euler _onChange](  [param:any callback] ) <br />
			[method:void _onChangeCallback](  ) <br />
			[method:Euler clone](  ) - Returns : Returns a new Euler with the same parameters as this one.<br />
			[method:Euler copy](  [param:Euler euler] ) - Copies value of [page:Euler euler] to this euler.<br />
			[method:boolean equals](  [param:Euler euler] ) - Checks for strict equality of this euler and [page:Euler euler].<br />
			[method:Euler fromArray](  [param:any[] xyzo] ) - Assigns this euler's *.x* angle to array[0].<br />
			Assigns this euler's *.y* angle to array[1].<br />
			Assigns this euler's *.z* angle to array[2].<br />
			Optionally assigns this euler's *.order* to array[3].<br />
			[method:Euler reorder](  [param:string newOrder] ) - Resets the euler angle with a new order by creating a quaternion from this euler angle and then setting this euler angle with the quaternion and the new order.<br />
			&lt;em&gt;WARNING&lt;/em&gt;: this discards revolution information.<br />
			[method:Euler set](  [param:number x],  [param:number y],  [param:number z],  [param:string order]? ) - Sets the angles of this euler transform and optionally the *.order*.<br />
			[method:Euler setFromQuaternion](  [param:Quaternion q],  [param:string order]?,  [param:boolean update]? ) - Sets the angles of this euler transform from a normalized quaternion based on the orientation specified by *.order*.<br />
			[method:Euler setFromRotationMatrix](  [param:Matrix4 m],  [param:string order]?,  [param:boolean update]? ) - Sets the angles of this euler transform from a pure rotation matrix based on the orientation specified by order.<br />
			[method:Euler setFromVector3](  [param:Vector3 v],  [param:string order]? ) - Set the *.x*, *.y* and *.z*, and optionally update the *.order*.<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns : Returns an array of the form [*.x*, *.y*, *.z*, *.order*].<br />
			[method:Vector3 toVector3](  [param:Vector3 optionalResult]? ) - Returns : Returns the Euler's *.x*, *.y* and *.z* properties as a [page:Vector3 Vector3].
		</p>

		<p class="desc">
			A class representing [link:http://en.wikipedia.org/wiki/Euler_angles Euler Angles].<br />
			Euler angles describe a rotational transformation by rotating an object on its various axes in specified amounts per axis, and a specified axis order.<br />
			<code data-type="javascript"><br />
			const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );<br />
			const b = new THREE.Vector3( 1, 0, 1 );<br />
			b.applyEuler(a);<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:BaseEvent] &rarr;

		<h3 id="Event">Event <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any target]? -  The target.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			Event object.
		</p>

		<hr class="interface-line"/>
		<h3 id="EventDispatcher">EventDispatcher <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:EventDispatcher EventDispatcher](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void dispatchEvent](  [param:E event] ) - Fire an event type.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.
		</p>

		<p class="desc">
			JavaScript events for custom objects.<br />
			[link:https://github.com/mrdoob/eventdispatcher.js Eventdispatcher on GitHub]<br />
			<code data-type="javascript"><br />
			//  Adding events to a custom object<br />
			class Car extends EventDispatcher {<br />
				start() {<br />
					this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );<br />
				}<br />
			};<br />
			//  Using events with the custom object<br />
			const car = new Car();<br />
			car.addEventListener( 'start', function ( event ) {<br />
				alert( event.message );<br />
			});<br />
			car.start();<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="ExampleCustomCurves">ExampleCustomCurves <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ExampleCustomCurves ExampleCustomCurves](  [param:number scale]? ) <br />
			[constructor:ExampleCustomCurves ExampleCustomCurves](  [param:number scale]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number scale] -  The scale.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ExampleCustomCurves clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ExampleCustomCurves copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:ExampleCustomCurves fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector3 getPoint](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getPointAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector3 getTangent](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getTangentAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:FunctionNode] &rarr;

		<h3 id="ExpressionNode">ExpressionNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ExpressionNode ExpressionNode](  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]? ) <br />
			[constructor:ExpressionNode ExpressionNode](  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]? ) <br />
			[constructor:ExpressionNode ExpressionNode](  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ExpressionNode ExpressionNode](  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object extensions] -  The extensions.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:object[] includes] -  The includes.<br />
			[property:FunctionNodeInput[] inputs] -  The inputs.<br />
			[property:boolean isMethod] -  The is method.<br />
			[property:any isNode] -  The is node.<br />
			[property:object keywords] -  The keywords.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean useKeywords] -  The use keywords.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ExpressionNode copy](  [param:FunctionNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getIncludeByName](  [param:string name] ) <br />
			[method:FunctionNodeInput getInputByName](  [param:string name] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]? ) <br />
			[method:ExpressionNode setLabel](  [param:string name] ) <br />
			[method:ExpressionNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="ExtrudeBufferGeometry">ExtrudeBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ExtrudeGeometry ExtrudeGeometry](  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ExtrudeGeometry ExtrudeGeometry](  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ExtrudeGeometry ExtrudeGeometry](  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:void addShape](  [param:Shape shape],  [param:any options]? ) <br />
			[method:void addShapeList](  [param:Shape[] shapes],  [param:any options]? ) <br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ExtrudeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:ExtrudeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="ExtrudeGeometry">ExtrudeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ExtrudeGeometry ExtrudeGeometry](  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ExtrudeGeometry ExtrudeGeometry](  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ExtrudeGeometry ExtrudeGeometry](  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:void addShape](  [param:Shape shape],  [param:any options]? ) <br />
			[method:void addShapeList](  [param:Shape[] shapes],  [param:any options]? ) <br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ExtrudeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:ExtrudeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ExtrudeGeometryOptions">ExtrudeGeometryOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:UVGenerator UVGenerator]? -  The u v generator.<br />
			[property:boolean bevelEnabled]? -  The bevel enabled.<br />
			[property:number bevelOffset]? -  The bevel offset.<br />
			[property:number bevelSegments]? -  The bevel segments.<br />
			[property:number bevelSize]? -  The bevel size.<br />
			[property:number bevelThickness]? -  The bevel thickness.<br />
			[property:number curveSegments]? -  The curve segments.<br />
			[property:number depth]? -  The depth.<br />
			[property:Curve extrudePath]? -  The extrude path.<br />
			[property:number steps]? -  The steps.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="FBXLoader">FBXLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FBXLoader FBXLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:FBXLoader FBXLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Group parse](  [param:string|ArrayBuffer FBXBuffer],  [param:string path] ) <br />
			[method:FBXLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:FBXLoader setPath](  [param:string path] ) <br />
			[method:FBXLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:FBXLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:FBXLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FXAAShader">FXAAShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Face">Face <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number a] -  The a.<br />
			[property:number b] -  The b.<br />
			[property:number c] -  The c.<br />
			[property:number materialIndex] -  The material index.<br />
			[property:Vector3 normal] -  The normal.
		</p>

		<p class="desc">
			Face
		</p>

		<hr class="interface-line"/>
		<h3 id="FaceEx">FaceEx <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FaceEx FaceEx](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number area] -  The area.<br />
			[property:number constant] -  The constant.<br />
			[property:HalfEdge edge] -  The edge.<br />
			[property:number mark] -  The mark.<br />
			[property:Vector3 midpoint] -  The midpoint.<br />
			[property:Vector3 normal] -  The normal.<br />
			[property:VertexNode outside] -  The outside.
		</p>
		<h4>Methods</h4>
		<p>
			[method:FaceEx compute](  ) <br />
			[method:FaceEx create](  [param:VertexNode a],  [param:VertexNode b],  [param:VertexNode c] ) <br />
			[method:HalfEdge getEdge](  [param:number i] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="FileLoader">FileLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FileLoader FileLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:FileLoader FileLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:MimeType mimeType] -  The mime type.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:string responseType] -  The response type.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:FileLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:FileLoader setMimeType](  [param:MimeType mimeType] ) <br />
			[method:FileLoader setPath](  [param:string path] ) <br />
			[method:FileLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:FileLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:FileLoader setResponseType](  [param:string responseType] ) <br />
			[method:FileLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="FilmPass">FilmPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FilmPass FilmPass](  [param:number noiseIntensity]?,  [param:number scanlinesIntensity]?,  [param:number scanlinesCount]?,  [param:number grayscale]? ) <br />
			[constructor:FilmPass FilmPass](  [param:number noiseIntensity]?,  [param:number scanlinesIntensity]?,  [param:number scanlinesCount]?,  [param:number grayscale]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FilmShader">FilmShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FirstPersonControls">FirstPersonControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FirstPersonControls FirstPersonControls](  [param:Camera object],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean activeLook] -  The active look.<br />
			[property:boolean autoForward] -  The auto forward.<br />
			[property:boolean constrainVertical] -  The constrain vertical.<br />
			[property:HTMLElement|HTMLDocument domElement] -  The dom element.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:number heightCoef] -  The height coef.<br />
			[property:number heightMax] -  The height max.<br />
			[property:number heightMin] -  The height min.<br />
			[property:boolean heightSpeed] -  The height speed.<br />
			[property:number lookSpeed] -  The look speed.<br />
			[property:boolean lookVertical] -  The look vertical.<br />
			[property:boolean mouseDragOn] -  The mouse drag on.<br />
			[property:number movementSpeed] -  The movement speed.<br />
			[property:Camera object] -  The object.<br />
			[property:number verticalMax] -  The vertical max.<br />
			[property:number verticalMin] -  The vertical min.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void handleResize](  ) <br />
			[method:FirstPersonControls lookAt](  [param:number|Vector3 x],  [param:number y],  [param:number z] ) <br />
			[method:FirstPersonControls update](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FlatMesh">FlatMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number expressID] -  The express i d.<br />
			[property:VectorEx geometries] -  The geometries.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Float16BufferAttribute">Float16BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Float16BufferAttribute Float16BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Float16BufferAttribute Float16BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Float16BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float16BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float16BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float16BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Float16BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Float16BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Float16BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Float16BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Float16BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Float16BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Float16BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Float16BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Float16BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Float16BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Float16BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Float16BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Float16BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Float16BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Float16BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Float16BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Float16BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Float16BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Float16 buffer attribute
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Float32Attribute">Float32Attribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Float32Attribute Float32Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Float32Attribute Float32Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Float32Attribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float32Attribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float32Attribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float32Attribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Float32Attribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Float32Attribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Float32Attribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Float32Attribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Float32Attribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Float32Attribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Float32Attribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Float32Attribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Float32Attribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Float32Attribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Float32Attribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Float32Attribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Float32Attribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Float32Attribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Float32Attribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Float32Attribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Float32Attribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Float32Attribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			deprecated - THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Float32BufferAttribute">Float32BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Float32BufferAttribute Float32BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Float32BufferAttribute Float32BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Float32BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float32BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float32BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float32BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Float32BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Float32BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Float32BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Float32BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Float32BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Float32BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Float32BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Float32BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Float32BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Float32BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Float32BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Float32BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Float32BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Float32BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Float32BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Float32BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Float32BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Float32BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Float32 buffer attribute
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Float64Attribute">Float64Attribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Float64Attribute Float64Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Float64Attribute Float64Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Float64Attribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float64Attribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float64Attribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float64Attribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Float64Attribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Float64Attribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Float64Attribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Float64Attribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Float64Attribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Float64Attribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Float64Attribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Float64Attribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Float64Attribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Float64Attribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Float64Attribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Float64Attribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Float64Attribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Float64Attribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Float64Attribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Float64Attribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Float64Attribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Float64Attribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			deprecated - THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Float64BufferAttribute">Float64BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Float64BufferAttribute Float64BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Float64BufferAttribute Float64BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Float64BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float64BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float64BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Float64BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Float64BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Float64BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Float64BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Float64BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Float64BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Float64BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Float64BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Float64BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Float64BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Float64BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Float64BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Float64BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Float64BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Float64BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Float64BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Float64BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Float64BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Float64BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Float64 buffer attribute
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="FloatNode">FloatNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FloatNode FloatNode](  [param:number value]? ) <br />
			[constructor:FloatNode FloatNode](  [param:number value]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:FloatNode FloatNode](  [param:number value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:FloatNode FloatNode](  [param:number value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:FloatNode copy](  [param:FloatNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:FloatNode setLabel](  [param:string name] ) <br />
			[method:FloatNode setName](  [param:string name] ) <br />
			[method:FloatNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Flow">Flow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Flow Flow](  [param:Mesh mesh],  [param:number numberOfCurves]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] curveArray] -  The curve array.<br />
			[property:number[] curveLengthArray] -  The curve length array.<br />
			[property:Mesh object3D] -  The object3 d.<br />
			[property:DataTexture splineTexure] -  The spline texure.<br />
			[property:SplineUniform uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void moveAlongCurve](  [param:number amount] ) <br />
			[method:void updateCurve](  [param:number index],  [param:Curve curve] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="FlyControls">FlyControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FlyControls FlyControls](  [param:Camera object],  [param:HTMLElement domElement]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:FlyControls FlyControls](  [param:Camera object],  [param:HTMLElement domElement]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoForward] -  The auto forward.<br />
			[property:HTMLElement|HTMLDocument domElement] -  The dom element.<br />
			[property:boolean dragToLook] -  The drag to look.<br />
			[property:number movementSpeed] -  The movement speed.<br />
			[property:Camera object] -  The object.<br />
			[property:number rollSpeed] -  The roll speed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void update](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FocusShader">FocusShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FogBase">FogBase <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FogBase FogBase](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:string name] -  The name.
		</p>
		<h4>Methods</h4>
		<p>
			[method:FogBase clone](  ) <br />
			[method:any toJSON](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:FogBase] &rarr;

		<h3 id="FogExp2">FogExp2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FogExp2 FogExp2](  [param:string|number hex],  [param:number density]? ) <br />
			[constructor:FogExp2 FogExp2](  [param:string|number hex],  [param:number density]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number density] - Defines how fast the fog will grow dense.<br />
			[property:any isFogExp2] -  The is fog exp2.<br />
			[property:string name] -  The name.
		</p>
		<h4>Methods</h4>
		<p>
			[method:FogExp2 clone](  ) <br />
			[method:any toJSON](  ) 
		</p>

		<p class="desc">
			This class contains the parameters that define linear fog, i.e., that grows exponentially denser with the distance.
		</p>

		<hr class="interface-line"/>
		<h3 id="Font">Font <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Font Font](  [param:any jsondata] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string data] -  The data.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Shape[] generateShapes](  [param:string text],  [param:number size] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="FontLoader">FontLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FontLoader FontLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:FontLoader FontLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Font parse](  [param:any json] ) <br />
			[method:FontLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:FontLoader setPath](  [param:string path] ) <br />
			[method:FontLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:FontLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:FontLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FreiChenShader">FreiChenShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Frustum">Frustum <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Frustum Frustum](  [param:Plane p0]?,  [param:Plane p1]?,  [param:Plane p2]?,  [param:Plane p3]?,  [param:Plane p4]?,  [param:Plane p5]? ) - Creates a new Frustum.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Plane[] planes] - Array of 6 [page:Plane planes].
		</p>
		<h4>Methods</h4>
		<p>
			[method:Frustum clone](  ) - Returns : Return a new Frustum with the same parameters as this one.<br />
			[method:boolean containsPoint](  [param:Vector3 point] ) - Checks to see if the frustum contains the [page:Vector3 point].<br />
			[method:Frustum copy](  [param:Frustum frustum] ) <br />
			[method:boolean intersectsBox](  [param:Box3 box] ) - Returns : Return true if [page:Box3 box] intersects with this frustum.<br />
			[method:boolean intersectsObject](  [param:Object3D object] ) - Checks whether the [page:Object3D object]'s [page:BufferGeometry.boundingSphere bounding sphere] is intersecting the Frustum.<br />
			Note that the object must have a [page:BufferGeometry geometry] so that the bounding sphere can be calculated.<br />
			[method:boolean intersectsSphere](  [param:Sphere sphere] ) - Returns : Return true if [page:Sphere sphere] intersects with this frustum.<br />
			[method:boolean intersectsSprite](  [param:Sprite sprite] ) - Checks whether the [sprite](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Sprite) is intersecting the Frustum.<br />
			<br />
			Returns : true if sprite<br />
			[method:Frustum set](  [param:Plane p0],  [param:Plane p1],  [param:Plane p2],  [param:Plane p3],  [param:Plane p4],  [param:Plane p5] ) - Sets the frustum from the passed planes. No plane order is implied.<br />
			Note that this method only copies the values from the given objects.<br />
			[method:Frustum setFromProjectionMatrix](  [param:Matrix4 m] ) - Sets the frustum planes from the projection matrix.
		</p>

		<p class="desc">
			[link:http://en.wikipedia.org/wiki/Frustum Frustums] are used to determine what is inside the camera's field of view. They help speed up the rendering process - objects which lie outside a camera's frustum can safely be excluded from rendering.<br />
			This class is mainly intended for use internally by a renderer for calculating a [page:Camera camera] or [page:LightShadow.camera shadowCamera]'s frustum.
		</p>

		<hr class="interface-line"/>
		<h3 id="FullScreenQuad">FullScreenQuad <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FullScreenQuad FullScreenQuad](  [param:Material material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Material material] -  The material.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void render](  [param:WebGLRenderer renderer] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="FunctionCallNode">FunctionCallNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FunctionCallNode FunctionCallNode](  [param:FunctionNode func],  [param:NodeNode[] inputs]? ) <br />
			[constructor:FunctionCallNode FunctionCallNode](  [param:FunctionNode func],  [param:NodeNode[] inputs]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:FunctionCallNode FunctionCallNode](  [param:FunctionNode func],  [param:NodeNode[] inputs]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:NodeNode[] inputs] -  The inputs.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:FunctionNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:FunctionCallNode copy](  [param:FunctionCallNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:FunctionNode getFunction](  ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void setFunction](  [param:FunctionNode func],  [param:NodeNode[] inputs]? ) <br />
			[method:FunctionCallNode setLabel](  [param:string name] ) <br />
			[method:FunctionCallNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="FunctionNode">FunctionNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:FunctionNode FunctionNode](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]? ) <br />
			[constructor:FunctionNode FunctionNode](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:FunctionNode FunctionNode](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object extensions] -  The extensions.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:object[] includes] -  The includes.<br />
			[property:FunctionNodeInput[] inputs] -  The inputs.<br />
			[property:boolean isMethod] -  The is method.<br />
			[property:any isNode] -  The is node.<br />
			[property:object keywords] -  The keywords.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean useKeywords] -  The use keywords.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:FunctionNode copy](  [param:FunctionNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getIncludeByName](  [param:string name] ) <br />
			[method:FunctionNodeInput getInputByName](  [param:string name] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]? ) <br />
			[method:FunctionNode setLabel](  [param:string name] ) <br />
			[method:FunctionNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FunctionNodeInput">FunctionNodeInput <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string name] -  The name.<br />
			[property:string qualifier] -  The qualifier.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="GCodeLoader">GCodeLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:GCodeLoader GCodeLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:GCodeLoader GCodeLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean splitLayer] -  The split layer.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Group parse](  [param:string data] ) <br />
			[method:GCodeLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:GCodeLoader setPath](  [param:string path] ) <br />
			[method:GCodeLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:GCodeLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:GCodeLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GLBufferAttribute">GLBufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:GLBufferAttribute GLBufferAttribute](  [param:WebGLBuffer buffer],  [param:number type],  [param:number itemSize],  [param:'1'|'2'|'4' elementSize],  [param:number count] ) - gl.FLOAT: 4<br />
			gl.UNSIGNED_SHORT: 2<br />
			gl.SHORT: 2<br />
			gl.UNSIGNED_INT: 4<br />
			gl.INT: 4<br />
			gl.BYTE: 1<br />
			gl.UNSIGNED_BYTE: 1
		</p>
		<h4>Properties</h4>
		<p>
			[property:WebGLBuffer buffer] - The current &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer" target="_blank"&gt;WebGLBuffer&lt;/a&gt; instance.<br />
			[property:number count] - The expected number of vertices in VBO.<br />
			[property:'1'|'2'|'4' elementSize] - Stores the corresponding size in bytes for the current *type* property value.<br />
			See above (constructor) for a list of known type sizes.<br />
			[property:any isGLBufferAttribute] - Read-only. Always *true*.<br />
			[property:number itemSize] - How many values make up each item (vertex).<br />
			[property:number type] - A &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Data_types" target="_blank"&gt;WebGL Data Type&lt;/a&gt;<br />
			describing the underlying VBO contents.<br />
			Set this property together with *elementSize*. The recommended way is using the *setType* method.<br />
			[property:number version] - A version number, incremented every time the needsUpdate property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:GLBufferAttribute setBuffer](  [param:WebGLBuffer buffer] ) - Sets the *buffer* property.<br />
			[method:GLBufferAttribute setCount](  [param:number count] ) - Sets the *count* property.<br />
			[method:GLBufferAttribute setItemSize](  [param:number itemSize] ) - Sets the *itemSize* property.<br />
			[method:GLBufferAttribute setType](  [param:number type],  [param:'1'|'2'|'4' elementSize] ) - Sets the both *type* and *elementSize* properties.
		</p>

		<p class="desc">
			This buffer attribute class does not construct a VBO. Instead, it uses whatever VBO is passed in constructor and can later be altered via the *buffer* property.<br />
			It is required to pass additional params alongside the VBO. Those are:<br />
			the GL context, the GL data type, the number of components per vertex, the number of bytes per component, and the number of vertices.<br />
			The most common use case for this class is when some kind of GPGPU<br />
			calculation interferes or even produces the VBOs in question.
		</p>

		<hr class="interface-line"/>
		<h3 id="GLTF">GLTF <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:AnimationClip[] animations] -  The animations.<br />
			[property:any asset] -  The asset.<br />
			[property:Camera[] cameras] -  The cameras.<br />
			[property:GLTFParser parser] -  The parser.<br />
			[property:Group scene] -  The scene.<br />
			[property:Group[] scenes] -  The scenes.<br />
			[property:any userData] -  The user data.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GLTFExporter">GLTFExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:GLTFExporter GLTFExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void parse](  [param:Object3D input],  [param:any onCompleted],  [param:GLTFExporterOptions options] ) <br />
			[method:Promise parseAsync](  [param:Object3D input],  [param:GLTFExporterOptions options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GLTFExporterOptions">GLTFExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:AnimationClip[] animations]? -  The animations.<br />
			[property:boolean binary]? -  The binary.<br />
			[property:boolean embedImages]? -  The embed images.<br />
			[property:boolean forceIndices]? -  The force indices.<br />
			[property:boolean forcePowerOfTwoTextures]? -  The force power of two textures.<br />
			[property:boolean includeCustomExtensions]? -  The include custom extensions.<br />
			[property:boolean onlyVisible]? -  The only visible.<br />
			[property:boolean trs]? -  The trs.<br />
			[property:boolean truncateDrawRange]? -  The truncate draw range.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="GLTFLoader">GLTFLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:GLTFLoader GLTFLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:GLTFLoader GLTFLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:DRACOLoader dracoLoader] -  The draco loader.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void parse](  [param:string|ArrayBuffer data],  [param:string path],  [param:any onLoad],  [param:any onError]? ) <br />
			[method:Promise parseAsync](  [param:string|ArrayBuffer data],  [param:string path] ) <br />
			[method:GLTFLoader register](  [param:any callback] ) <br />
			[method:GLTFLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:GLTFLoader setDRACOLoader](  [param:DRACOLoader dracoLoader] ) <br />
			[method:GLTFLoader setKTX2Loader](  [param:KTX2Loader ktx2Loader] ) <br />
			[method:GLTFLoader setMeshoptDecoder](  [param:any meshoptDecoder] ) <br />
			[method:GLTFLoader setPath](  [param:string path] ) <br />
			[method:GLTFLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:GLTFLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:GLTFLoader setWithCredentials](  [param:boolean value] ) <br />
			[method:GLTFLoader unregister](  [param:any callback] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GLTFLoaderPlugin">GLTFLoaderPlugin <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any afterRoot]? -  The after root.<br />
			[property:any beforeRoot]? -  The before root.<br />
			[property:any createNodeAttachment]? -  The create node attachment.<br />
			[property:any createNodeMesh]? -  The create node mesh.<br />
			[property:any extendMaterialParams]? -  The extend material params.<br />
			[property:any getMaterialType]? -  The get material type.<br />
			[property:any loadBufferView]? -  The load buffer view.<br />
			[property:any loadMaterial]? -  The load material.<br />
			[property:any loadMesh]? -  The load mesh.<br />
			[property:any loadTexture]? -  The load texture.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GLTFParser">GLTFParser <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Map associations] -  The associations.<br />
			[property:any extensions] -  The extensions.<br />
			[property:FileLoader fileLoader] -  The file loader.<br />
			[property:any json] -  The json.<br />
			[property:any options] -  The options.<br />
			[property:GLTFLoaderPlugin plugins] -  The plugins.<br />
			[property:ImageBitmapLoader|TextureLoader textureLoader] -  The texture loader.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void assignFinalMaterial](  [param:Mesh object] ) <br />
			[method:Promise assignTexture](  [param:any materialParams],  [param:string mapName],  [param:any mapDef] ) <br />
			[method:Promise createNodeMesh](  [param:number nodeIndex] ) <br />
			[method:string createUniqueName](  [param:string originalName] ) <br />
			[method:Promise getDependencies](  [param:string type] ) <br />
			[method:Promise getDependency](  [param:string type],  [param:number index] ) <br />
			[method:any getMaterialType](  ) <br />
			[method:Promise loadAccessor](  [param:number accessorIndex] ) <br />
			[method:Promise loadAnimation](  [param:number animationIndex] ) <br />
			[method:Promise loadBuffer](  [param:number bufferIndex] ) <br />
			[method:Promise loadBufferView](  [param:number bufferViewIndex] ) <br />
			[method:Promise loadCamera](  [param:number cameraIndex] ) <br />
			[method:Promise loadGeometries](  [param:any primitives] ) <br />
			[method:Promise loadMaterial](  [param:number materialIndex] ) <br />
			[method:Promise loadMesh](  [param:number meshIndex] ) <br />
			[method:Promise loadNode](  [param:number nodeIndex] ) <br />
			[method:Promise loadScene](  ) <br />
			[method:Promise loadSkin](  [param:number skinIndex] ) <br />
			[method:Promise loadTexture](  [param:number textureIndex] ) <br />
			[method:Promise loadTextureImage](  [param:number textureIndex],  [param:any source],  [param:Loader loader] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GLTFReference">GLTFReference <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number materials]? -  The materials.<br />
			[property:number meshes]? -  The meshes.<br />
			[property:number nodes]? -  The nodes.<br />
			[property:number textures]? -  The textures.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GPUComputationRenderer">GPUComputationRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:GPUComputationRenderer GPUComputationRenderer](  [param:number sizeX],  [param:number sizeY],  [param:WebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addResolutionDefine](  [param:ShaderMaterial materialShader] ) <br />
			[method:Variable addVariable](  [param:string variableName],  [param:string computeFragmentShader],  [param:Texture initialValueTexture] ) <br />
			[method:void compute](  ) <br />
			[method:WebGLRenderTarget createRenderTarget](  [param:number sizeXTexture],  [param:number sizeYTexture],  [param:Wrapping wrapS],  [param:number wrapT],  [param:TextureFilter minFilter],  [param:TextureFilter magFilter] ) <br />
			[method:ShaderMaterial createShaderMaterial](  [param:string computeFragmentShader],  [param:any uniforms]? ) <br />
			[method:DataTexture createTexture](  ) <br />
			[method:void doRenderTarget](  [param:Material material],  [param:WebGLRenderTarget output] ) <br />
			[method:WebGLRenderTarget getAlternateRenderTarget](  [param:Variable variable] ) <br />
			[method:WebGLRenderTarget getCurrentRenderTarget](  [param:Variable variable] ) <br />
			[method:string init](  ) <br />
			[method:void renderTexture](  [param:Texture input],  [param:Texture output] ) <br />
			[method:void setDataType](  [param:TextureDataType type] ) <br />
			[method:void setVariableDependencies](  [param:Variable variable],  [param:Variable[] dependencies] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GammaCorrectionShader">GammaCorrectionShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GeometriesByMaterial">GeometriesByMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IdGeometries geometries] -  The geometries.<br />
			[property:Material material] -  The material.
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GeometryCompressionUtils">GeometryCompressionUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void compressNormals](  [param:Mesh mesh],  [param:string encodeMethod] ) <br />
			[method:void compressPositions](  [param:Mesh mesh] ) <br />
			[method:void compressUvs](  [param:Mesh mesh] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GeometryUtils">GeometryUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:object computeMorphedAttributes](  [param:Line|Mesh|Points object] ) <br />
			[method:number estimateBytesUsed](  [param:BufferGeometry geometry] ) <br />
			[method:number[] gosper](  [param:number size]? ) <br />
			[method:Vector3[] hilbert2D](  [param:Vector3 center]?,  [param:number size]?,  [param:number iterations]?,  [param:number v0]?,  [param:number v1]?,  [param:number v2]?,  [param:number v3]? ) <br />
			[method:Vector3[] hilbert3D](  [param:Vector3 center]?,  [param:number size]?,  [param:number iterations]?,  [param:number v0]?,  [param:number v1]?,  [param:number v2]?,  [param:number v3]?,  [param:number v4]?,  [param:number v5]?,  [param:number v6]?,  [param:number v7]? ) <br />
			[method:InterleavedBufferAttribute interleaveAttributes](  [param:BufferAttribute[] attributes] ) <br />
			[method:BufferAttribute mergeBufferAttributes](  [param:BufferAttribute[] attributes] ) <br />
			[method:BufferGeometry mergeBufferGeometries](  [param:BufferGeometry[] geometries],  [param:boolean useGroups]? ) <br />
			[method:BufferGeometry mergeVertices](  [param:BufferGeometry geometry],  [param:number tolerance]? ) <br />
			[method:BufferGeometry toTrianglesDrawMode](  [param:BufferGeometry geometry],  [param:TrianglesDrawModes drawMode] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="GlitchPass">GlitchPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:GlitchPass GlitchPass](  [param:number dt_size]? ) <br />
			[constructor:GlitchPass GlitchPass](  [param:number dt_size]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:number curF] -  The cur f.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:boolean goWild] -  The go wild.<br />
			[property:ShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number randX] -  The rand x.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DataTexture generateHeightmap](  [param:number dt_size] ) <br />
			[method:void generateTrigger](  ) <br />
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GodRaysCombineShader">GodRaysCombineShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GodRaysDepthMaskShader">GodRaysDepthMaskShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GodRaysFakeSunShader">GodRaysFakeSunShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GodRaysGenerateShader">GodRaysGenerateShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GrantSolver">GrantSolver <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:GrantSolver GrantSolver](  [param:SkinnedMesh mesh],  [param:object[] grants] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object[] grants] -  The grants.<br />
			[property:SkinnedMesh mesh] -  The mesh.
		</p>
		<h4>Methods</h4>
		<p>
			[method:GrantSolver addGrantRotation](  [param:Bone bone],  [param:Quaternion q],  [param:number ratio] ) <br />
			[method:GrantSolver update](  ) <br />
			[method:GrantSolver updateOne](  [param:object[] gran] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="GridHelper">GridHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:GridHelper GridHelper](  [param:number size]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]? ) <br />
			[constructor:GridHelper GridHelper](  [param:number size]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:GridHelper GridHelper](  [param:number size]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:GridHelper GridHelper](  [param:number size]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:GridHelper GridHelper](  [param:number size]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:GridHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:GridHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:GridHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:GridHelper clear](  ) - Removes all child objects.<br />
			[method:GridHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:GridHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:GridHelper copy](  [param:GridHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:GridHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:GridHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:GridHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:GridHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:GridHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:GridHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:GridHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setColors](  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]? ) - deprecated - Colors should be specified in the constructor.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:GridHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:GridHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:GridHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:GridHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Group">Group <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Group Group](  ) - The constructor takes no arguments.<br />
			[constructor:Group Group](  ) - The constructor takes no arguments.<br />
			[constructor:Group Group](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isGroup] -  The is group.<br />
			[property:any type] - A string 'Group'. This should not be changed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Group add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Group applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Group attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Group clear](  ) - Removes all child objects.<br />
			[method:Group clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Group copy](  [param:Group source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:Group remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Group removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Group rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Group rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Group rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Group rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Group rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Group translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Group translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Group translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Group translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			This is almost identical to an [page:Object3D Object3D]. Its purpose is to make working with groups of objects syntactically clearer.<br />
			<code data-type="javascript"><br />
			const geometry = new THREE.BoxGeometry( 1, 1, 1 );<br />
			const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );<br />
			const cubeA = new THREE.Mesh( geometry, material );<br />
			cubeA.position.set( 100, 100, 0 );<br />
			const cubeB = new THREE.Mesh( geometry, material );<br />
			cubeB.position.set( -100, -100, 0 );<br />
			// create a group and add the two cubes //These cubes can now be rotated / scaled etc as a group const group = new THREE.Group();<br />
			group.add( cubeA );<br />
			group.add( cubeB );<br />
			scene.add( group );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		<h3 id="Gunzip">Gunzip <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Gunzip Gunzip](  [param:FlateStreamHandler cb]? ) - Creates a GUNZIP stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:FlateStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be GUNZIPped
		</p>

		<p class="desc">
			Streaming GZIP decompression
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Gyroscope">Gyroscope <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Gyroscope Gyroscope](  ) - The constructor takes no arguments.<br />
			[constructor:Gyroscope Gyroscope](  ) - The constructor takes no arguments.<br />
			[constructor:Gyroscope Gyroscope](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Gyroscope add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Gyroscope applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Gyroscope attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Gyroscope clear](  ) - Removes all child objects.<br />
			[method:Gyroscope clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Gyroscope copy](  [param:Gyroscope source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:Gyroscope remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Gyroscope removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Gyroscope rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Gyroscope rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Gyroscope rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Gyroscope rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Gyroscope rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Gyroscope translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Gyroscope translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Gyroscope translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Gyroscope translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Gzip">Gzip <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Gzip Gzip](  [param:GzipOptions opts],  [param:FlateStreamHandler cb]? ) - Creates a GZIP stream<br />
			[constructor:Gzip Gzip](  [param:GzipOptions opts],  [param:FlateStreamHandler cb]?,  [param:FlateStreamHandler cb]? ) - Creates a GZIP stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:FlateStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be GZIPped
		</p>

		<p class="desc">
			Streaming GZIP compression
		</p>

		<hr class="interface-line"/>
		[page:DeflateOptions] &rarr;

		<h3 id="GzipOptions">GzipOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string filename]? - The filename of the data. If the `gunzip` command is used to decompress the data, it will output a file<br />
			with this name instead of the name of the compressed file.<br />
			[property:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' level]? - The level of compression to use, ranging from 0-9.<br />
			0 will store the data without compression.<br />
			1 is fastest but compresses the worst, 9 is slowest but compresses the best.<br />
			The default level is 6.<br />
			<br />
			Typically, binary data benefits much more from higher values than text data.<br />
			In both cases, higher values usually take disproportionately longer than the reduction in final size that results.<br />
			<br />
			For example, a 1 MB text file could:<br />
			- become 1.01 MB with level 0 in 1ms<br />
			- become 400 kB with level 1 in 10ms<br />
			- become 320 kB with level 9 in 100ms<br />
			[property:'0'|'1'|'2'|'3'|'4'|'10'|'5'|'6'|'7'|'8'|'9'|'11'|'12' mem]? - The memory level to use, ranging from 0-12. Increasing this increases speed and compression ratio at the cost of memory.<br />
			Note that this is exponential: while level 0 uses 4 kB, level 4 uses 64 kB, level 8 uses 1 MB, and level 12 uses 16 MB.<br />
			It is recommended not to lower the value below 4, since that tends to hurt performance.<br />
			In addition, values above 8 tend to help very little on most data and can even hurt performance.<br />
			<br />
			The default value is automatically determined based on the size of the input data.<br />
			[property:string|number|Date mtime]? - When the file was last modified. Defaults to the current time.<br />
			Set this to 0 to avoid revealing a modification date entirely.
		</p>

		<p class="desc">
			Options for compressing data into a GZIP format
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="HDRCubeTextureLoader">HDRCubeTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:HDRCubeTextureLoader HDRCubeTextureLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:HDRCubeTextureLoader HDRCubeTextureLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:RGBELoader hdrLoader] -  The hdr loader.<br />
			[property:TextureDataType type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:CubeTexture load](  [param:string[] urls],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:HDRCubeTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:HDRCubeTextureLoader setDataType](  [param:TextureDataType type] ) <br />
			[method:HDRCubeTextureLoader setPath](  [param:string path] ) <br />
			[method:HDRCubeTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:HDRCubeTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:HDRCubeTextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="HTMLMesh">HTMLMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:HTMLMesh HTMLMesh](  [param:HTMLElement dom] ) <br />
			[constructor:HTMLMesh HTMLMesh](  [param:HTMLElement dom],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:HTMLMesh HTMLMesh](  [param:HTMLElement dom],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:HTMLMesh HTMLMesh](  [param:HTMLElement dom],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:HTMLMesh add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:HTMLMesh applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:HTMLMesh attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:HTMLMesh clear](  ) - Removes all child objects.<br />
			[method:HTMLMesh clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:HTMLMesh copy](  [param:HTMLMesh source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:HTMLMesh remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:HTMLMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:HTMLMesh rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:HTMLMesh rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:HTMLMesh rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:HTMLMesh rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:HTMLMesh rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:HTMLMesh translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:HTMLMesh translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:HTMLMesh translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:HTMLMesh translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="HalfEdge">HalfEdge <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:HalfEdge HalfEdge](  [param:VertexNode vertex],  [param:FaceEx face] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:FaceEx face] -  The face.<br />
			[property:HalfEdge next] -  The next.<br />
			[property:HalfEdge prev] -  The prev.<br />
			[property:HalfEdge twin] -  The twin.<br />
			[property:VertexNode vertex] -  The vertex.
		</p>
		<h4>Methods</h4>
		<p>
			[method:VertexNode head](  ) <br />
			[method:number length](  ) <br />
			[method:number lengthSquared](  ) <br />
			[method:HalfEdge setTwin](  [param:HalfEdge edge] ) <br />
			[method:VertexNode tail](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="HalftonePass">HalftonePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:HalftonePass HalftonePass](  [param:number width],  [param:number height],  [param:HalftonePassParameters params] ) <br />
			[constructor:HalftonePass HalftonePass](  [param:number width],  [param:number height],  [param:HalftonePassParameters params] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="HalftonePassParameters">HalftonePassParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number blending]? -  The blending.<br />
			[property:number blendingMode]? -  The blending mode.<br />
			[property:boolean disable]? -  The disable.<br />
			[property:boolean greyscale]? -  The greyscale.<br />
			[property:number radius]? -  The radius.<br />
			[property:number rotateB]? -  The rotate b.<br />
			[property:number rotateG]? -  The rotate g.<br />
			[property:number rotateR]? -  The rotate r.<br />
			[property:number scatter]? -  The scatter.<br />
			[property:number shape]? -  The shape.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="HalftoneShader">HalftoneShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Light] &rarr;

		<h3 id="HemisphereLight">HemisphereLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:HemisphereLight HemisphereLight](  [param:ColorRepresentation skyColor]?,  [param:ColorRepresentation groundColor]?,  [param:number intensity]? ) <br />
			[constructor:HemisphereLight HemisphereLight](  [param:ColorRepresentation skyColor]?,  [param:ColorRepresentation groundColor]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:HemisphereLight HemisphereLight](  [param:ColorRepresentation skyColor]?,  [param:ColorRepresentation groundColor]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:HemisphereLight HemisphereLight](  [param:ColorRepresentation skyColor]?,  [param:ColorRepresentation groundColor]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:Color groundColor] -  The ground color.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isHemisphereLight] -  The is hemisphere light.<br />
			[property:any isLight] -  The is light.<br />
			[property:Vector3 position] -  The position.<br />
			[property:LightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:HemisphereLight add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:HemisphereLight applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:HemisphereLight attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:HemisphereLight clear](  ) - Removes all child objects.<br />
			[method:HemisphereLight clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:HemisphereLight copy](  [param:HemisphereLight source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:HemisphereLight remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:HemisphereLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:HemisphereLight rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:HemisphereLight rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:HemisphereLight rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:HemisphereLight rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:HemisphereLight rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:HemisphereLight translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:HemisphereLight translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:HemisphereLight translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:HemisphereLight translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="HemisphereLightHelper">HemisphereLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:HemisphereLightHelper HemisphereLightHelper](  [param:HemisphereLight light],  [param:number size],  [param:ColorRepresentation color]? ) - The constructor takes no arguments.<br />
			[constructor:HemisphereLightHelper HemisphereLightHelper](  [param:HemisphereLight light],  [param:number size],  [param:ColorRepresentation color]? ) - The constructor takes no arguments.<br />
			[constructor:HemisphereLightHelper HemisphereLightHelper](  [param:HemisphereLight light],  [param:number size],  [param:ColorRepresentation color]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:ColorRepresentation color] -  The color.<br />
			[property:HemisphereLight light] -  The light.<br />
			[property:MeshBasicMaterial material] - The Material<br />
			[property:Matrix4 matrix] - The local transform matrix.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also recalculates the matrixWorld property. Default is [page:Object3D.DefaultMatrixAutoUpdate Object3D.DefaultMatrixAutoUpdate] (true).
		</p>
		<h4>Methods</h4>
		<p>
			[method:HemisphereLightHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:HemisphereLightHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:HemisphereLightHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:HemisphereLightHelper clear](  ) - Removes all child objects.<br />
			[method:HemisphereLightHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:HemisphereLightHelper copy](  [param:HemisphereLightHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:HemisphereLightHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:HemisphereLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:HemisphereLightHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:HemisphereLightHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:HemisphereLightHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:HemisphereLightHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:HemisphereLightHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:HemisphereLightHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:HemisphereLightHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:HemisphereLightHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:HemisphereLightHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Light] &rarr; [page:LightProbe] &rarr;

		<h3 id="HemisphereLightProbe">HemisphereLightProbe <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:HemisphereLightProbe HemisphereLightProbe](  [param:ColorRepresentation skyColor]?,  [param:ColorRepresentation groundColor]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:HemisphereLightProbe HemisphereLightProbe](  [param:ColorRepresentation skyColor]?,  [param:ColorRepresentation groundColor]?,  [param:number intensity]?,  [param:SphericalHarmonics3 sh]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:HemisphereLightProbe HemisphereLightProbe](  [param:ColorRepresentation skyColor]?,  [param:ColorRepresentation groundColor]?,  [param:number intensity]?,  [param:SphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:HemisphereLightProbe HemisphereLightProbe](  [param:ColorRepresentation skyColor]?,  [param:ColorRepresentation groundColor]?,  [param:number intensity]?,  [param:SphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:HemisphereLightProbe HemisphereLightProbe](  [param:ColorRepresentation skyColor]?,  [param:ColorRepresentation groundColor]?,  [param:number intensity]?,  [param:SphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isHemisphereLightProbe] -  The is hemisphere light probe.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isLightProbe] -  The is light probe.<br />
			[property:SphericalHarmonics3 sh] -  The sh.<br />
			[property:LightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:HemisphereLightProbe add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:HemisphereLightProbe applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:HemisphereLightProbe attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:HemisphereLightProbe clear](  ) - Removes all child objects.<br />
			[method:HemisphereLightProbe clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:HemisphereLightProbe copy](  [param:HemisphereLightProbe source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:LightProbe fromJSON](  [param:object json] ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:HemisphereLightProbe remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:HemisphereLightProbe removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:HemisphereLightProbe rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:HemisphereLightProbe rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:HemisphereLightProbe rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:HemisphereLightProbe rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:HemisphereLightProbe rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:HemisphereLightProbe translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:HemisphereLightProbe translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:HemisphereLightProbe translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:HemisphereLightProbe translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="HighlightConfig">HighlightConfig <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number[] ids] -  The ids.<br />
			[property:Material material]? -  The material.<br />
			[property:boolean removePrevious] -  The remove previous.<br />
			[property:Object3D scene] -  The scene.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:HighlightConfig] &rarr;

		<h3 id="HighlightConfigOfModel">HighlightConfigOfModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number[] ids] -  The ids.<br />
			[property:Material material]? -  The material.<br />
			[property:number modelID] -  The model i d.<br />
			[property:boolean removePrevious] -  The remove previous.<br />
			[property:Object3D scene] -  The scene.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="HorizontalBlurShader">HorizontalBlurShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="HorizontalTiltShiftShader">HorizontalTiltShiftShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="HueSaturationShader">HueSaturationShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="IFCLoader">IFCLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFCLoader IFCLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:IFCLoader IFCLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IFCManager ifcManager] -  The ifc manager.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:any url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Promise parse](  [param:ArrayBuffer buffer] ) <br />
			[method:IFCLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IFCLoader setPath](  [param:string path] ) <br />
			[method:IFCLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IFCLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IFCLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IFCManager">IFCManager <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void addModelJSONData](  [param:number modelID],  [param:any data] ) - Adds the properties of a model as JSON data.<br />
			[method:void applyWebIfcConfig](  [param:LoaderSettings settings] ) - Applies a configuration for [link:https://ifcjs.github.io/info/docs/Guide/web-ifc/Introduction web-ifc].<br />
			[method:void close](  [param:number modelID],  [param:Scene scene]? ) - Closes the specified model and deletes it from the [link:https://threejs.org/docs/#api/en/scenes/Scene scene].<br />
			[method:void|Mesh createSubset](  [param:HighlightConfigOfModel config] ) - Creates a new geometric subset.<br />
			[method:void disposeMemory](  ) - Completely releases the WASM memory, thus drastically decreasing the memory use of the app.<br />
			Only use this in the following scenarios:<br />
			- If you don't need to access the properties of the IFC<br />
			- If you will provide the properties as JSON.<br />
			[method:any[] getAllItemsOfType](  [param:number modelID],  [param:number type],  [param:boolean verbose] ) - Returns all items of the specified type. You can import<br />
			the types from *web-ifc*.<br />
			Example to get all the standard walls of a project:<br />
			<code data-type="text">js<br />
			import { IFCWALLSTANDARDCASE } from 'web-ifc';<br />
			const walls = ifcLoader.getAllItemsOfType(IFCWALLSTANDARDCASE) : this;<br />
			</code><br />
			[method:number getExpressId](  [param:BufferGeometry geometry],  [param:number faceIndex] ) - Gets the **Express ID** to which the given face belongs.<br />
			This ID uniquely identifies this entity within this IFC file.<br />
			[method:string getIfcType](  [param:number modelID],  [param:number id] ) - Gets the ifc type of the specified item.<br />
			[method:any getItemProperties](  [param:number modelID],  [param:number id],  [param:boolean recursive]? ) - Gets the native properties of the given element.<br />
			[method:any[] getMaterialsProperties](  [param:number modelID],  [param:number id],  [param:boolean recursive]? ) - Gets the materials assigned to the given element.<br />
			[method:any[] getPropertySets](  [param:number modelID],  [param:number id],  [param:boolean recursive]? ) - Gets the [link:https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifckernel/lexical/ifcpropertyset.htm property sets]<br />
			assigned to the given element.<br />
			[method:void getSpatialStructure](  [param:number modelID] ) - Gets the spatial structure of the project. The<br />
			[link:https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifcproductextension/lexical/ifcspatialstructureelement.htm spatial structure]<br />
			is the hierarchical structure that organizes every IFC project (all physical items<br />
			are referenced to an element of the spatial structure). It is formed by<br />
			one IfcProject that contains one or more IfcSites, that contain one or more<br />
			IfcBuildings, that contain one or more IfcBuildingStoreys, that contain<br />
			one or more IfcSpaces.<br />
			[method:Mesh getSubset](  [param:number modelID],  [param:Material material]? ) - Gets the mesh of the subset with the specified [link:https://threejs.org/docs/#api/en/materials/Material material].<br />
			If no material is given, this returns the subset with the original materials.<br />
			[method:any[] getTypeProperties](  [param:number modelID],  [param:number id],  [param:boolean recursive]? ) - Gets the properties of the type assigned to the element.<br />
			For example, if applied to a wall (IfcWall), this would get back the information<br />
			contained in the IfcWallType assigned to it, if any.<br />
			[method:void hideAllItems](  [param:number modelID] ) - Hides all the items of the specified model<br />
			[method:void hideItems](  [param:number modelID],  [param:number[] ids] ) - Hides the selected items in the specified model<br />
			[method:Promise parse](  [param:ArrayBuffer buffer] ) <br />
			[method:void removeSubset](  [param:number modelID],  [param:Object3D parent]?,  [param:Material material]? ) - Removes the specified subset.<br />
			[method:void setWasmPath](  [param:string path] ) - Sets the relative path of web-ifc.wasm file in the project.<br />
			Beware: you **must** serve this file in your page; this means<br />
			that you have to copy this files from *node_modules/web-ifc*<br />
			to your deployment directory.<br />
			If you don't use this methods,<br />
			IFC.js assumes that you are serving it in the root directory.<br />
			<br />
			Example if web-ifc.wasm is in dist/wasmDir:<br />
			`ifcLoader.setWasmPath("dist/wasmDir/") : this;`<br />
			[method:void setupThreeMeshBVH](  [param:any computeBoundsTree],  [param:any disposeBoundsTree],  [param:any acceleratedRaycast] ) - Makes object picking a lot faster<br />
			Courtesy of gkjohnson's [link:https://github.com/gkjohnson/three-mesh-bvh work].<br />
			Import these objects from his library and pass them as arguments. IFC.js takes care of the rest!<br />
			[method:void showAllItems](  [param:number modelID] ) - Shows all the items of the specified model<br />
			[method:void showItems](  [param:number modelID],  [param:number[] ids] ) - Shows all the items of the specified model<br />
			[method:void useJSONData](  [param:boolean useJSON]? ) - Enables the JSON mode (which consumes way less memory) and eliminates the WASM data.<br />
			Only use this in the following scenarios:<br />
			- If you don't need to access the properties of the IFC<br />
			- If you will provide the properties as JSON.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="IFCModel">IFCModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFCModel IFCModel](  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:IFCModel IFCModel](  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:IFCModel IFCModel](  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:IFCManager ifcManager] -  The ifc manager.<br />
			[property:number modelID] -  The model i d.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IFCModel add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:IFCModel applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:IFCModel attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:IFCModel clear](  ) - Removes all child objects.<br />
			[method:IFCModel clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:void close](  [param:Scene scene]? ) - deprecated - Use `IfcModel.ifcManager.close` instead.<br />
			<br />
			Closes the specified model and deletes it from the [link:https://threejs.org/docs/#api/en/scenes/Scene scene].<br />
			[method:IFCModel copy](  [param:IFCModel source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void|Mesh createSubset](  [param:HighlightConfig config] ) - deprecated - Use `IfcModel.ifcManager.createSubset` instead.<br />
			<br />
			Creates a new geometric subset.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:any[] getAllItemsOfType](  [param:number type],  [param:boolean verbose] ) - deprecated - Use `IfcModel.ifcManager.getAllItemsOfType` instead.<br />
			<br />
			Returns all items of the specified type. You can import<br />
			the types from *web-ifc*.<br />
			<br />
			Example to get all the standard walls of a project:<br />
			```js<br />
			import { IFCWALLSTANDARDCASE } from 'web-ifc';<br />
			const walls = ifcLoader.getAllItemsOfType(IFCWALLSTANDARDCASE) : this;<br />
			```<br />
			[method:number getExpressId](  [param:BufferGeometry geometry],  [param:number faceIndex] ) - deprecated - Use `IfcModel.ifcManager.getExpressId` instead.<br />
			<br />
			Gets the **Express ID** to which the given face belongs.<br />
			This ID uniquely identifies this entity within this IFC file.<br />
			[method:string getIfcType](  [param:number id] ) - deprecated - Use `IfcModel.ifcManager.getIfcType` instead.<br />
			<br />
			Gets the ifc type of the specified item.<br />
			[method:any getItemProperties](  [param:number id],  [param:boolean recursive]? ) - deprecated - Use `IfcModel.ifcManager.getItemProperties` instead.<br />
			<br />
			Gets the native properties of the given element.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:any[] getPropertySets](  [param:number id],  [param:boolean recursive]? ) - deprecated - Use `IfcModel.ifcManager.getPropertySets` instead.<br />
			<br />
			Gets the [link:https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifckernel/lexical/ifcpropertyset.htm property sets]<br />
			assigned to the given element.<br />
			[method:void getSpatialStructure](  ) - deprecated - Use `IfcModel.ifcManager.getSpatialStructure` instead.<br />
			<br />
			Gets the spatial structure of the project. The<br />
			[link:https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifcproductextension/lexical/ifcspatialstructureelement.htm spatial structure]<br />
			is the hierarchical structure that organizes every IFC project (all physical items<br />
			are referenced to an element of the spatial structure). It is formed by<br />
			one IfcProject that contains one or more IfcSites, that contain one or more<br />
			IfcBuildings, that contain one or more IfcBuildingStoreys, that contain<br />
			one or more IfcSpaces.<br />
			[method:Mesh getSubset](  [param:Material material]? ) - deprecated - Use `IfcModel.ifcManager.getSubset` instead.<br />
			<br />
			Gets the mesh of the subset with the specified [link:https://threejs.org/docs/#api/en/materials/Material material].<br />
			If no material is given, this returns the subset with the original materials.<br />
			[method:any[] getTypeProperties](  [param:number id],  [param:boolean recursive]? ) - deprecated - Use `IfcModel.ifcManager.getTypeProperties` instead.<br />
			<br />
			Gets the properties of the type assigned to the element.<br />
			For example, if applied to a wall (IfcWall), this would get back the information<br />
			contained in the IfcWallType assigned to it, if any.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void hideAllItems](  ) - deprecated - Use `IfcModel.ifcManager.hideAllItems` instead.<br />
			<br />
			Hides all the items of the specified model<br />
			[method:void hideItems](  [param:number[] ids] ) - deprecated - Use `IfcModel.ifcManager.hideItems` instead.<br />
			<br />
			Hides the selected items in the specified model<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:IFCModel remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:IFCModel removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:void removeSubset](  [param:Object3D parent]?,  [param:Material material]? ) - deprecated - Use `IfcModel.ifcManager.removeSubset` instead.<br />
			<br />
			Removes the specified subset.<br />
			[method:IFCModel rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IFCModel rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:IFCModel rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:IFCModel rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:IFCModel rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setIFCManager](  [param:IFCManager manager] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:void setWasmPath](  [param:string path] ) - deprecated - Use `IfcModel.ifcManager.setWasmPath` instead.<br />
			<br />
			Sets the relative path of web-ifc.wasm file in the project.<br />
			Beware: you **must** serve this file in your page; this means<br />
			that you have to copy this files from *node_modules/web-ifc*<br />
			to your deployment directory.<br />
			<br />
			If you don't use this methods,<br />
			IFC.js assumes that you are serving it in the root directory.<br />
			<br />
			Example if web-ifc.wasm is in dist/wasmDir:<br />
			`ifcLoader.setWasmPath("dist/wasmDir/") : this;`<br />
			[method:void showAllItems](  ) - deprecated - Use `IfcModel.ifcManager.showAllItems` instead.<br />
			<br />
			Shows all the items of the specified model<br />
			[method:void showItems](  [param:number[] ids] ) - deprecated - Use `IfcModel.ifcManager.showItems` instead.<br />
			<br />
			Hides all the items of the specified model<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IFCModel translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IFCModel translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:IFCModel translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:IFCModel translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			Represents an IFC model. This object is returned by the `IFCLoader` after loading an IFC.
		</p>

		<hr class="interface-line"/>
		<h3 id="IUniform">IUniform <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:TValue value] -  The value.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:PolyhedronGeometry] &rarr;

		<h3 id="IcosahedronBufferGeometry">IcosahedronBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IcosahedronGeometry IcosahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IcosahedronGeometry IcosahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IcosahedronGeometry IcosahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:IcosahedronGeometry IcosahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IcosahedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:IcosahedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:PolyhedronGeometry] &rarr;

		<h3 id="IcosahedronGeometry">IcosahedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IcosahedronGeometry IcosahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IcosahedronGeometry IcosahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IcosahedronGeometry IcosahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:IcosahedronGeometry IcosahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IcosahedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:IcosahedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IfcAPI">IfcAPI <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any fs] -  The fs.<br />
			[property:any wasmModule] -  The wasm module.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void CloseModel](  [param:number modelID] ) - Closes a model and frees all related memory<br />
			[method:number CreateModel](  [param:LoaderSettings settings]? ) - Creates a new model and returns a modelID number<br />
			[method:Uint8Array ExportFileAsIFC](  [param:number modelID] ) <br />
			[method:void FlattenLine](  [param:number modelID],  [param:any line] ) <br />
			[method:VectorEx GetAllLines](  [param:number modelID] ) <br />
			[method:FlatMesh GetFlatMesh](  [param:number modelID],  [param:number expressID] ) - Load geometry for a single element<br />
			[method:IfcGeometry GetGeometry](  [param:number modelID],  [param:number geometryExpressID] ) - Opens a model and returns a modelID number<br />
			[method:Uint32Array GetIndexArray](  [param:number ptr],  [param:number size] ) <br />
			[method:any GetLine](  [param:number modelID],  [param:number expressID],  [param:boolean flatten]? ) <br />
			[method:VectorEx GetLineIDsWithType](  [param:number modelID],  [param:number type] ) <br />
			[method:RawLineData GetRawLineData](  [param:number modelID],  [param:number expressID] ) <br />
			[method:Float32Array GetVertexArray](  [param:number ptr],  [param:number size] ) <br />
			[method:Promise Init](  ) - Initializes the WASM module (WebIFCWasm), required before using any other functionality<br />
			[method:boolean IsModelOpen](  [param:number modelID] ) - Checks if a specific model ID is open or closed<br />
			[method:VectorEx LoadAllGeometry](  [param:number modelID] ) - Load all geometry in a model<br />
			[method:number OpenModel](  [param:string|Uint8Array data],  [param:LoaderSettings settings]? ) - Opens a model and returns a modelID number<br />
			[method:void SetGeometryTransformation](  [param:number modelID],  [param:number[] transformationMatrix] ) <br />
			[method:void SetWasmPath](  [param:string path] ) <br />
			[method:void StreamAllMeshes](  [param:number modelID],  [param:any meshCallback] ) <br />
			[method:void WriteLine](  [param:number modelID],  [param:any lineObject] ) <br />
			[method:any WriteRawLineData](  [param:number modelID],  [param:RawLineData data] ) <br />
			[method:any getSubArray](  [param:any heap],  [param:any startPtr],  [param:any sizeBytes] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IfcGeometry">IfcGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:number GetIndexData](  ) <br />
			[method:number GetIndexDataSize](  ) <br />
			[method:number GetVertexData](  ) <br />
			[method:number GetVertexDataSize](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="IfcMesh">IfcMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IfcMesh IfcMesh](  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:IfcMesh IfcMesh](  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:IfcMesh IfcMesh](  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number modelID] -  The model i d.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IfcMesh add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:IfcMesh applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:IfcMesh attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:IfcMesh clear](  ) - Removes all child objects.<br />
			[method:IfcMesh clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:IfcMesh copy](  [param:IfcMesh source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:IfcMesh remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:IfcMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IfcMesh rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IfcMesh rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:IfcMesh rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:IfcMesh rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:IfcMesh rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IfcMesh translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IfcMesh translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:IfcMesh translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:IfcMesh translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IfcModel">IfcModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:GeometriesByMaterials items] -  The items.<br />
			[property:any jsonData] -  The json data.<br />
			[property:IfcMesh mesh] -  The mesh.<br />
			[property:number modelID] -  The model i d.<br />
			[property:TypesMap types] -  The types.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IfcState">IfcState <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IfcAPI api] -  The api.<br />
			[property:any models] -  The models.<br />
			[property:boolean useJSON] -  The use j s o n.<br />
			[property:LoaderSettings webIfcSettings]? -  The web ifc settings.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="ImageBitmapLoader">ImageBitmapLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ImageBitmapLoader ImageBitmapLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:ImageBitmapLoader ImageBitmapLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:any isImageBitmapLoader] -  The is image bitmap loader.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:object options] -  The options.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ImageBitmapLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ImageBitmapLoader setOptions](  [param:object options] ) <br />
			[method:ImageBitmapLoader setPath](  [param:string path] ) <br />
			[method:ImageBitmapLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ImageBitmapLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ImageBitmapLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="ImageLoader">ImageLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ImageLoader ImageLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:ImageLoader ImageLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:HTMLImageElement load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ImageLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ImageLoader setPath](  [param:string path] ) <br />
			[method:ImageLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ImageLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ImageLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			A loader for loading an image.<br />
			Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
		</p>

		<hr class="interface-line"/>
		<h3 id="ImageUtils">ImageUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] - deprecated -
		</p>
		<h4>Methods</h4>
		<p>
			[method:string getDataURL](  [param:any image] ) <br />
			[method:Texture loadTexture](  [param:string url],  [param:Mapping mapping]?,  [param:any onLoad]?,  [param:any onError]? ) - deprecated - Use {@link TextureLoader THREE.TextureLoader()} instead.<br />
			[method:Texture loadTextureCube](  [param:string[] array],  [param:Mapping mapping]?,  [param:any onLoad]?,  [param:any onError]? ) - deprecated - Use {@link CubeTextureLoader THREE.CubeTextureLoader()} instead.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ImprovedNoise">ImprovedNoise <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ImprovedNoise ImprovedNoise](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:number noise](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Inflate">Inflate <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Inflate Inflate](  [param:FlateStreamHandler cb]? ) - Creates an inflation stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:FlateStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be inflated
		</p>

		<p class="desc">
			Streaming DEFLATE decompression
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="InputNode">InputNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:InputNode InputNode](  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:InputNode InputNode](  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:InputNode InputNode](  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:InputNode copy](  [param:InputNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:InputNode setLabel](  [param:string name] ) <br />
			[method:InputNode setName](  [param:string name] ) <br />
			[method:InputNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="InstancedBufferAttribute">InstancedBufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:InstancedBufferAttribute InstancedBufferAttribute](  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number meshPerAttribute]? ) - Returns : aaa<br />
			[constructor:InstancedBufferAttribute InstancedBufferAttribute](  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number meshPerAttribute]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:number meshPerAttribute] - Defines how often a value of this buffer attribute should be repeated. A value of one means that each value of the instanced attribute is used for a single instance. A value of two means that each value is used for two consecutive instances (and so on). Default is *1*.<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:InstancedBufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:InstancedBufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:InstancedBufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:InstancedBufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:InstancedBufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:InstancedBufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:InstancedBufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:InstancedBufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:InstancedBufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:InstancedBufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:InstancedBufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:InstancedBufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:InstancedBufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:InstancedBufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:InstancedBufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:InstancedBufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:InstancedBufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:InstancedBufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:InstancedBufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:InstancedBufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:InstancedBufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:InstancedBufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			An instanced version of [page:BufferAttribute BufferAttribute].
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="InstancedBufferGeometry">InstancedBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:InstancedBufferGeometry InstancedBufferGeometry](  ) <br />
			[constructor:InstancedBufferGeometry InstancedBufferGeometry](  ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:InstancedBufferGeometry InstancedBufferGeometry](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number MaxIndex] -  The max index.<br />
			[property:any attributes] - This hashmap has as id the name of the attribute to be set and as value the [page:BufferAttribute buffer] to set it to.<br />
			Rather than accessing this property directly, use *.setAttribute* and *.getAttribute* to access attributes of this geometry.<br />
			[property:Box3 boundingBox] - Bounding box for the bufferGeometry, which can be calculated with *.computeBoundingBox*(). Default is *null*.<br />
			[property:Sphere boundingSphere] - Bounding sphere for the bufferGeometry, which can be calculated with *.computeBoundingSphere*(). Default is *null*.<br />
			[property:any drawRange] - Determines the part of the geometry to render. This should not be set directly, instead use *.setDrawRange*. Default is { start: 0, count: Infinity }<br />
			For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[property:any drawcalls] - deprecated - Use {@link BufferGeometry#groups .groups} instead.<br />
			[property:any groups] - Split the geometry into groups, each of which will be rendered in a separate WebGL draw call.<br />
			This allows an array of materials to be used with the bufferGeometry.<br />
			Each group is an object of the form: { start: Integer, count: Integer, materialIndex: Integer }<br />
			where start specifies the first element in this draw call  the first vertex for non-indexed geometry, otherwise the first triangle index. Count specifies how many vertices (or indices) are included, and materialIndex specifies the material array index to use.<br />
			Use *.addGroup* to add groups, rather than modifying this array directly.<br />
			[property:number id] - Unique number for this bufferGeometry instance.<br />
			[property:BufferAttribute index] - Allows for vertices to be re-used across multiple triangles; this is called using "indexed triangles".<br />
			Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face.<br />
			If this attribute is not set, the [page:WebGLRenderer renderer] assumes that each three contiguous positions represent a single triangle.<br />
			Default is *null*.<br />
			[property:number instanceCount] - Default is *Infinity*.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:boolean isInstancedBufferGeometry] -  The is instanced buffer geometry.<br />
			[property:any morphAttributes] - Hashmap of [page:BufferAttribute BufferAttribute]s holding details of the geometry's morph targets.<br />
			[property:boolean morphTargetsRelative] - Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals.<br />
			Default is *false*.<br />
			[property:string name] - Optional name for this bufferGeometry instance. Default is an empty string.<br />
			[property:any offsets] - deprecated - Use {@link BufferGeometry#groups .groups} instead.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the BufferGeometry. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - [link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID] of this object instance.<br />
			This gets automatically assigned and shouldn't be edited.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number instances] ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:InstancedBufferGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			An instanced version of [page:BufferGeometry BufferGeometry].
		</p>

		<hr class="interface-line"/>
		[page:Flow] &rarr;

		<h3 id="InstancedFlow">InstancedFlow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:InstancedFlow InstancedFlow](  [param:number count],  [param:number curveCount],  [param:BufferGeometry geometry],  [param:Material material] ) <br />
			[constructor:InstancedFlow InstancedFlow](  [param:number count],  [param:number curveCount],  [param:BufferGeometry geometry],  [param:Material material],  [param:Mesh mesh],  [param:number numberOfCurves]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] curveArray] -  The curve array.<br />
			[property:number[] curveLengthArray] -  The curve length array.<br />
			[property:InstancedMesh object3D] -  The object3 d.<br />
			[property:number[] offsets] -  The offsets.<br />
			[property:DataTexture splineTexure] -  The spline texure.<br />
			[property:SplineUniform uniforms] -  The uniforms.<br />
			[property:number[] whichCurve] -  The which curve.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void moveAlongCurve](  [param:number amount] ) <br />
			[method:void moveIndividualAlongCurve](  [param:number index],  [param:number offset] ) <br />
			[method:void setCurve](  [param:number index],  [param:number curveNo] ) <br />
			[method:void updateCurve](  [param:number index],  [param:Curve curve] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:InterleavedBuffer] &rarr;

		<h3 id="InstancedInterleavedBuffer">InstancedInterleavedBuffer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:InstancedInterleavedBuffer InstancedInterleavedBuffer](  [param:ArrayLike array],  [param:number stride],  [param:number meshPerAttribute]? ) - Returns : aaa<br />
			[constructor:InstancedInterleavedBuffer InstancedInterleavedBuffer](  [param:ArrayLike array],  [param:number stride],  [param:number meshPerAttribute]?,  [param:ArrayLike array],  [param:number stride] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - A typed array with a shared buffer. Stores the geometry data.<br />
			[property:number count] - Gives the total number of elements in the array.<br />
			[property:number length] -  The length.<br />
			[property:number meshPerAttribute] - Default is *1*.<br />
			[property:boolean needsUpdate] - Default is *false*. Setting this to true increments [page:InterleavedBuffer.version version].<br />
			[property:number stride] - The number of typed-array elements per vertex.<br />
			[property:any updateRange] - Object containing offset and count.<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			[property:string uuid] - [link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID] of this instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - A version number, incremented every time the needsUpdate property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:InterleavedBuffer clone](  [param:object data] ) - data - This object holds shared array buffers required for properly cloning geometries with interleaved attributes.<br />
			Creates a clone of this [name].<br />
			[method:InstancedInterleavedBuffer copy](  [param:InterleavedBuffer source] ) - Copies another [name] to this [name].<br />
			[method:InterleavedBuffer copyAt](  [param:number index1],  [param:InterleavedBufferAttribute attribute],  [param:number index2] ) - Copies data from attribute[index2] to [page:InterleavedBuffer.array array][index1].<br />
			[method:InterleavedBuffer set](  [param:ArrayLike value],  [param:number index] ) - value - The source (typed) array.<br />
			offset - The offset into the target array at which to begin writing values from the source array. Default is *0*.<br />
			Stores multiple values in the buffer, reading input values from a specified array.<br />
			[method:InterleavedBuffer setUsage](  [param:Usage usage] ) - Set [page:InterleavedBuffer.usage usage] to value.<br />
			[method:void toJSON](  [param:object data] ) - data - This object holds shared array buffers required for properly serializing geometries with interleaved attributes.<br />
			Serializes this [name].
		</p>

		<p class="desc">
			An instanced version of [page:InterleavedBuffer InterleavedBuffer].
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="InstancedMesh">InstancedMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:InstancedMesh InstancedMesh](  [param:TGeometry geometry],  [param:TMaterial material],  [param:number count] ) <br />
			[constructor:InstancedMesh InstancedMesh](  [param:TGeometry geometry],  [param:TMaterial material],  [param:number count],  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:InstancedMesh InstancedMesh](  [param:TGeometry geometry],  [param:TMaterial material],  [param:number count],  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - The constructor takes no arguments.<br />
			[constructor:InstancedMesh InstancedMesh](  [param:TGeometry geometry],  [param:TMaterial material],  [param:number count],  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number count] -  The count.<br />
			[property:TGeometry geometry] - An instance of [page:BufferGeometry BufferGeometry] (or derived classes), defining the object's structure.<br />
			[property:InstancedBufferAttribute instanceColor] - Represents the colors of all instances. *null* by default.<br />
			You have to set its [page:BufferAttribute.needsUpdate needsUpdate] flag to true if you modify instanced data via *.setColorAt*().<br />
			[property:InstancedBufferAttribute instanceMatrix] - Represents the local transformation of all instances.<br />
			You have to set its [page:BufferAttribute.needsUpdate needsUpdate] flag to true if you modify instanced data via *.setMatrixAt*().<br />
			[property:any isInstancedMesh] -  The is instanced mesh.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:TMaterial material] - An instance of material derived from the [page:Material Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial MeshBasicMaterial].<br />
			[property:any morphTargetDictionary]? - A dictionary of morphTargets based on the morphTarget.name property.<br />
			Undefined by default, but rebuilt [page:Mesh.updateMorphTargets updateMorphTargets].<br />
			[property:number[] morphTargetInfluences]? - An array of weights typically from 0-1 that specify how much of the morph is applied.<br />
			Undefined by default, but reset to a blank array by [page:Mesh.updateMorphTargets updateMorphTargets].<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:InstancedMesh add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:InstancedMesh applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:InstancedMesh attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:InstancedMesh clear](  ) - Removes all child objects.<br />
			[method:InstancedMesh clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:InstancedMesh copy](  [param:InstancedMesh source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Frees the internal resources of this instance.<br />
			[method:void getColorAt](  [param:number index],  [param:Color color] ) - Get the color of the defined instance.<br />
			[page:Integer index]: The index of an instance. Values have to be in the range [0, count].<br />
			[page:Color color]: This color object will be set to the color of the defined instance.<br />
			[method:void getMatrixAt](  [param:number index],  [param:Matrix4 matrix] ) - Get the local transformation matrix of the defined instance.<br />
			[page:Integer index]: The index of an instance. Values have to be in the range [0, count].<br />
			[page:Matrix4 matrix]: This 4x4 matrix will be set to the local transformation matrix of the defined instance.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:InstancedMesh remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:InstancedMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:InstancedMesh rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:InstancedMesh rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:InstancedMesh rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:InstancedMesh rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:InstancedMesh rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setColorAt](  [param:number index],  [param:Color color] ) - Sets the given color to the defined instance.<br />
			Make sure you set *.instanceColor*[page:BufferAttribute.needsUpdate .needsUpdate] to true after updating all the colors.<br />
			[page:Integer index]: The index of an instance. Values have to be in the range [0, count].<br />
			[page:Color color]: The color of a single instance.<br />
			[method:void setMatrixAt](  [param:number index],  [param:Matrix4 matrix] ) - Sets the given local transformation matrix to the defined instance.<br />
			Make sure you set *.instanceMatrix*[page:BufferAttribute.needsUpdate .needsUpdate] to true after updating all the matrices.<br />
			[page:Integer index]: The index of an instance. Values have to be in the range [0, count].<br />
			[page:Matrix4 matrix]: A 4x4 matrix representing the local transformation of a single instance.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:InstancedMesh translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:InstancedMesh translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:InstancedMesh translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:InstancedMesh translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			A special version of [Mesh](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Mesh) with instanced rendering support. Use [name] if you have to render a large number of objects with the same geometry and material but with different world transformations. The usage of [name] will help you to reduce the number of draw calls and thus improve the overall rendering performance in your application.<br />
			[example:webgl_instancing_dynamic WebGL / instancing / dynamic]<br />
			[example:webgl_instancing_modified WebGL / instancing / modified]<br />
			[example:webgl_instancing_performance WebGL / instancing / performance]<br />
			[example:webgl_instancing_scatter WebGL / instancing / scatter]<br />
			[example:webgl_instancing_raycast WebGL / instancing / raycast]
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Int16Attribute">Int16Attribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Int16Attribute Int16Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Int16Attribute Int16Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Int16Attribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int16Attribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int16Attribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int16Attribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Int16Attribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Int16Attribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Int16Attribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Int16Attribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Int16Attribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Int16Attribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Int16Attribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Int16Attribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Int16Attribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Int16Attribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Int16Attribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Int16Attribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Int16Attribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Int16Attribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Int16Attribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Int16Attribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Int16Attribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Int16Attribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			deprecated - THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Int16BufferAttribute">Int16BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Int16BufferAttribute Int16BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Int16BufferAttribute Int16BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Int16BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int16BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int16BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int16BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Int16BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Int16BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Int16BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Int16BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Int16BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Int16BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Int16BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Int16BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Int16BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Int16BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Int16BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Int16BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Int16BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Int16BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Int16BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Int16BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Int16BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Int16BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Int16 buffer attribute
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Int32Attribute">Int32Attribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Int32Attribute Int32Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Int32Attribute Int32Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Int32Attribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int32Attribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int32Attribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int32Attribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Int32Attribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Int32Attribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Int32Attribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Int32Attribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Int32Attribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Int32Attribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Int32Attribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Int32Attribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Int32Attribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Int32Attribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Int32Attribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Int32Attribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Int32Attribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Int32Attribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Int32Attribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Int32Attribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Int32Attribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Int32Attribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			deprecated - THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Int32BufferAttribute">Int32BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Int32BufferAttribute Int32BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Int32BufferAttribute Int32BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Int32BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int32BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int32BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int32BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Int32BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Int32BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Int32BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Int32BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Int32BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Int32BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Int32BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Int32BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Int32BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Int32BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Int32BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Int32BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Int32BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Int32BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Int32BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Int32BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Int32BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Int32BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Int32 buffer attribute
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Int8Attribute">Int8Attribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Int8Attribute Int8Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Int8Attribute Int8Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Int8Attribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int8Attribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int8Attribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int8Attribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Int8Attribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Int8Attribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Int8Attribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Int8Attribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Int8Attribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Int8Attribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Int8Attribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Int8Attribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Int8Attribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Int8Attribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Int8Attribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Int8Attribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Int8Attribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Int8Attribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Int8Attribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Int8Attribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Int8Attribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Int8Attribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			deprecated - THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Int8BufferAttribute">Int8BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Int8BufferAttribute Int8BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Int8BufferAttribute Int8BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Int8BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int8BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int8BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Int8BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Int8BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Int8BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Int8BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Int8BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Int8BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Int8BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Int8BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Int8BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Int8BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Int8BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Int8BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Int8BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Int8BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Int8BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Int8BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Int8BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Int8BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Int8BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Int8 buffer attribute
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="IntNode">IntNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IntNode IntNode](  [param:number value]? ) <br />
			[constructor:IntNode IntNode](  [param:number value]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:IntNode IntNode](  [param:number value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:IntNode IntNode](  [param:number value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IntNode copy](  [param:IntNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IntNode setLabel](  [param:string name] ) <br />
			[method:IntNode setName](  [param:string name] ) <br />
			[method:IntNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Group] &rarr;

		<h3 id="InteractiveGroup">InteractiveGroup <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:InteractiveGroup InteractiveGroup](  [param:WebGLRenderer renderer],  [param:Camera camera] ) - The constructor takes no arguments.<br />
			[constructor:InteractiveGroup InteractiveGroup](  [param:WebGLRenderer renderer],  [param:Camera camera] ) - The constructor takes no arguments.<br />
			[constructor:InteractiveGroup InteractiveGroup](  [param:WebGLRenderer renderer],  [param:Camera camera] ) - The constructor takes no arguments.<br />
			[constructor:InteractiveGroup InteractiveGroup](  [param:WebGLRenderer renderer],  [param:Camera camera] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:InteractiveGroup add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:InteractiveGroup applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:InteractiveGroup attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:InteractiveGroup clear](  ) - Removes all child objects.<br />
			[method:InteractiveGroup clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:InteractiveGroup copy](  [param:InteractiveGroup source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:InteractiveGroup remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:InteractiveGroup removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:InteractiveGroup rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:InteractiveGroup rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:InteractiveGroup rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:InteractiveGroup rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:InteractiveGroup rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:InteractiveGroup translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:InteractiveGroup translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:InteractiveGroup translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:InteractiveGroup translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="InterleavedBuffer">InterleavedBuffer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:InterleavedBuffer InterleavedBuffer](  [param:ArrayLike array],  [param:number stride] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - A typed array with a shared buffer. Stores the geometry data.<br />
			[property:number count] - Gives the total number of elements in the array.<br />
			[property:number length] -  The length.<br />
			[property:boolean needsUpdate] - Default is *false*. Setting this to true increments [page:InterleavedBuffer.version version].<br />
			[property:number stride] - The number of typed-array elements per vertex.<br />
			[property:any updateRange] - Object containing offset and count.<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			[property:string uuid] - [link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID] of this instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - A version number, incremented every time the needsUpdate property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:InterleavedBuffer clone](  [param:object data] ) - data - This object holds shared array buffers required for properly cloning geometries with interleaved attributes.<br />
			Creates a clone of this [name].<br />
			[method:InterleavedBuffer copy](  [param:InterleavedBuffer source] ) - Copies another [name] to this [name].<br />
			[method:InterleavedBuffer copyAt](  [param:number index1],  [param:InterleavedBufferAttribute attribute],  [param:number index2] ) - Copies data from attribute[index2] to [page:InterleavedBuffer.array array][index1].<br />
			[method:InterleavedBuffer set](  [param:ArrayLike value],  [param:number index] ) - value - The source (typed) array.<br />
			offset - The offset into the target array at which to begin writing values from the source array. Default is *0*.<br />
			Stores multiple values in the buffer, reading input values from a specified array.<br />
			[method:InterleavedBuffer setUsage](  [param:Usage usage] ) - Set [page:InterleavedBuffer.usage usage] to value.<br />
			[method:void toJSON](  [param:object data] ) - data - This object holds shared array buffers required for properly serializing geometries with interleaved attributes.<br />
			Serializes this [name].
		</p>

		<p class="desc">
			"Interleaved" means that multiple attributes, possibly of different types, (e.g., position, normal, uv, color) are packed into a single array buffer.<br />
			An introduction into interleaved arrays can be found here: [Interleaved array basics](https://blog.tojicode.com/2011/05/interleaved-array-basics.html)<br />
			[example:webgl_buffergeometry_points_interleaved webgl / buffergeometry / points / interleaved]
		</p>

		<hr class="interface-line"/>
		<h3 id="InterleavedBufferAttribute">InterleavedBufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:InterleavedBufferAttribute InterleavedBufferAttribute](  [param:InterleavedBuffer interleavedBuffer],  [param:number itemSize],  [param:number offset],  [param:boolean normalized]? ) - Returns : aaa
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterleavedBuffer data] - The [page:InterleavedBuffer InterleavedBuffer] instance passed in the constructor.<br />
			[property:any isInterleavedBufferAttribute] -  The is interleaved buffer attribute.<br />
			[property:number itemSize] - How many values make up each item.<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Default is *false*.<br />
			[property:number offset] - The offset in the underlying array buffer where an item starts.
		</p>
		<h4>Methods</h4>
		<p>
			[method:InterleavedBufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this InterleavedBufferAttribute.<br />
			[method:InterleavedBufferAttribute applyNormalMatrix](  [param:Matrix matrix] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this InterleavedBufferAttribute.<br />
			[method:BufferAttribute clone](  [param:object data]? ) <br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the item at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the item at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the item at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the item at the given index.<br />
			[method:InterleavedBufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the item at the given index.<br />
			[method:InterleavedBufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the item at the given index.<br />
			[method:InterleavedBufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the item at the given index.<br />
			[method:InterleavedBufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the item at the given index.<br />
			[method:InterleavedBufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the item at the given index.<br />
			[method:InterleavedBufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the item at the given index.<br />
			[method:InterleavedBufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the item at the given index.<br />
			[method:void toJSON](  [param:object data]? ) <br />
			[method:InterleavedBufferAttribute transformDirection](  [param:Matrix matrix] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this InterleavedBufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			see {@link https://github.com/mrdoob/three.js/blob/master/src/core/InterleavedBufferAttribute.js|src/core/InterleavedBufferAttribute.js}
		</p>

		<hr class="interface-line"/>
		<h3 id="Interpolant">Interpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Interpolant Interpolant](  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) - Note: This is not designed to be called directly.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] - array of positions<br />
			[property:any resultBuffer] - buffer to store the interpolation results.<br />
			[property:any sampleValues] - array of samples<br />
			[property:number valueSize] - number of samples
		</p>
		<h4>Methods</h4>
		<p>
			[method:any evaluate](  [param:number time] ) - Evaluate the interpolant at position *t*.
		</p>

		<p class="desc">
			Abstract base class of interpolants over parametric samples.<br />
			The parameter domain is one dimensional, typically the time or a path along a curve defined by the data.<br />
			The sample values can have any dimensionality and derived classes may apply special interpretations to the data.<br />
			This class provides the interval seek in a Template Method, deferring the actual interpolation to derived classes.<br />
			Time complexity is *O(1)* for linear access crossing at most two points and *O(log N)* for random access, where *N* is the number of positions.<br />
			References:	[link:http://www.oodesign.com/template-method-pattern.html http://www.oodesign.com/template-method-pattern.html]
		</p>

		<hr class="interface-line"/>
		<h3 id="Intersection">Intersection <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number distance] -  The distance.<br />
			[property:number distanceToRay]? -  The distance to ray.<br />
			[property:Face face]? -  The face.<br />
			[property:number faceIndex]? -  The face index.<br />
			[property:number index]? -  The index.<br />
			[property:number instanceId]? -  The instance id.<br />
			[property:TIntersected object] -  The object.<br />
			[property:Vector3 point] -  The point.<br />
			[property:Vector2 uv]? -  The uv.
		</p>

		<p class="desc">
			Intersection
		</p>

		<hr class="interface-line"/>
		<h3 id="JSONObject">JSONObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number expressID] -  The express i d.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="JoinNode">JoinNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:JoinNode JoinNode](  [param:NodeNode x],  [param:NodeNode y],  [param:NodeNode z]?,  [param:NodeNode w]? ) <br />
			[constructor:JoinNode JoinNode](  [param:NodeNode x],  [param:NodeNode y],  [param:NodeNode z]?,  [param:NodeNode w]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:JoinNode JoinNode](  [param:NodeNode x],  [param:NodeNode y],  [param:NodeNode z]?,  [param:NodeNode w]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:NodeNode w] -  The w.<br />
			[property:NodeNode x] -  The x.<br />
			[property:NodeNode y] -  The y.<br />
			[property:NodeNode z] -  The z.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:JoinNode copy](  [param:JoinNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:number getNumElements](  ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:JoinNode setLabel](  [param:string name] ) <br />
			[method:JoinNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="KMZLoader">KMZLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:KMZLoader KMZLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:KMZLoader KMZLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Collada parse](  [param:ArrayBuffer data] ) <br />
			[method:KMZLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:KMZLoader setPath](  [param:string path] ) <br />
			[method:KMZLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:KMZLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:KMZLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr; [page:CompressedTextureLoader] &rarr;

		<h3 id="KTX2Loader">KTX2Loader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:KTX2Loader KTX2Loader](  [param:LoadingManager manager]? ) <br />
			[constructor:KTX2Loader KTX2Loader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) <br />
			[constructor:KTX2Loader KTX2Loader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:KTX2Loader detectSupport](  [param:WebGLRenderer renderer] ) <br />
			[method:KTX2Loader dispose](  ) <br />
			[method:CompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:KTX2Loader parse](  [param:ArrayBuffer buffer],  [param:any onLoad],  [param:any onError]? ) <br />
			[method:KTX2Loader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:KTX2Loader setPath](  [param:string path] ) <br />
			[method:KTX2Loader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:KTX2Loader setResourcePath](  [param:string resourcePath] ) <br />
			[method:KTX2Loader setTranscoderPath](  [param:string path] ) <br />
			[method:KTX2Loader setWithCredentials](  [param:boolean value] ) <br />
			[method:KTX2Loader setWorkerLimit](  [param:number limit] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr; [page:CompressedTextureLoader] &rarr;

		<h3 id="KTXLoader">KTXLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:KTXLoader KTXLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:KTXLoader KTXLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) <br />
			[constructor:KTXLoader KTXLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:CompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:KTX parse](  [param:ArrayBuffer buffer],  [param:boolean loadMipmaps] ) <br />
			[method:KTXLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:KTXLoader setPath](  [param:string path] ) <br />
			[method:KTXLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:KTXLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:KTXLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="KaleidoShader">KaleidoShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="KeyframeTrack">KeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:KeyframeTrack KeyframeTrack](  [param:string name],  [param:ArrayLike times],  [param:ArrayLike values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:LinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:CubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:KeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:KeyframeTrack optimize](  ) <br />
			[method:KeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:KeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:KeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:any toJSON](  [param:KeyframeTrack track] ) <br />
			[method:KeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="LDrawLoader">LDrawLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LDrawLoader LDrawLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:LDrawLoader LDrawLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addMaterial](  [param:Material material] ) <br />
			[method:Material getMaterial](  [param:string colourCode] ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void parse](  [param:string text],  [param:string path],  [param:any onLoad] ) <br />
			[method:LDrawLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:void setFileMap](  [param:Record fileMap] ) <br />
			[method:void setMaterials](  [param:Material[] materials] ) <br />
			[method:LDrawLoader setPath](  [param:string path] ) <br />
			[method:LDrawLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:LDrawLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:LDrawLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="LUT3dlLoader">LUT3dlLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LUT3dlLoader LUT3dlLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:LUT3dlLoader LUT3dlLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:any load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:LUT3dlResult parse](  [param:string data] ) <br />
			[method:LUT3dlLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:LUT3dlLoader setPath](  [param:string path] ) <br />
			[method:LUT3dlLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:LUT3dlLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:LUT3dlLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LUT3dlResult">LUT3dlResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number size] -  The size.<br />
			[property:DataTexture texture] -  The texture.<br />
			[property:DataTexture3D texture3D] -  The texture3 d.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="LUTCubeLoader">LUTCubeLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LUTCubeLoader LUTCubeLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:LUTCubeLoader LUTCubeLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:any load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:LUTCubeResult parse](  [param:string data] ) <br />
			[method:LUTCubeLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:LUTCubeLoader setPath](  [param:string path] ) <br />
			[method:LUTCubeLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:LUTCubeLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:LUTCubeLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LUTCubeResult">LUTCubeResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Vector3 domainMax] -  The domain max.<br />
			[property:Vector3 domainMin] -  The domain min.<br />
			[property:number size] -  The size.<br />
			[property:DataTexture texture] -  The texture.<br />
			[property:DataTexture3D texture3D] -  The texture3 d.<br />
			[property:string title] -  The title.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr; [page:ShaderPass] &rarr;

		<h3 id="LUTPass">LUTPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LUTPass LUTPass](  [param:LUTPassParameters params] ) <br />
			[constructor:LUTPass LUTPass](  [param:LUTPassParameters params],  [param:object shader],  [param:string textureID]? ) <br />
			[constructor:LUTPass LUTPass](  [param:LUTPassParameters params],  [param:object shader],  [param:string textureID]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:number intensity]? -  The intensity.<br />
			[property:DataTexture|DataTexture3D lut]? -  The lut.<br />
			[property:ShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LUTPassParameters">LUTPassParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number intensity]? -  The intensity.<br />
			[property:DataTexture|DataTexture3D lut]? -  The lut.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="LWOLoader">LWOLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LWOLoader LWOLoader](  [param:LoadingManager manager]?,  [param:LWOLoaderParameters parameters]? ) <br />
			[constructor:LWOLoader LWOLoader](  [param:LoadingManager manager]?,  [param:LWOLoaderParameters parameters]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:LWO parse](  [param:ArrayBuffer data],  [param:string path],  [param:string modelName] ) <br />
			[method:LWOLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:LWOLoader setPath](  [param:string path] ) <br />
			[method:LWOLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:LWOLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:LWOLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LWOLoaderParameters">LWOLoaderParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string resourcePath]? - Base content delivery folder path, use when it differs from Lightwave default structure
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="LatheBufferGeometry">LatheBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LatheGeometry LatheGeometry](  [param:Vector2[] points]?,  [param:number segments]?,  [param:number phiStart]?,  [param:number phiLength]? ) <br />
			[constructor:LatheGeometry LatheGeometry](  [param:Vector2[] points]?,  [param:number segments]?,  [param:number phiStart]?,  [param:number phiLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:LatheGeometry LatheGeometry](  [param:Vector2[] points]?,  [param:number segments]?,  [param:number phiStart]?,  [param:number phiLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:LatheGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:LatheGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="LatheGeometry">LatheGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LatheGeometry LatheGeometry](  [param:Vector2[] points]?,  [param:number segments]?,  [param:number phiStart]?,  [param:number phiLength]? ) <br />
			[constructor:LatheGeometry LatheGeometry](  [param:Vector2[] points]?,  [param:number segments]?,  [param:number phiStart]?,  [param:number phiLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:LatheGeometry LatheGeometry](  [param:Vector2[] points]?,  [param:number segments]?,  [param:number phiStart]?,  [param:number phiLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:LatheGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:LatheGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Layers">Layers <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Layers Layers](  ) - Create a new Layers object, with membership initially set to layer 0.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number mask] - A bit mask storing which of the 32 layers this layers object is currently a member of.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void disable](  [param:number channel] ) - Remove membership of this *layer*.<br />
			[method:void disableAll](  ) - Remove membership from all layers.<br />
			[method:void enable](  [param:number channel] ) - Add membership of this *layer*.<br />
			[method:void enableAll](  ) - Add membership to all layers.<br />
			[method:boolean isEnabled](  [param:number channel] ) - Returns : Returns true if the given layer is enabled.<br />
			[method:void set](  [param:number channel] ) - Set membership to *layer*, and remove membership all other layers.<br />
			[method:boolean test](  [param:Layers layers] ) <br />
			[method:void toggle](  [param:number channel] ) - Toggle membership of *layer*.
		</p>

		<p class="desc">
			A [Layers](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Layers) object assigns an [Object3D](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Object3D) to 1 or more of 32 layers numbered 0 to 31 - internally the layers are stored as a [bit mask](https://en.wikipedia.org/wiki/Mask_(computing)), and by default all Object3Ds are a member of layer 0.<br />
			This can be used to control visibility - an object must share a layer with a [camera](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Camera) to be visible when that camera's view is rendered.<br />
			All classes that inherit from [Object3D](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Object3D) have an [Object3D.layers](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Object3D.layers) property which is an instance of this class.<br />
			[example:webgl_layers WebGL / layers]
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="Lensflare">Lensflare <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Lensflare Lensflare](  ) <br />
			[constructor:Lensflare Lensflare](  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:Lensflare Lensflare](  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:Lensflare Lensflare](  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isLensflare] -  The is lensflare.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Lensflare add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addElement](  [param:LensflareElement element] ) <br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Lensflare applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Lensflare attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Lensflare clear](  ) - Removes all child objects.<br />
			[method:Lensflare clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Lensflare copy](  [param:Lensflare source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:Lensflare remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Lensflare removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Lensflare rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Lensflare rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Lensflare rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Lensflare rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Lensflare rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Lensflare translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Lensflare translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Lensflare translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Lensflare translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LensflareElement">LensflareElement <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LensflareElement LensflareElement](  [param:Texture texture],  [param:number size]?,  [param:number distance]?,  [param:Color color]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number distance] -  The distance.<br />
			[property:number size] -  The size.<br />
			[property:Texture texture] -  The texture.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Light">Light <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Light Light](  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:Light Light](  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:Light Light](  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:LightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Light add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Light applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Light attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Light clear](  ) - Removes all child objects.<br />
			[method:Light clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Light copy](  [param:Light source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:Light remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Light removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Light rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Light rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Light rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Light rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Light rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Light translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Light translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Light translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Light translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			Abstract base class for lights.
		</p>

		<hr class="interface-line"/>
		<h3 id="LightMapContainers">LightMapContainers <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Material|Material[] basicMat] -  The basic mat.<br />
			[property:Object3D object] -  The object.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="LightNode">LightNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LightNode LightNode](  [param:string scope]? ) <br />
			[constructor:LightNode LightNode](  [param:string scope]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:LightNode LightNode](  [param:string scope]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string TOTAL] -  The t o t a l.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:LightNode copy](  [param:LightNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:LightNode setLabel](  [param:string name] ) <br />
			[method:LightNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Light] &rarr;

		<h3 id="LightProbe">LightProbe <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LightProbe LightProbe](  [param:SphericalHarmonics3 sh]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:LightProbe LightProbe](  [param:SphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:LightProbe LightProbe](  [param:SphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:LightProbe LightProbe](  [param:SphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isLightProbe] -  The is light probe.<br />
			[property:SphericalHarmonics3 sh] -  The sh.<br />
			[property:LightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:LightProbe add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:LightProbe applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:LightProbe attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:LightProbe clear](  ) - Removes all child objects.<br />
			[method:LightProbe clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:LightProbe copy](  [param:LightProbe source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:LightProbe fromJSON](  [param:object json] ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:LightProbe remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:LightProbe removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:LightProbe rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LightProbe rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:LightProbe rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:LightProbe rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:LightProbe rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:LightProbe translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LightProbe translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:LightProbe translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:LightProbe translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LightProbeGenerator">LightProbeGenerator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:LightProbe fromCubeRenderTarget](  [param:WebGLRenderer renderer],  [param:WebGLCubeRenderTarget cubeRenderTarget] ) <br />
			[method:LightProbe fromCubeTexture](  [param:CubeTexture cubeTexture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="LightProbeHelper">LightProbeHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LightProbeHelper LightProbeHelper](  [param:LightProbe lightProbe],  [param:number size] ) <br />
			[constructor:LightProbeHelper LightProbeHelper](  [param:LightProbe lightProbe],  [param:number size],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:LightProbeHelper LightProbeHelper](  [param:LightProbe lightProbe],  [param:number size],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:LightProbeHelper LightProbeHelper](  [param:LightProbe lightProbe],  [param:number size],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:LightProbe lightProbe] -  The light probe.<br />
			[property:number size] -  The size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:LightProbeHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:LightProbeHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:LightProbeHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:LightProbeHelper clear](  ) - Removes all child objects.<br />
			[method:LightProbeHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:LightProbeHelper copy](  [param:LightProbeHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:LightProbeHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:LightProbeHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:LightProbeHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LightProbeHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:LightProbeHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:LightProbeHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:LightProbeHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:LightProbeHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LightProbeHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:LightProbeHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:LightProbeHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LightShadow">LightShadow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LightShadow LightShadow](  [param:Camera camera] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:number bias] -  The bias.<br />
			[property:number blurSamples] -  The blur samples.<br />
			[property:Camera camera] -  The camera.<br />
			[property:WebGLRenderTarget map] -  The map.<br />
			[property:WebGLRenderTarget mapPass] -  The map pass.<br />
			[property:Vector2 mapSize] -  The map size.<br />
			[property:Matrix4 matrix] -  The matrix.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number normalBias] -  The normal bias.<br />
			[property:number radius] -  The radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:LightShadow clone](  [param:boolean recursive]? ) <br />
			[method:LightShadow copy](  [param:LightShadow source] ) <br />
			[method:void dispose](  ) <br />
			[method:Vector2 getFrameExtents](  ) <br />
			[method:number getFrustum](  ) <br />
			[method:Vector4 getViewport](  [param:number viewportIndex] ) <br />
			[method:any toJSON](  ) <br />
			[method:void updateMatrices](  [param:Light light],  [param:number viewportIndex]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LightningSegment">LightningSegment <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number fraction0] -  The fraction0.<br />
			[property:number fraction1] -  The fraction1.<br />
			[property:number iteration] -  The iteration.<br />
			[property:Vector3 linPos0] -  The lin pos0.<br />
			[property:Vector3 linPos1] -  The lin pos1.<br />
			[property:Vector3 pos0] -  The pos0.<br />
			[property:Vector3 pos1] -  The pos1.<br />
			[property:number positionVariationFactor] -  The position variation factor.<br />
			[property:number radius0] -  The radius0.<br />
			[property:number radius1] -  The radius1.<br />
			[property:Vector3 up0] -  The up0.<br />
			[property:Vector3 up1] -  The up1.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LightningStorm">LightningStorm <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LightningStorm LightningStorm](  [param:StormParams stormParams]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:LightningStorm clone](  ) <br />
			[method:LightningStorm copy](  [param:LightningStorm source] ) <br />
			[method:void update](  [param:number time] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LightningStrike">LightningStrike <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LightningStrike LightningStrike](  [param:RayParameters rayParameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number RAY_EXTINGUISHED] -  The r a y_ e x t i n g u i s h e d.<br />
			[property:number RAY_INITIALIZED] -  The r a y_ i n i t i a l i z e d.<br />
			[property:number RAY_PROPAGATING] -  The r a y_ p r o p a g a t i n g.<br />
			[property:number RAY_STEADY] -  The r a y_ s t e a d y.<br />
			[property:number RAY_UNBORN] -  The r a y_ u n b o r n.<br />
			[property:number RAY_VANISHING] -  The r a y_ v a n i s h i n g.<br />
			[property:number state] -  The state.
		</p>
		<h4>Methods</h4>
		<p>
			[method:LightningStrike clone](  ) <br />
			[method:LightningStrike copy](  [param:LightningStrike source] ) <br />
			[method:RayParameters copyParameters](  [param:RayParameters dest]?,  [param:RayParameters source]? ) <br />
			[method:void update](  [param:number time] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LightningSubray">LightningSubray <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number beginVanishingTime] -  The begin vanishing time.<br />
			[property:number birthTime] -  The birth time.<br />
			[property:number deathTime] -  The death time.<br />
			[property:number endPropagationTime] -  The end propagation time.<br />
			[property:Vector3 linPos0] -  The lin pos0.<br />
			[property:Vector3 linPos1] -  The lin pos1.<br />
			[property:number maxIterations] -  The max iterations.<br />
			[property:Vector3 pos0] -  The pos0.<br />
			[property:Vector3 pos1] -  The pos1.<br />
			[property:number propagationTimeFactor] -  The propagation time factor.<br />
			[property:number radius0] -  The radius0.<br />
			[property:number radius1] -  The radius1.<br />
			[property:number recursion] -  The recursion.<br />
			[property:number roughness] -  The roughness.<br />
			[property:number seed] -  The seed.<br />
			[property:number straightness] -  The straightness.<br />
			[property:number timeScale] -  The time scale.<br />
			[property:Vector3 up0] -  The up0.<br />
			[property:Vector3 up1] -  The up1.<br />
			[property:number vanishingTimeFactor] -  The vanishing time factor.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Line">Line <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Line Line](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:Line Line](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - The constructor takes no arguments.<br />
			[constructor:Line Line](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:TGeometry geometry] - Vertices representing the line segment(s).<br />
			[property:any isLine] -  The is line.<br />
			[property:TMaterial material] - Material for the line.<br />
			[property:any morphTargetDictionary]? - A dictionary of morphTargets based on the morphTarget.name property.<br />
			Undefined by default, but rebuilt *.updateMorphTargets*().<br />
			[property:number[] morphTargetInfluences]? - An array of weights typically from 0-1 that specify how much of the morph is applied.<br />
			Undefined by default, but reset to a blank array by *.updateMorphTargets*().<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Line add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Line applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Line attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Line clear](  ) - Removes all child objects.<br />
			[method:Line clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Line computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:Line copy](  [param:Line source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:Line remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Line removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Line rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Line rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Line rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Line rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Line rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Line translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Line translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Line translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Line translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			A continuous line.<br />
			This is nearly the same as [LineSegments](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/LineSegments); the only difference is that it is rendered using [gl.LINE_STRIP](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements)<br />
			instead of [gl.LINES](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements)<br />
			<code data-type="javascript"><br />
			const material = new THREE.LineBasicMaterial({ color: 0x0000ff });<br />
			const points = [];<br />
			points.push( new THREE.Vector3( - 10, 0, 0 ) );<br />
			points.push( new THREE.Vector3( 0, 10, 0 ) );<br />
			points.push( new THREE.Vector3( 10, 0, 0 ) );<br />
			const geometry = new THREE.BufferGeometry().setFromPoints( points );<br />
			const line = new THREE.Line( geometry, material );<br />
			scene.add( line );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr; [page:LineSegments2] &rarr;

		<h3 id="Line2">Line2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Line2 Line2](  [param:LineGeometry geometry]?,  [param:LineMaterial material]? ) <br />
			[constructor:Line2 Line2](  [param:LineGeometry geometry]?,  [param:LineMaterial material]?,  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]? ) <br />
			[constructor:Line2 Line2](  [param:LineGeometry geometry]?,  [param:LineMaterial material]?,  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:Line2 Line2](  [param:LineGeometry geometry]?,  [param:LineMaterial material]?,  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:Line2 Line2](  [param:LineGeometry geometry]?,  [param:LineMaterial material]?,  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:LineGeometry geometry] - An instance of [page:BufferGeometry BufferGeometry] (or derived classes), defining the object's structure.<br />
			[property:any isLine2] -  The is line2.<br />
			[property:any isLineSegments2] -  The is line segments2.<br />
			[property:LineMaterial material] - An instance of material derived from the [page:Material Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial MeshBasicMaterial].
		</p>
		<h4>Methods</h4>
		<p>
			[method:Line2 add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Line2 applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Line2 attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Line2 clear](  ) - Removes all child objects.<br />
			[method:Line2 clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Line2 computeLineDistances](  ) <br />
			[method:Line2 copy](  [param:Line2 source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:Line2 remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Line2 removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Line2 rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Line2 rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Line2 rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Line2 rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Line2 rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Line2 translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Line2 translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Line2 translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Line2 translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Line3">Line3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Line3 Line3](  [param:Vector3 start]?,  [param:Vector3 end]? ) - Creates a new Line3.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Vector3 end] - [page:Vector3 Vector3] representing the end point of the line.<br />
			[property:Vector3 start] - [page:Vector3 Vector3] representing the start point of the line.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Line3 applyMatrix4](  [param:Matrix4 matrix] ) - Applies a matrix transform to the line segment.<br />
			[method:Vector3 at](  [param:number t],  [param:Vector3 target] ) - Returns : Returns a vector at a certain position along the line. When [page:Float t] = 0, it returns the start vector, and when [page:Float t] = 1 it returns the end vector.<br />
			[method:Line3 clone](  ) - Returns : Returns a new [page:Line3 Line3] with the same *.start* and *.end* vectors as this one.<br />
			[method:Vector3 closestPointToPoint](  [param:Vector3 point],  [param:boolean clampToLine],  [param:Vector3 target] ) - Returns : Returns the closets point on the line. If [page:Boolean clampToLine] is true, then the returned value will be clamped to the line segment.<br />
			[method:number closestPointToPointParameter](  [param:Vector3 point],  [param:boolean clampToLine]? ) - If [clampToLine](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Boolean) is true, then the returned value will be between 0 and 1.<br />
			<br />
			Returns : Returns a point parameter based on the closest point as projected on the line segement.<br />
			[method:Line3 copy](  [param:Line3 line] ) - Copies the passed line's *.start* and *.end* vectors to this line.<br />
			[method:Vector3 delta](  [param:Vector3 target] ) - Returns : Returns the delta vector of the line segment ( *.end* vector minus the *.start* vector).<br />
			[method:number distance](  ) - (straight-line distance) between the line's *.start* and *.end* points.<br />
			<br />
			Returns : Returns the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean distance]<br />
			[method:number distanceSq](  ) - Returns : Returns the square of the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean distance] (straight-line distance) between the line's *.start* and *.end* vectors.<br />
			[method:boolean equals](  [param:Line3 line] ) - Returns : Returns true if both line's *.start* and *.end* points are equal.<br />
			[method:Vector3 getCenter](  [param:Vector3 target] ) - Returns : Returns the center of the line segment.<br />
			[method:Line3 set](  [param:Vector3 start]?,  [param:Vector3 end]? ) - Sets the start and end values by copying the provided vectors.
		</p>

		<p class="desc">
			A geometric line segment represented by a start and end point.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="LineBasicMaterial">LineBasicMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineBasicMaterial LineBasicMaterial](  [param:LineBasicMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:LineBasicMaterial LineBasicMaterial](  [param:LineBasicMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:LineBasicMaterial LineBasicMaterial](  [param:LineBasicMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string linecap] -  The linecap.<br />
			[property:string linejoin] -  The linejoin.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:LineBasicMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:LineBasicMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:LineBasicMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="LineBasicMaterialParameters">LineBasicMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string linecap]? -  The linecap.<br />
			[property:string linejoin]? -  The linejoin.<br />
			[property:number linewidth]? -  The linewidth.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="LineCurve">LineCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineCurve LineCurve](  [param:Vector2 v1],  [param:Vector2 v2] ) <br />
			[constructor:LineCurve LineCurve](  [param:Vector2 v1],  [param:Vector2 v2] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:Vector2 v1] -  The v1.<br />
			[property:Vector2 v2] -  The v2.
		</p>
		<h4>Methods</h4>
		<p>
			[method:LineCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:LineCurve copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:LineCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="LineCurve3">LineCurve3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineCurve3 LineCurve3](  [param:Vector3 v1],  [param:Vector3 v2] ) <br />
			[constructor:LineCurve3 LineCurve3](  [param:Vector3 v1],  [param:Vector3 v2] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:Vector3 v1] -  The v1.<br />
			[property:Vector3 v2] -  The v2.
		</p>
		<h4>Methods</h4>
		<p>
			[method:LineCurve3 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:LineCurve3 copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:LineCurve3 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector3 getPoint](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getPointAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector3 getTangent](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getTangentAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:LineBasicMaterial] &rarr;

		<h3 id="LineDashedMaterial">LineDashedMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineDashedMaterial LineDashedMaterial](  [param:LineDashedMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:LineDashedMaterial LineDashedMaterial](  [param:LineDashedMaterialParameters parameters]?,  [param:LineBasicMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:LineDashedMaterial LineDashedMaterial](  [param:LineDashedMaterialParameters parameters]?,  [param:LineBasicMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:LineDashedMaterial LineDashedMaterial](  [param:LineDashedMaterialParameters parameters]?,  [param:LineBasicMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:number dashSize] -  The dash size.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number gapSize] -  The gap size.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isLineDashedMaterial] -  The is line dashed material.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string linecap] -  The linecap.<br />
			[property:string linejoin] -  The linejoin.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number scale] -  The scale.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:LineDashedMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:LineDashedMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:LineDashedMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr; [page:LineBasicMaterialParameters] &rarr;

		<h3 id="LineDashedMaterialParameters">LineDashedMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:number dashSize]? -  The dash size.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:number gapSize]? -  The gap size.<br />
			[property:string linecap]? -  The linecap.<br />
			[property:string linejoin]? -  The linejoin.<br />
			[property:number linewidth]? -  The linewidth.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number scale]? -  The scale.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:InstancedBufferGeometry] &rarr; [page:LineSegmentsGeometry] &rarr;

		<h3 id="LineGeometry">LineGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineGeometry LineGeometry](  ) <br />
			[constructor:LineGeometry LineGeometry](  ) <br />
			[constructor:LineGeometry LineGeometry](  ) <br />
			[constructor:LineGeometry LineGeometry](  ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:LineGeometry LineGeometry](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isLineGeometry] -  The is line geometry.<br />
			[property:any isLineSegmentsGeometry] -  The is line segments geometry.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number instances] ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:LineGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:LineGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:LineGeometry fromEdgesGeometry](  [param:EdgesGeometry geometry] ) <br />
			[method:LineGeometry fromLine](  [param:Line line] ) <br />
			[method:LineGeometry fromLineSegments](  [param:LineSegments lineSegments] ) <br />
			[method:LineGeometry fromMesh](  [param:Mesh mesh] ) <br />
			[method:LineGeometry fromWireframeGeometry](  [param:WireframeGeometry geometry] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:LineGeometry setColors](  [param:Float32Array|number[] array] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:LineGeometry setPositions](  [param:Float32Array|number[] array] ) <br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr;

		<h3 id="LineLoop">LineLoop <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineLoop LineLoop](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:LineLoop LineLoop](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:LineLoop LineLoop](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - The constructor takes no arguments.<br />
			[constructor:LineLoop LineLoop](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:TGeometry geometry] - Vertices representing the line segment(s).<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineLoop] -  The is line loop.<br />
			[property:TMaterial material] - Material for the line.<br />
			[property:any morphTargetDictionary]? - A dictionary of morphTargets based on the morphTarget.name property.<br />
			Undefined by default, but rebuilt *.updateMorphTargets*().<br />
			[property:number[] morphTargetInfluences]? - An array of weights typically from 0-1 that specify how much of the morph is applied.<br />
			Undefined by default, but reset to a blank array by *.updateMorphTargets*().<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:LineLoop add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:LineLoop applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:LineLoop attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:LineLoop clear](  ) - Removes all child objects.<br />
			[method:LineLoop clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:LineLoop computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:LineLoop copy](  [param:LineLoop source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:LineLoop remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:LineLoop removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:LineLoop rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LineLoop rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:LineLoop rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:LineLoop rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:LineLoop rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:LineLoop translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LineLoop translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:LineLoop translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:LineLoop translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			A continuous line that connects back to the start.<br />
			This is nearly the same	as [page:Line Line]; the only difference is that it is rendered using [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements gl.LINE_LOOP]<br />
			instead of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements gl.LINE_STRIP], which draws a straight line to the next vertex, and connects the last vertex back to the first.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:ShaderMaterial] &rarr;

		<h3 id="LineMaterial">LineMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineMaterial LineMaterial](  [param:LineMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:LineMaterial LineMaterial](  [param:LineMaterialParameters parameters]?,  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:LineMaterial LineMaterial](  [param:LineMaterialParameters parameters]?,  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:LineMaterial LineMaterial](  [param:LineMaterialParameters parameters]?,  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:Color color] -  The color.<br />
			[property:number dashOffset] -  The dash offset.<br />
			[property:number dashScale] -  The dash scale.<br />
			[property:number dashSize] -  The dash size.<br />
			[property:boolean dashed] -  The dashed.<br />
			[property:number gapSize] -  The gap size.<br />
			[property:any isLineMaterial] -  The is line material.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:Vector2 resolution] -  The resolution.<br />
			[property:boolean worldUnits] -  The world units.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:LineMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:LineMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="LineMaterialParameters">LineMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:number color]? -  The color.<br />
			[property:number dashOffset]? -  The dash offset.<br />
			[property:number dashScale]? -  The dash scale.<br />
			[property:number dashSize]? -  The dash size.<br />
			[property:boolean dashed]? -  The dashed.<br />
			[property:number gapSize]? -  The gap size.<br />
			[property:number linewidth]? -  The linewidth.<br />
			[property:Vector2 resolution]? -  The resolution.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:boolean worldUnits]? -  The world units.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr;

		<h3 id="LineSegments">LineSegments <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineSegments LineSegments](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:LineSegments LineSegments](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:LineSegments LineSegments](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - The constructor takes no arguments.<br />
			[constructor:LineSegments LineSegments](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:TGeometry geometry] - Vertices representing the line segment(s).<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:TMaterial material] - Material for the line.<br />
			[property:any morphTargetDictionary]? - A dictionary of morphTargets based on the morphTarget.name property.<br />
			Undefined by default, but rebuilt *.updateMorphTargets*().<br />
			[property:number[] morphTargetInfluences]? - An array of weights typically from 0-1 that specify how much of the morph is applied.<br />
			Undefined by default, but reset to a blank array by *.updateMorphTargets*().<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:LineSegments add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:LineSegments applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:LineSegments attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:LineSegments clear](  ) - Removes all child objects.<br />
			[method:LineSegments clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:LineSegments computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:LineSegments copy](  [param:LineSegments source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:LineSegments remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:LineSegments removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:LineSegments rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LineSegments rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:LineSegments rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:LineSegments rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:LineSegments rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:LineSegments translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LineSegments translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:LineSegments translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:LineSegments translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			A series of lines drawn between pairs of vertices.<br />
			This is nearly the same	as [page:Line Line]; the only difference is that it is rendered using [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements gl.LINES]<br />
			instead of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements gl.LINE_STRIP].
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="LineSegments2">LineSegments2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineSegments2 LineSegments2](  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]? ) <br />
			[constructor:LineSegments2 LineSegments2](  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:LineSegments2 LineSegments2](  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:LineSegments2 LineSegments2](  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:LineSegmentsGeometry geometry] - An instance of [page:BufferGeometry BufferGeometry] (or derived classes), defining the object's structure.<br />
			[property:any isLineSegments2] -  The is line segments2.<br />
			[property:LineMaterial material] - An instance of material derived from the [page:Material Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial MeshBasicMaterial].
		</p>
		<h4>Methods</h4>
		<p>
			[method:LineSegments2 add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:LineSegments2 applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:LineSegments2 attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:LineSegments2 clear](  ) - Removes all child objects.<br />
			[method:LineSegments2 clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:LineSegments2 computeLineDistances](  ) <br />
			[method:LineSegments2 copy](  [param:LineSegments2 source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:LineSegments2 remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:LineSegments2 removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:LineSegments2 rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LineSegments2 rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:LineSegments2 rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:LineSegments2 rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:LineSegments2 rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:LineSegments2 translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:LineSegments2 translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:LineSegments2 translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:LineSegments2 translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:InstancedBufferGeometry] &rarr;

		<h3 id="LineSegmentsGeometry">LineSegmentsGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LineSegmentsGeometry LineSegmentsGeometry](  ) <br />
			[constructor:LineSegmentsGeometry LineSegmentsGeometry](  ) <br />
			[constructor:LineSegmentsGeometry LineSegmentsGeometry](  ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:LineSegmentsGeometry LineSegmentsGeometry](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isLineSegmentsGeometry] -  The is line segments geometry.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number instances] ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:LineSegmentsGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:LineSegmentsGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:LineSegmentsGeometry fromEdgesGeometry](  [param:EdgesGeometry geometry] ) <br />
			[method:LineSegmentsGeometry fromLineSegments](  [param:LineSegments lineSegments] ) <br />
			[method:LineSegmentsGeometry fromMesh](  [param:Mesh mesh] ) <br />
			[method:LineSegmentsGeometry fromWireframeGeometry](  [param:WireframeGeometry geometry] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:LineSegmentsGeometry setColors](  [param:Float32Array|number[] array] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:LineSegmentsGeometry setPositions](  [param:Float32Array|number[] array] ) <br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Interpolant] &rarr;

		<h3 id="LinearInterpolant">LinearInterpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LinearInterpolant LinearInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]? ) <br />
			[constructor:LinearInterpolant LinearInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]?,  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) - Note: This is not designed to be called directly.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] - array of positions<br />
			[property:any resultBuffer] - buffer to store the interpolation results.<br />
			[property:any sampleValues] - array of samples<br />
			[property:number valueSize] - number of samples
		</p>
		<h4>Methods</h4>
		<p>
			[method:number[] evaluate](  [param:number t] ) - Evaluate the interpolant at position *t*.<br />
			[method:any interpolate_](  [param:number i1],  [param:number t0],  [param:number t],  [param:number t1] ) 
		</p>

		<p class="desc">
			Linear interpolant<br />
			<code data-type="javascript"><br />
			const interpolant = new THREE.LinearInterpolant(<br />
			new Float32Array( 2 ), new Float32Array( 2 ),, n, new Float32Array( 1 ) );<br />
			interpolant.evaluate( 0.5 );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		<h3 id="Loader">Loader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Loader Loader](  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Loader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:Loader setPath](  [param:string path] ) <br />
			[method:Loader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:Loader setResourcePath](  [param:string resourcePath] ) <br />
			[method:Loader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			Base class for implementing loaders.
		</p>

		<hr class="interface-line"/>
		<h3 id="LoaderSettings">LoaderSettings <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number CIRCLE_SEGMENTS_HIGH]? -  The c i r c l e_ s e g m e n t s_ h i g h.<br />
			[property:number CIRCLE_SEGMENTS_LOW]? -  The c i r c l e_ s e g m e n t s_ l o w.<br />
			[property:number CIRCLE_SEGMENTS_MEDIUM]? -  The c i r c l e_ s e g m e n t s_ m e d i u m.<br />
			[property:boolean COORDINATE_TO_ORIGIN] -  The c o o r d i n a t e_ t o_ o r i g i n.<br />
			[property:boolean USE_FAST_BOOLS] -  The u s e_ f a s t_ b o o l s.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LoaderUtils">LoaderUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:string decodeText](  [param:BufferSource array] ) <br />
			[method:string extractUrlBase](  [param:string url] ) <br />
			[method:string resolveURL](  [param:string url],  [param:string path] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LoadingManager">LoadingManager <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LoadingManager LoadingManager](  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any onStart]? -  The on start.
		</p>
		<h4>Methods</h4>
		<p>
			[method:LoadingManager addHandler](  [param:RegExp regex],  [param:Loader loader] ) <br />
			[method:Loader getHandler](  [param:string file] ) <br />
			[method:void itemEnd](  [param:string url] ) <br />
			[method:void itemError](  [param:string url] ) <br />
			[method:void itemStart](  [param:string url] ) <br />
			[method:void onError](  [param:string url] ) - Will be called when item loading fails.<br />
			The default is a with empty body.<br />
			[method:void onLoad](  ) - Will be called when all items finish loading.<br />
			The default is a with empty body.<br />
			[method:void onProgress](  [param:string url],  [param:number loaded],  [param:number total] ) - Will be called for each loaded item.<br />
			The default is a with empty body.<br />
			[method:LoadingManager removeHandler](  [param:RegExp regex] ) <br />
			[method:string resolveURL](  [param:string url] ) - Given a URL, uses the URL modifier callback (if any) and returns a resolved URL.<br />
			If no URL modifier is set, returns the original URL.<br />
			[method:LoadingManager setURLModifier](  [param:any callback]? ) - If provided, the callback will be passed each resource URL before a request is sent.<br />
			The callback may return the original URL, or a new URL to override loading behavior.<br />
			This behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs.
		</p>

		<p class="desc">
			Handles and keeps track of loaded and pending data.
		</p>

		<hr class="interface-line"/>
		<h3 id="LogLuv">LogLuv <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Uint16Array|Float32Array data] -  The data.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:number height] -  The height.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number width] -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr; [page:DataTextureLoader] &rarr;

		<h3 id="LogLuvLoader">LogLuvLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LogLuvLoader LogLuvLoader](  [param:LoadingManager manager] ) <br />
			[constructor:LogLuvLoader LogLuvLoader](  [param:LoadingManager manager],  [param:LoadingManager manager]? ) <br />
			[constructor:LogLuvLoader LogLuvLoader](  [param:LoadingManager manager],  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:TextureDataType type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DataTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:LogLuv parse](  [param:Iterable buffer] ) <br />
			[method:LogLuvLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:LogLuvLoader setDataType](  [param:TextureDataType value] ) <br />
			[method:LogLuvLoader setPath](  [param:string path] ) <br />
			[method:LogLuvLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:LogLuvLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:LogLuvLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="LottieLoader">LottieLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LottieLoader LottieLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:LottieLoader LottieLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:LottieLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:LottieLoader setPath](  [param:string path] ) <br />
			[method:void setQuality](  [param:number value] ) <br />
			[method:LottieLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:LottieLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:LottieLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="LuminanceNode">LuminanceNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:LuminanceNode LuminanceNode](  [param:NodeNode rgb] ) <br />
			[constructor:LuminanceNode LuminanceNode](  [param:NodeNode rgb],  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:LuminanceNode LuminanceNode](  [param:NodeNode rgb],  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:NodeNode rgb] -  The rgb.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:LuminanceNode copy](  [param:LuminanceNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:LuminanceNode setLabel](  [param:string name] ) <br />
			[method:LuminanceNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LuminosityHighPassShader">LuminosityHighPassShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:string shaderID] -  The shader i d.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="LuminosityShader">LuminosityShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MD2Character">MD2Character <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MD2Character MD2Character](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string activeAnimation] -  The active animation.<br />
			[property:number animationFPS] -  The animation f p s.<br />
			[property:number loadCounter] -  The load counter.<br />
			[property:Mesh meshBody] -  The mesh body.<br />
			[property:Mesh meshWeapon] -  The mesh weapon.<br />
			[property:AnimationMixer mixer] -  The mixer.<br />
			[property:Object3D root] -  The root.<br />
			[property:number scale] -  The scale.<br />
			[property:Texture[] skinsBody] -  The skins body.<br />
			[property:Texture[] skinsWeapon] -  The skins weapon.<br />
			[property:Mesh[] weapons] -  The weapons.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void loadParts](  [param:MD2PartsConfig config] ) <br />
			[method:void onLoadComplete](  ) <br />
			[method:void setAnimation](  [param:string clipName] ) <br />
			[method:void setPlaybackRate](  [param:number rate] ) <br />
			[method:void setSkin](  [param:number index] ) <br />
			[method:void setWeapon](  [param:number index] ) <br />
			[method:void setWireframe](  [param:boolean wireframeEnabled] ) <br />
			[method:void syncWeaponAnimation](  ) <br />
			[method:void update](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MD2CharacterComplex">MD2CharacterComplex <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MD2CharacterComplex MD2CharacterComplex](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string activeAnimation] -  The active animation.<br />
			[property:number angularSpeed] -  The angular speed.<br />
			[property:number animationFPS] -  The animation f p s.<br />
			[property:object[] animations] -  The animations.<br />
			[property:number backAcceleration] -  The back acceleration.<br />
			[property:number bodyOrientation] -  The body orientation.<br />
			[property:any controls] -  The controls.<br />
			[property:number crouchSpeed] -  The crouch speed.<br />
			[property:number currentSkin] -  The current skin.<br />
			[property:number frontAcceleration] -  The front acceleration.<br />
			[property:number frontDecceleration] -  The front decceleration.<br />
			[property:number loadCounter] -  The load counter.<br />
			[property:number maxReverseSpeed] -  The max reverse speed.<br />
			[property:number maxSpeed] -  The max speed.<br />
			[property:Mesh meshBody] -  The mesh body.<br />
			[property:Mesh meshWeapon] -  The mesh weapon.<br />
			[property:Mesh[] meshes] -  The meshes.<br />
			[property:string oldAnimation] -  The old animation.<br />
			[property:Object3D root] -  The root.<br />
			[property:number scale] -  The scale.<br />
			[property:Texture[] skinsBody] -  The skins body.<br />
			[property:Texture[] skinsWeapon] -  The skins weapon.<br />
			[property:number speed] -  The speed.<br />
			[property:number transitionFrames] -  The transition frames.<br />
			[property:number walkSpeed] -  The walk speed.<br />
			[property:Mesh[] weapons] -  The weapons.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void enableShadows](  [param:boolean enable] ) <br />
			[method:void loadParts](  [param:object config] ) <br />
			[method:void onLoadComplete](  ) <br />
			[method:void setAnimation](  [param:string animationName] ) <br />
			[method:void setPlaybackRate](  [param:number rate] ) <br />
			[method:void setSkin](  [param:number index] ) <br />
			[method:void setVisible](  [param:boolean enable] ) <br />
			[method:void setWeapon](  [param:number index] ) <br />
			[method:void setWireframe](  [param:boolean wireframeEnabled] ) <br />
			[method:void shareParts](  [param:MD2CharacterComplex original] ) <br />
			[method:void update](  [param:number delta] ) <br />
			[method:void updateAnimations](  [param:number delta] ) <br />
			[method:void updateBehaviors](  ) <br />
			[method:void updateMovementModel](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="MD2Loader">MD2Loader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MD2Loader MD2Loader](  [param:LoadingManager manager]? ) <br />
			[constructor:MD2Loader MD2Loader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:BufferGeometry parse](  [param:ArrayBuffer data] ) <br />
			[method:MD2Loader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:MD2Loader setPath](  [param:string path] ) <br />
			[method:MD2Loader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:MD2Loader setResourcePath](  [param:string resourcePath] ) <br />
			[method:MD2Loader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MD2PartsConfig">MD2PartsConfig <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string baseUrl] -  The base url.<br />
			[property:string body] -  The body.<br />
			[property:string[] skins] -  The skins.<br />
			[property:any weapons] -  The weapons.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="MDDLoader">MDDLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MDDLoader MDDLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:MDDLoader MDDLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:MDD parse](  [param:ArrayBuffer data] ) <br />
			[method:MDDLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:MDDLoader setPath](  [param:string path] ) <br />
			[method:MDDLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:MDDLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:MDDLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MMDAnimationHelper">MMDAnimationHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MMDAnimationHelper MMDAnimationHelper](  [param:MMDAnimationHelperParameter params]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Audio audio] -  The audio.<br />
			[property:AudioManager audioManager] -  The audio manager.<br />
			[property:Camera camera] -  The camera.<br />
			[property:Object3D cameraTarget] -  The camera target.<br />
			[property:any configuration] -  The configuration.<br />
			[property:any enabled] -  The enabled.<br />
			[property:any masterPhysics] -  The master physics.<br />
			[property:SkinnedMesh[] meshes] -  The meshes.<br />
			[property:WeakMap objects] -  The objects.<br />
			[property:boolean sharedPhysics] -  The shared physics.
		</p>
		<h4>Methods</h4>
		<p>
			[method:MMDAnimationHelper add](  [param:Camera|SkinnedMesh|Audio object],  [param:MMDAnimationHelperAddParameter params]? ) <br />
			[method:GrantSolver createGrantSolver](  [param:SkinnedMesh mesh] ) <br />
			[method:MMDAnimationHelper enable](  [param:string key],  [param:boolean enabled] ) <br />
			[method:void onBeforePhysics](  [param:SkinnedMesh mesh] ) <br />
			[method:MMDAnimationHelper pose](  [param:SkinnedMesh mesh],  [param:object vpd],  [param:MMDAnimationHelperPoseParameter params]? ) <br />
			[method:MMDAnimationHelper remove](  [param:Camera|SkinnedMesh|Audio object] ) <br />
			[method:MMDAnimationHelper update](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MMDAnimationHelperAddParameter">MMDAnimationHelperAddParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:AnimationClip|AnimationClip[] animation]? -  The animation.<br />
			[property:number delayTime]? -  The delay time.<br />
			[property:number gravity]? -  The gravity.<br />
			[property:number maxStepNum]? -  The max step num.<br />
			[property:boolean physics]? -  The physics.<br />
			[property:number unitStep]? -  The unit step.<br />
			[property:number warmup]? -  The warmup.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MMDAnimationHelperMixer">MMDAnimationHelperMixer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number duration]? -  The duration.<br />
			[property:GrantSolver grantSolver] -  The grant solver.<br />
			[property:CCDIKSolver ikSolver] -  The ik solver.<br />
			[property:boolean looped] -  The looped.<br />
			[property:AnimationMixer mixer]? -  The mixer.<br />
			[property:MMDPhysics physics]? -  The physics.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MMDAnimationHelperParameter">MMDAnimationHelperParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number afterglow]? -  The afterglow.<br />
			[property:boolean resetPhysicsOnLoop]? -  The reset physics on loop.<br />
			[property:boolean sync]? -  The sync.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MMDAnimationHelperPoseParameter">MMDAnimationHelperPoseParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean grant]? -  The grant.<br />
			[property:boolean ik]? -  The ik.<br />
			[property:boolean resetPose]? -  The reset pose.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MMDExporter">MMDExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MMDExporter MMDExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint8Array parseVpd](  [param:Object3D skin],  [param:boolean outputShiftJis],  [param:boolean useOriginalBones] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="MMDLoader">MMDLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MMDLoader MMDLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:MMDLoader MMDLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object animationBuilder] -  The animation builder.<br />
			[property:string animationPath] -  The animation path.<br />
			[property:FileLoader loader] -  The loader.<br />
			[property:object meshBuilder] -  The mesh builder.<br />
			[property:object parser] -  The parser.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadAnimation](  [param:string url],  [param:Camera|SkinnedMesh object],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void loadPMD](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadPMX](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadVMD](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadVPD](  [param:string url],  [param:boolean isUnicode],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadWithAnimation](  [param:string url],  [param:string|string[] vmdUrl],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:MMDLoader setAnimationPath](  [param:string animationPath] ) <br />
			[method:MMDLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:MMDLoader setPath](  [param:string path] ) <br />
			[method:MMDLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:MMDLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:MMDLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MMDLoaderAnimationObject">MMDLoaderAnimationObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:AnimationClip animation] -  The animation.<br />
			[property:SkinnedMesh mesh] -  The mesh.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MMDPhysics">MMDPhysics <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MMDPhysics MMDPhysics](  [param:SkinnedMesh mesh],  [param:object[] rigidBodyParams],  [param:object[] constraintParams]?,  [param:MMDPhysicsParameter params]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:RigidBody[] bodies] -  The bodies.<br />
			[property:Constraint[] constraints] -  The constraints.<br />
			[property:Vector3 gravity] -  The gravity.<br />
			[property:ResourceManager manager] -  The manager.<br />
			[property:number maxStepNum] -  The max step num.<br />
			[property:SkinnedMesh mesh] -  The mesh.<br />
			[property:number unitStep] -  The unit step.<br />
			[property:any world] -  The world.
		</p>
		<h4>Methods</h4>
		<p>
			[method:MMDPhysicsHelper createHelper](  ) <br />
			[method:MMDPhysics reset](  ) <br />
			[method:MMDPhysics setGravity](  [param:Vector3 gravity] ) <br />
			[method:MMDPhysics update](  [param:number delta] ) <br />
			[method:MMDPhysics warmup](  [param:number cycles] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="MMDPhysicsHelper">MMDPhysicsHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MMDPhysicsHelper MMDPhysicsHelper](  ) - The constructor takes no arguments.<br />
			[constructor:MMDPhysicsHelper MMDPhysicsHelper](  ) - The constructor takes no arguments.<br />
			[constructor:MMDPhysicsHelper MMDPhysicsHelper](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:MMDPhysicsHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:MMDPhysicsHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:MMDPhysicsHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:MMDPhysicsHelper clear](  ) - Removes all child objects.<br />
			[method:MMDPhysicsHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:MMDPhysicsHelper copy](  [param:MMDPhysicsHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:MMDPhysicsHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:MMDPhysicsHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:MMDPhysicsHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:MMDPhysicsHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:MMDPhysicsHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:MMDPhysicsHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:MMDPhysicsHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:MMDPhysicsHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:MMDPhysicsHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:MMDPhysicsHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:MMDPhysicsHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MMDPhysicsParameter">MMDPhysicsParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Vector3 gravity]? -  The gravity.<br />
			[property:number maxStepNum]? -  The max step num.<br />
			[property:number unitStep]? -  The unit step.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="MTLLoader">MTLLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MTLLoader MTLLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:MTLLoader MTLLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:MaterialCreatorOptions materialOptions] -  The material options.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:MaterialCreator parse](  [param:string text],  [param:string path] ) <br />
			[method:MTLLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:void setMaterialOptions](  [param:MaterialCreatorOptions value] ) <br />
			[method:MTLLoader setPath](  [param:string path] ) <br />
			[method:MTLLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:MTLLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:MTLLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:OrbitControls] &rarr;

		<h3 id="MapControls">MapControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MapControls MapControls](  [param:Camera object],  [param:HTMLElement domElement]? ) <br />
			[constructor:MapControls MapControls](  [param:Camera object],  [param:HTMLElement domElement]?,  [param:Camera object],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoRotate] -  The auto rotate.<br />
			[property:number autoRotateSpeed] -  The auto rotate speed.<br />
			[property:Vector3 center] -  The center.<br />
			[property:number dampingFactor] -  The damping factor.<br />
			[property:HTMLElement|HTMLDocument domElement] -  The dom element.<br />
			[property:boolean enableDamping] -  The enable damping.<br />
			[property:boolean enableKeys] -  The enable keys.<br />
			[property:boolean enablePan] -  The enable pan.<br />
			[property:boolean enableRotate] -  The enable rotate.<br />
			[property:boolean enableZoom] -  The enable zoom.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:number keyPanSpeed] -  The key pan speed.<br />
			[property:any keys] -  The keys.<br />
			[property:number maxAzimuthAngle] -  The max azimuth angle.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number maxPolarAngle] -  The max polar angle.<br />
			[property:number maxZoom] -  The max zoom.<br />
			[property:number minAzimuthAngle] -  The min azimuth angle.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:number minPolarAngle] -  The min polar angle.<br />
			[property:number minZoom] -  The min zoom.<br />
			[property:any mouseButtons] -  The mouse buttons.<br />
			[property:Camera object] -  The object.<br />
			[property:number panSpeed] -  The pan speed.<br />
			[property:number rotateSpeed] -  The rotate speed.<br />
			[property:boolean screenSpacePanning] -  The screen space panning.<br />
			[property:Vector3 target] -  The target.<br />
			[property:any touches] -  The touches.<br />
			[property:number zoomSpeed] -  The zoom speed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void dispatchEvent](  [param:any event] ) <br />
			[method:void dispose](  ) <br />
			[method:number getAzimuthalAngle](  ) <br />
			[method:number getDistance](  ) <br />
			[method:number getPolarAngle](  ) <br />
			[method:boolean hasEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void listenToKeyEvents](  [param:HTMLElement domElement] ) <br />
			[method:void removeEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void reset](  ) <br />
			[method:void saveState](  ) <br />
			[method:boolean update](  ) 
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="MarchingCubes">MarchingCubes <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MarchingCubes MarchingCubes](  [param:number resolution],  [param:Material material],  [param:boolean enableUvs]?,  [param:boolean enableColors]?,  [param:number maxPolyCount]? ) <br />
			[constructor:MarchingCubes MarchingCubes](  [param:number resolution],  [param:Material material],  [param:boolean enableUvs]?,  [param:boolean enableColors]?,  [param:number maxPolyCount]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:MarchingCubes MarchingCubes](  [param:number resolution],  [param:Material material],  [param:boolean enableUvs]?,  [param:boolean enableColors]?,  [param:number maxPolyCount]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:MarchingCubes MarchingCubes](  [param:number resolution],  [param:Material material],  [param:boolean enableUvs]?,  [param:boolean enableColors]?,  [param:number maxPolyCount]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Float32Array colorArray] -  The color array.<br />
			[property:number count] -  The count.<br />
			[property:number delta] -  The delta.<br />
			[property:boolean enableColors] -  The enable colors.<br />
			[property:boolean enableUvs] -  The enable uvs.<br />
			[property:Float32Array field] -  The field.<br />
			[property:number halfsize] -  The halfsize.<br />
			[property:boolean hasColors] -  The has colors.<br />
			[property:boolean hasNormals] -  The has normals.<br />
			[property:boolean hasPositions] -  The has positions.<br />
			[property:boolean hasUvs] -  The has uvs.<br />
			[property:number isolation] -  The isolation.<br />
			[property:number maxCount] -  The max count.<br />
			[property:Float32Array normalArray] -  The normal array.<br />
			[property:Float32Array normal_cache] -  The normal_cache.<br />
			[property:Float32Array palette] -  The palette.<br />
			[property:Float32Array positionArray] -  The position array.<br />
			[property:number resolution] -  The resolution.<br />
			[property:number size] -  The size.<br />
			[property:number size2] -  The size2.<br />
			[property:number size3] -  The size3.<br />
			[property:Float32Array uvArray] -  The uv array.<br />
			[property:number yd] -  The yd.<br />
			[property:number zd] -  The zd.
		</p>
		<h4>Methods</h4>
		<p>
			[method:MarchingCubes add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addBall](  [param:number ballx],  [param:number bally],  [param:number ballz],  [param:number strength],  [param:number subtract],  [param:Color colors]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addPlaneX](  [param:number strength],  [param:number subtract] ) <br />
			[method:void addPlaneY](  [param:number strength],  [param:number subtract] ) <br />
			[method:void addPlaneZ](  [param:number strength],  [param:number subtract] ) <br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:MarchingCubes applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:MarchingCubes attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:void begin](  ) <br />
			[method:void blur](  [param:number intensity] ) <br />
			[method:MarchingCubes clear](  ) - Removes all child objects.<br />
			[method:MarchingCubes clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:MarchingCubes copy](  [param:MarchingCubes source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void end](  ) <br />
			[method:BufferGeometry generateBufferGeometry](  ) <br />
			[method:BufferGeometry generateGeometry](  ) <br />
			[method:number getCell](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void init](  [param:number resolution] ) <br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:MarchingCubes remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:MarchingCubes removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:void render](  [param:any renderCallback] ) <br />
			[method:void reset](  ) <br />
			[method:MarchingCubes rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:MarchingCubes rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:MarchingCubes rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:MarchingCubes rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:MarchingCubes rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setCell](  [param:number x],  [param:number y],  [param:number z],  [param:number value] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:MarchingCubes translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:MarchingCubes translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:MarchingCubes translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:MarchingCubes translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="MaskPass">MaskPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MaskPass MaskPass](  [param:Scene scene],  [param:Camera camera] ) <br />
			[constructor:MaskPass MaskPass](  [param:Scene scene],  [param:Camera camera] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Camera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean inverse] -  The inverse.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:Scene scene] -  The scene.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="Material">Material <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Material Material](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:Material Material](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] - Value is the string 'Material'. This shouldn't be changed, and can be used to find all objects of this type in a scene.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:Material clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:Material copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MaterialParameters values] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			Materials describe the appearance of objects. They are defined in a (mostly) renderer-independent way, so you don't have to rewrite materials if you decide to use a different renderer.
		</p>

		<hr class="interface-line"/>
		<h3 id="MaterialCreatorOptions">MaterialCreatorOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean ignoreZeroRGBs]? -  The ignore zero r g bs.<br />
			[property:boolean invertTrProperty]? -  The invert tr property.<br />
			[property:boolean normalizeRGB]? -  The normalize r g b.<br />
			[property:Side side]? - side: Which side to apply the material<br />
			THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide<br />
			[property:Wrapping wrap]? -  The wrap.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MaterialInfo">MaterialInfo <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string bump]? -  The bump.<br />
			[property:number d]? -  The d.<br />
			[property:number[] kd]? -  The kd.<br />
			[property:number[] ke]? -  The ke.<br />
			[property:number[] ks]? -  The ks.<br />
			[property:string map_bump]? -  The map_bump.<br />
			[property:string map_d]? -  The map_d.<br />
			[property:string map_kd]? -  The map_kd.<br />
			[property:string map_ke]? -  The map_ke.<br />
			[property:string map_ks]? -  The map_ks.<br />
			[property:string norm]? -  The norm.<br />
			[property:number ns]? -  The ns.<br />
			[property:number tr]? -  The tr.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="MaterialLoader">MaterialLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MaterialLoader MaterialLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:MaterialLoader MaterialLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:any textures] -  The textures.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Material parse](  [param:any json] ) <br />
			[method:MaterialLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:MaterialLoader setPath](  [param:string path] ) <br />
			[method:MaterialLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:MaterialLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:MaterialLoader setTextures](  [param:any textures] ) <br />
			[method:MaterialLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MaterialParameters">MaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="MathNode">MathNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MathNode MathNode](  [param:NodeNode a],  [param:string|NodeNode bOrMethod],  [param:string|NodeNode cOrMethod]?,  [param:string method]? ) <br />
			[constructor:MathNode MathNode](  [param:NodeNode a],  [param:string|NodeNode bOrMethod],  [param:string|NodeNode cOrMethod]?,  [param:string method]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:MathNode MathNode](  [param:NodeNode a],  [param:string|NodeNode bOrMethod],  [param:string|NodeNode cOrMethod]?,  [param:string method]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string ABS] -  The a b s.<br />
			[property:string ACOS] -  The a c o s.<br />
			[property:string ARCTAN] -  The a r c t a n.<br />
			[property:string ASIN] -  The a s i n.<br />
			[property:string CEIL] -  The c e i l.<br />
			[property:string CLAMP] -  The c l a m p.<br />
			[property:string COS] -  The c o s.<br />
			[property:string CROSS] -  The c r o s s.<br />
			[property:string DEG] -  The d e g.<br />
			[property:string DISTANCE] -  The d i s t a n c e.<br />
			[property:string DOT] -  The d o t.<br />
			[property:string EXP] -  The e x p.<br />
			[property:string EXP2] -  The e x p2.<br />
			[property:string FACEFORWARD] -  The f a c e f o r w a r d.<br />
			[property:string FLOOR] -  The f l o o r.<br />
			[property:string INVERT] -  The i n v e r t.<br />
			[property:string INV_SQRT] -  The i n v_ s q r t.<br />
			[property:string LENGTH] -  The l e n g t h.<br />
			[property:string LOG] -  The l o g.<br />
			[property:string LOG2] -  The l o g2.<br />
			[property:string MAX] -  The m a x.<br />
			[property:string MIN] -  The m i n.<br />
			[property:string MIX] -  The m i x.<br />
			[property:string MOD] -  The m o d.<br />
			[property:string NEGATE] -  The n e g a t e.<br />
			[property:string NORMALIZE] -  The n o r m a l i z e.<br />
			[property:string POW] -  The p o w.<br />
			[property:string RAD] -  The r a d.<br />
			[property:string REFLECT] -  The r e f l e c t.<br />
			[property:string REFRACT] -  The r e f r a c t.<br />
			[property:string SATURATE] -  The s a t u r a t e.<br />
			[property:string SIGN] -  The s i g n.<br />
			[property:string SIN] -  The s i n.<br />
			[property:string SMOOTHSTEP] -  The s m o o t h s t e p.<br />
			[property:string SQRT] -  The s q r t.<br />
			[property:string STEP] -  The s t e p.<br />
			[property:string TAN] -  The t a n.<br />
			[property:NodeNode a] -  The a.<br />
			[property:string|NodeNode b] -  The b.<br />
			[property:string|NodeNode c] -  The c.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string method] -  The method.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:MathNode copy](  [param:MathNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:string getInputType](  [param:NodeBuilder builder] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:number getNumInputs](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:MathNode setLabel](  [param:string name] ) <br />
			[method:MathNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MathUtils">MathUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:number ceilPowerOfTwo](  [param:number value] ) - Returns : Returns the smallest power of 2 that is greater than or equal to [page:Number n].<br />
			[method:number clamp](  [param:number value],  [param:number min],  [param:number max] ) - Clamps the [page:Float value] to be between [page:Float min] and [page:Float max].<br />
			[method:number damp](  [param:number x],  [param:number y],  [param:number lambda],  [param:number dt] ) - Smoothly interpolate a number from [page:Float x] toward [page:Float y] in a spring-like manner using the [page:Float dt] to maintain frame rate independent movement.<br />
			For details, see [link:http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/ Frame rate independent damping using lerp].<br />
			[method:number degToRad](  [param:number degrees] ) - Converts degrees to radians.<br />
			[method:number euclideanModulo](  [param:number n],  [param:number m] ) <br />
			[method:number floorPowerOfTwo](  [param:number value] ) - Returns : Returns the largest power of 2 that is less than or equal to [page:Number n].<br />
			[method:string generateUUID](  ) - Generate a [link:https://en.wikipedia.org/wiki/Universally_unique_identifier UUID] (universally unique identifier).<br />
			[method:number inverseLerp](  [param:number x],  [param:number y],  [param:number t] ) - Returns : Returns the percentage in the closed interval [0, 1] of the given value between the start and end point.<br />
			[method:boolean isPowerOfTwo](  [param:number value] ) - Returns : Return *true* if [page:Number n] is a power of 2.<br />
			[method:number lerp](  [param:number x],  [param:number y],  [param:number t] ) - Returns : Returns a value [link:https://en.wikipedia.org/wiki/Linear_interpolation linearly interpolated] from two known points based on the given interval - [page:Float t] = 0 will return [page:Float x] and [page:Float t] = 1 will return [page:Float y].<br />
			[method:number mapLinear](  [param:number x],  [param:number a1],  [param:number a2],  [param:number b1],  [param:number b2] ) - Linear mapping of [page:Float x] from range [page:Float [a1], [page:Float a2]] to range [page:Float [b1], [page:Float b2]].<br />
			[method:number nearestPowerOfTwo](  [param:number value] ) - deprecated - Use {@link Math#floorPowerOfTwo .floorPowerOfTwo()}<br />
			[method:number nextPowerOfTwo](  [param:number value] ) - deprecated - Use {@link Math#ceilPowerOfTwo .ceilPowerOfTwo()}<br />
			[method:number pingpong](  [param:number x],  [param:number length]? ) - Returns : Returns a value that alternates between 0 and [param:Float length].<br />
			[method:number radToDeg](  [param:number radians] ) - Converts radians to degrees.<br />
			[method:number randFloat](  [param:number low],  [param:number high] ) - Random float in the interval<br />
			[method:number randFloatSpread](  [param:number range] ) - Random float from - range / 2 to range / 2 interval.<br />
			[method:number randInt](  [param:number low],  [param:number high] ) - Random integer from low to high interval.<br />
			[method:number random16](  ) - Random float from 0 to 1 with 16 bits of randomness.<br />
			Standard Math.random() creates repetitive patterns when applied over larger space.<br />
			<br />
			deprecated - Use {@link Math#random Math.random()}<br />
			[method:number seededRandom](  [param:number seed]? ) - Deterministic pseudo-random float in the interval [0, 1].<br />
			The integer *seed* is optional.<br />
			[method:void setQuaternionFromProperEuler](  [param:Quaternion q],  [param:number a],  [param:number b],  [param:number c],  [param:string order] ) - Rotations are applied to the axes in the order specified by [page:String order]: rotation by angle [page:Float a] is applied first, then by angle [page:Float b], then by angle [page:Float c]. Angles are in radians.<br />
			[method:number smootherstep](  [param:number x],  [param:number min],  [param:number max] ) - Returns : Returns a value between 0-1. A [link:https://en.wikipedia.org/wiki/Smoothstep#Variations variation on smoothstep] that has zero 1st and 2nd order derivatives at x=0 and x=1.<br />
			[method:number smoothstep](  [param:number x],  [param:number min],  [param:number max] ) - See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for details.<br />
			<br />
			Returns : Returns a value between 0-1 that represents the percentage that x has moved between min and max, but smoothed or slowed down the closer X is to the min and max.
		</p>

		<p class="desc">
			An object with several math utility functions.<br />
			<br />
			[link:https://github.com/mrdoob/three.js/blob/master/src/math/MathUtils.js src/math/MathUtils.js]
		</p>

		<hr class="interface-line"/>
		<h3 id="Matrix">Matrix <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] - Array with matrix values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Matrix clone](  ) - Creates a new Matrix4 with identical *.elements* to this one.<br />
			[method:Matrix copy](  [param:Matrix m] ) - Copies the *.elements* of matrix [page:Matrix m] into this matrix.<br />
			[method:number determinant](  ) - Computes and returns the [link:https://en.wikipedia.org/wiki/Determinant determinant] of this matrix.<br />
			[method:Matrix identity](  ) - Resets this matrix to the [link:https://en.wikipedia.org/wiki/Identity_matrix identity matrix].<br />
			[method:Matrix invert](  ) - Inverts this matrix, using the [link:https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution analytic method].<br />
			You can not invert with a determinant of zero. If you attempt this, the method produces a zero matrix instead.<br />
			[method:Matrix multiplyScalar](  [param:number s] ) - Multiplies every component of the matrix by a scalar value [page:Float s].<br />
			[method:Matrix transpose](  ) - [link:https://en.wikipedia.org/wiki/Transpose Transposes] this matrix.
		</p>

		<p class="desc">
			A class representing a [link:https://en.wikipedia.org/wiki/Matrix_(mathematics matrix]).
		</p>

		<hr class="interface-line"/>
		[page:Matrix] &rarr;

		<h3 id="Matrix3">Matrix3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Matrix3 Matrix3](  ) - Creates and initializes the Matrix3 to the 3x3<br />
			[link:https://en.wikipedia.org/wiki/Identity_matrix identity matrix].
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] - A [link:https://en.wikipedia.org/wiki/Row-_and_column-major_order column-major] list of matrix values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Matrix3 clone](  ) - Creates a new Matrix3 and with identical elements to this one.<br />
			[method:Matrix3 copy](  [param:Matrix3 m] ) - Copies the elements of matrix [page:Matrix3 m] into this matrix.<br />
			[method:number determinant](  ) - Computes and returns the [link:https://en.wikipedia.org/wiki/Determinant determinant] of this matrix.<br />
			[method:boolean equals](  [param:Matrix3 matrix] ) - Returns : Return true if this matrix and [page:Matrix3 m] are equal.<br />
			[method:Matrix3 extractBasis](  [param:Vector3 xAxis],  [param:Vector3 yAxis],  [param:Vector3 zAxis] ) - Extracts the [link:https://en.wikipedia.org/wiki/Basis_(linear_algebra basis]) of this matrix into the three axis vectors provided. If this matrix is:<br />
			a, b, c, d, e, f, g, h, i<br />
			then the [page:Vector3 xAxis], [page:Vector3 yAxis], [page:Vector3 zAxis] will be set to:<br />
			xAxis = (a, d, g)<br />
			yAxis = (b, e, h)<br />
			zAxis = (c, f, i)<br />
			[method:number[] flattenToArrayOffset](  [param:number[] array],  [param:number offset] ) - deprecated - Use {@link Matrix3#toArray .toArray()} instead.<br />
			[method:Matrix3 fromArray](  [param:ArrayLike|number[] array],  [param:number offset]? ) - Sets the elements of this matrix based on an array in [link:https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order column-major] format.<br />
			[method:Matrix3 getInverse](  [param:Matrix4 matrix],  [param:boolean throwOnDegenerate]? ) - deprecated - Use {@link Matrix3#invert .invert()} instead.<br />
			[method:Matrix getInverse](  [param:Matrix4 matrix],  [param:boolean throwOnDegenerate]?,  [param:Matrix matrix] ) <br />
			[method:Matrix3 getNormalMatrix](  [param:Matrix4 matrix4] ) - Sets this matrix as the upper left 3x3 of the [link:https://en.wikipedia.org/wiki/Normal_matrix normal matrix] of the passed [page:Matrix4 matrix4]. The normal matrix is the [link:https://en.wikipedia.org/wiki/Invertible_matrix inverse] [link:https://en.wikipedia.org/wiki/Transpose transpose] of the matrix [page:Matrix4 m].<br />
			[method:Matrix3 identity](  ) - Resets this matrix to the 3x3 identity matrix:<br />
			1, 0, 0<br />
			0, 1, 0<br />
			0, 0, 1<br />
			[method:Matrix3 invert](  ) - Inverts this matrix, using the [link:https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution analytic method].<br />
			You can not invert with a determinant of zero. If you attempt this, the method produces a zero matrix instead.<br />
			[method:Matrix3 multiply](  [param:Matrix3 m] ) - Post-multiplies this matrix by [page:Matrix3 m].<br />
			[method:Matrix3 multiplyMatrices](  [param:Matrix3 a],  [param:Matrix3 b] ) - Sets this matrix to [page:Matrix3 a] x [page:Matrix3 b].<br />
			[method:Matrix3 multiplyScalar](  [param:number s] ) - Multiplies every component of the matrix by a scalar value [page:Float s].<br />
			[method:Matrix3 multiplyScalar](  [param:number s],  [param:number s] ) - Multiplies every component of the matrix by the scalar value *s*.<br />
			[method:any multiplyVector3](  [param:Vector3 vector] ) - deprecated - Use {@link Vector3.applyMatrix3 vector.applyMatrix3( matrix )} instead.<br />
			[method:any multiplyVector3Array](  [param:any a] ) - deprecated - This method has been removed completely.<br />
			[method:Matrix3 premultiply](  [param:Matrix3 m] ) - Pre-multiplies this matrix by [page:Matrix3 m].<br />
			[method:Matrix3 rotate](  [param:number theta] ) <br />
			[method:Matrix3 scale](  [param:number sx],  [param:number sy] ) <br />
			[method:Matrix3 set](  [param:number n11],  [param:number n12],  [param:number n13],  [param:number n21],  [param:number n22],  [param:number n23],  [param:number n31],  [param:number n32],  [param:number n33] ) - Sets the 3x3 matrix values to the given [link:https://en.wikipedia.org/wiki/Row-_and_column-major_order row-major] sequence of values.<br />
			[method:Matrix3 setFromMatrix4](  [param:Matrix4 m] ) - Set this matrix to the upper 3x3 matrix of the Matrix4 [page:Matrix4 m].<br />
			[method:Matrix3 setUvTransform](  [param:number tx],  [param:number ty],  [param:number sx],  [param:number sy],  [param:number rotation],  [param:number cx],  [param:number cy] ) - Sets the UV transform matrix from offset, repeat, rotation, and center.<br />
			<br />
			Returns : uv transform<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Writes the elements of this matrix to an array in [link:https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order column-major] format.<br />
			[method:Matrix3 translate](  [param:number tx],  [param:number ty] ) <br />
			[method:Matrix3 transpose](  ) - [link:https://en.wikipedia.org/wiki/Transpose Transposes] this matrix in place.<br />
			[method:Matrix3 transposeIntoArray](  [param:number[] r] ) - [link:https://en.wikipedia.org/wiki/Transpose Transposes] this matrix into the supplied array, and returns itself unchanged.
		</p>

		<p class="desc">
			A class representing a 3x3 [link:https://en.wikipedia.org/wiki/Matrix_(mathematics matrix]).<br />
			<code data-type="javascript"><br />
			const m = new Matrix3();<br />
			</code><br />
			A Note on Row-Major and Column-Major Ordering<br />
			The [page:set set]() method takes arguments in [link:https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order row-major]<br />
			order, while internally they are stored in the *.elements* array in column-major order.<br />
			This means that calling m.set( 11, 12, 13, 21, 22, 23, 31, 32, 33 );<br />
			will result in the *.elements* array containing:<br />
			m.elements = [ 11, 21, 31, 12, 22, 32, 13, 23, 33 ];<br />
			and internally all calculations are performed using column-major ordering. However, as the actual ordering makes no difference mathematically and most people are used to thinking about matrices in row-major order,g the three.js documentation shows matrices in row-major order. Just bear in mind that if you are reading the source code, you'll have to take the [link:https://en.wikipedia.org/wiki/Transpose transpose] of any matrices outlined here to make sense of the calculations.
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="Matrix3Node">Matrix3Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Matrix3Node Matrix3Node](  [param:Matrix3 matrix]? ) <br />
			[constructor:Matrix3Node Matrix3Node](  [param:Matrix3 matrix]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Matrix3Node Matrix3Node](  [param:Matrix3 matrix]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Matrix3Node Matrix3Node](  [param:Matrix3 matrix]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] -  The elements.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Matrix3 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:Matrix3Node copy](  [param:Matrix3Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:Matrix3Node setLabel](  [param:string name] ) <br />
			[method:Matrix3Node setName](  [param:string name] ) <br />
			[method:Matrix3Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Matrix] &rarr;

		<h3 id="Matrix4">Matrix4 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Matrix4 Matrix4](  ) - Creates and initializes the [name] to the 4x4<br />
			[link:https://en.wikipedia.org/wiki/Identity_matrix identity matrix].
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] - A [link:https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order column-major] list of matrix values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Matrix4 clone](  ) - Creates a new Matrix4 with identical *.elements* to this one.<br />
			[method:Matrix4 compose](  [param:Vector3 translation],  [param:Quaternion rotation],  [param:Vector3 scale] ) - Sets this matrix to the transformation composed of [page:Vector3 position],<br />
			[page:Quaternion quaternion] and [page:Vector3 scale].<br />
			[method:Matrix4 copy](  [param:Matrix4 m] ) - Copies the *.elements* of matrix [page:Matrix4 m] into this matrix.<br />
			[method:Matrix4 copyPosition](  [param:Matrix4 m] ) - Copies the translation component of the supplied matrix [page:Matrix4 m] into this matrix's translation component.<br />
			[method:void crossVector](  [param:any v] ) - deprecated - Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.<br />
			[method:Matrix4 decompose](  [param:Vector3 translation],  [param:Quaternion rotation],  [param:Vector3 scale] ) - Decomposes this matrix into its [page:Vector3 position], [page:Quaternion quaternion] and [page:Vector3 scale] components.<br />
			Note: Not all matrices are decomposable in this way. For example, if an object has a non-uniformly scaled parent, then the object's world matrix may not be decomposable, and this method may not be appropriate.<br />
			[method:number determinant](  ) - Computes and returns the [link:https://en.wikipedia.org/wiki/Determinant determinant] of this matrix.<br />
			Based on the method outlined [link:http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm here].<br />
			[method:boolean equals](  [param:Matrix4 matrix] ) - Returns : Return true if this matrix and [page:Matrix4 m] are equal.<br />
			[method:Matrix4 extractBasis](  [param:Vector3 xAxis],  [param:Vector3 yAxis],  [param:Vector3 zAxis] ) - Extracts the [basis](https://en.wikipedia.org/wiki/Basis_(linear_algebra)) of this matrix into the three axis vectors provided. If this matrix is:<br />
			a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p<br />
			then the [page:Vector3 xAxis], [page:Vector3 yAxis], [page:Vector3 zAxis] will be set to:<br />
			<br />
			xAxis = (a, e, i)<br />
			yAxis = (b, f, j)<br />
			zAxis = (c, g, k)<br />
			<br />
			Returns : basis<br />
			[method:Matrix4 extractPosition](  [param:Matrix4 m] ) - deprecated - Use {@link Matrix4#copyPosition .copyPosition()} instead.<br />
			[method:Matrix4 extractRotation](  [param:Matrix4 m] ) - Extracts the rotation component of the supplied matrix [page:Matrix4 m] into this matrix's rotation component.<br />
			[method:number[] flattenToArrayOffset](  [param:number[] array],  [param:number offset] ) - deprecated - Use {@link Matrix4#toArray .toArray()} instead.<br />
			[method:Matrix4 fromArray](  [param:ArrayLike|number[] array],  [param:number offset]? ) - Sets the elements of this matrix based on an [page:Array array] in [link:https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order column-major] format.<br />
			[method:Matrix getInverse](  [param:Matrix matrix] ) - deprecated - Use {@link Matrix4#invert .invert()} instead.<br />
			[method:number getMaxScaleOnAxis](  ) - Gets the maximum scale value of the 3 axes.<br />
			[method:Matrix4 identity](  ) - Resets this matrix to the [link:https://en.wikipedia.org/wiki/Identity_matrix identity matrix].<br />
			[method:Matrix4 invert](  ) - Inverts this matrix, using the [link:https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution analytic method].<br />
			You can not invert with a determinant of zero. If you attempt this, the method produces a zero matrix instead.<br />
			[method:Matrix4 lookAt](  [param:Vector3 eye],  [param:Vector3 target],  [param:Vector3 up] ) - Constructs a rotation matrix, looking from [page:Vector3 eye] towards [page:Vector3 target]<br />
			oriented by the [page:Vector3 up] vector.<br />
			[method:Matrix4 makeBasis](  [param:Vector3 xAxis],  [param:Vector3 yAxis],  [param:Vector3 zAxis] ) - Set this to the [basis](https://en.wikipedia.org/wiki/Basis_(linear_algebra)) matrix consisting of the three provided basis vectors:<br />
			xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0,<br />
			0,       0,       0,       1<br />
			[method:Matrix4 makeOrthographic](  [param:number left],  [param:number right],  [param:number top],  [param:number bottom],  [param:number near],  [param:number far] ) - Creates an [link:https://en.wikipedia.org/wiki/Orthographic_projection orthographic projection] matrix.<br />
			This is used internally by [page:OrthographicCamera.updateProjectionMatrix OrthographicCamera.updateProjectionMatrix]().<br />
			[method:Matrix4 makePerspective](  [param:number left],  [param:number right],  [param:number bottom],  [param:number top],  [param:number near],  [param:number far] ) - Creates a [link:https://en.wikipedia.org/wiki/3D_projection#Perspective_projection perspective projection] matrix.<br />
			This is used internally by [page:PerspectiveCamera.updateProjectionMatrix PerspectiveCamera.updateProjectionMatrix]()<br />
			[method:Matrix4 makePerspective](  [param:number left],  [param:number right],  [param:number bottom],  [param:number top],  [param:number near],  [param:number far],  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far] ) - Creates a [link:https://en.wikipedia.org/wiki/3D_projection#Perspective_projection perspective projection] matrix.<br />
			This is used internally by [page:PerspectiveCamera.updateProjectionMatrix PerspectiveCamera.updateProjectionMatrix]()<br />
			[method:Matrix4 makeRotationAxis](  [param:Vector3 axis],  [param:number angle] ) - Sets this matrix as rotation transform around [page:Vector3 axis] by [page:Float theta] radians.<br />
			This is a somewhat controversial but mathematically sound alternative to rotating via [page:Quaternions Quaternions].<br />
			See the discussion [link:https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199 here].<br />
			[method:Matrix4 makeRotationFromEuler](  [param:Euler euler] ) <br />
			[method:Matrix4 makeRotationFromQuaternion](  [param:Quaternion q] ) - Sets the rotation component of this matrix to the rotation specified by [q](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Quaternion), as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion).<br />
			The rest of the matrix is set to the identity. So, given [q](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Quaternion) = w + xi + yj + zk, the resulting matrix will be:<br />
			1-2y-2z    2xy-2zw    2xz+2yw    0<br />
			2xy+2zw      1-2x-2z  2yz-2xw    0<br />
			2xz-2yw      2yz+2xw    1-2x-2y  0<br />
			0            0          0          1<br />
			[method:Matrix4 makeRotationX](  [param:number theta] ) - Sets this matrix as a rotational transformation around the X axis by [theta](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Float) (&theta;) radians.<br />
			The resulting matrix will be:<br />
			1 0      0        0<br />
			0 cos(&theta;) -sin(&theta;)  0<br />
			0 sin(&theta;) cos(&theta;)   0<br />
			0 0      0        1<br />
			[method:Matrix4 makeRotationY](  [param:number theta] ) - Sets this matrix as a rotational transformation around the Y axis by [theta](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Float) (&theta;) radians.<br />
			The resulting matrix will be:<br />
			cos(&theta;)  0 sin(&theta;) 0<br />
			0       1 0      0<br />
			-sin(&theta;) 0 cos(&theta;) 0<br />
			0       0 0      1<br />
			[method:Matrix4 makeRotationZ](  [param:number theta] ) - Sets this matrix as a rotational transformation around the Z axis by [page:Float theta] (&theta;) radians.<br />
			The resulting matrix will be:<br />
			cos(&theta;) -sin(&theta;) 0 0<br />
			sin(&theta;) cos(&theta;)  0 0<br />
			0      0       1 0<br />
			0      0       0 1<br />
			[method:Matrix4 makeScale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:Matrix4 makeShear](  [param:number xy],  [param:number xz],  [param:number yx],  [param:number yz],  [param:number zx],  [param:number zy] ) - Sets this matrix as a shear transform:<br />
			1,   yx,  zx,  0, xy,   1,  zy,  0, xz,  yz,   1,  0,<br />
			0,    0,   0,  1<br />
			[method:Matrix4 makeTranslation](  [param:number x],  [param:number y],  [param:number z] ) - Sets this matrix as a translation transform:<br />
			1, 0, 0, x,<br />
			0, 1, 0, y,<br />
			0, 0, 1, z,<br />
			0, 0, 0, 1<br />
			[method:Matrix4 multiply](  [param:Matrix4 m] ) - Post-multiplies this matrix by [page:Matrix4 m].<br />
			[method:Matrix4 multiplyMatrices](  [param:Matrix4 a],  [param:Matrix4 b] ) - Sets this matrix to [page:Matrix4 a] x [page:Matrix4 b].<br />
			[method:Matrix4 multiplyScalar](  [param:number s] ) - Multiplies every component of the matrix by a scalar value [page:Float s].<br />
			[method:Matrix4 multiplyToArray](  [param:Matrix4 a],  [param:Matrix4 b],  [param:number[] r] ) - Sets this matrix to a x b and stores the result into the flat array r.<br />
			r can be either a regular Array or a TypedArray.<br />
			<br />
			deprecated - This method has been removed completely.<br />
			[method:any multiplyVector3](  [param:any v] ) - deprecated - Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.<br />
			[method:number[] multiplyVector3Array](  [param:number[] array] ) - deprecated - This method has been removed completely.<br />
			[method:any multiplyVector4](  [param:any v] ) - deprecated - Use {@link Vector4#applyMatrix4 vector.applyMatrix4( matrix )} instead.<br />
			[method:Matrix4 premultiply](  [param:Matrix4 m] ) - Pre-multiplies this matrix by [page:Matrix4 m].<br />
			[method:void rotateAxis](  [param:any v] ) - deprecated - Use {@link Vector3#transformDirection Vector3.transformDirection( matrix )} instead.<br />
			[method:Matrix4 scale](  [param:Vector3 v] ) - Multiplies the columns of this matrix by vector [page:Vector3 v].<br />
			[method:Matrix4 set](  [param:number n11],  [param:number n12],  [param:number n13],  [param:number n14],  [param:number n21],  [param:number n22],  [param:number n23],  [param:number n24],  [param:number n31],  [param:number n32],  [param:number n33],  [param:number n34],  [param:number n41],  [param:number n42],  [param:number n43],  [param:number n44] ) - Set the *.elements* of this matrix to the supplied row-major values [page:Float n11],<br />
			[page:Float n12], ... [page:Float n44].<br />
			[method:Matrix4 setFromMatrix3](  [param:Matrix3 m] ) - Set the upper 3x3 elements of this matrix to the values of the Matrix3 [page:Matrix3 m].<br />
			[method:Matrix4 setPosition](  [param:number|Vector3 v],  [param:number y]?,  [param:number z]? ) - Sets the position component for this matrix from vector [page:Vector3 v], without affecting the rest of the matrix - i.e. if the matrix is currently:<br />
			a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p<br />
			This becomes:<br />
			a, b, c, v.x, e, f, g, v.y, i, j, k, v.z, m, n, o, p<br />
			[method:Matrix4 setRotationFromQuaternion](  [param:Quaternion q] ) - deprecated - Use {@link Matrix4#makeRotationFromQuaternion .makeRotationFromQuaternion()} instead.<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) <br />
			[method:Matrix4 transpose](  ) - [link:https://en.wikipedia.org/wiki/Transpose Transposes] this matrix.
		</p>

		<p class="desc">
			A class representing a 4x4 [matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)).<br />
			The most common use of a 4x4 matrix in 3D computer graphics is as a [Transformation Matrix](https://en.wikipedia.org/wiki/Transformation_matrix).a For an introduction to transformation matrices as used in WebGL, check out [this tutorial](http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices).<br />
			This allows a [Vector3](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Vector3) representing a point in 3D space to undergo transformations such as translation, rotation, shear, scale, reflection, orthogonal or perspective projection and so on, by being multiplied by the matrix. This is known as	&lt;em&gt;applying&lt;/em&gt; the matrix to the vector.<br />
			Every [Object3D](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Object3D) has three associated Matrix4s:<br />
			[Object3D.matrix](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Object3D.matrix): This stores the local transform of the object. This is the object's transformation relative to its parent.<br />
			[Object3D.matrixWorld](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Object3D.matrixWorld): The global or world transform of the object. If the object has no parent, then this is identical to the local transform stored in [matrix](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Object3D.matrix).<br />
			[Object3D.modelViewMatrix](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Object3D.modelViewMatrix): This represents the object's transformation relative to the camera's coordinate system.<br />
			An object's modelViewMatrix is the object's matrixWorld pre-multiplied by the camera's matrixWorldInverse.<br />
			[page:Camera Cameras] have three additional Matrix4s:<br />
			[page:Camera.matrixWorldInverse Camera.matrixWorldInverse]: The view matrix - the inverse of the Camera's [page:Object3D.matrixWorld matrixWorld].<br />
			[page:Camera.projectionMatrix Camera.projectionMatrix]: Represents the information how to project the scene to clip space.<br />
			[page:Camera.projectionMatrixInverse Camera.projectionMatrixInverse]: The inverse of projectionMatrix.<br />
			Note: [page:Object3D.normalMatrix Object3D.normalMatrix] is not a Matrix4, but a [page:Matrix3 Matrix3].<br />
			<br />
			A Note on Row-Major and Column-Major Ordering<br />
			The [page:set set]() method takes arguments in [link:https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order row-major]<br />
			order, while internally they are stored in the *.elements* array in column-major order.<br />
			This means that calling const m = new THREE.Matrix4();<br />
			m.set( 11, 12, 13, 14, 21, 22, 23, 24, 31, 32, 33, 34, 41, 42, 43, 44 );<br />
			will result in the *.elements* array containing:<br />
			m.elements = [ 11, 21, 31, 41, 12, 22, 32, 42, 13, 23, 33, 43, 14, 24, 34, 44 ];<br />
			and internally all calculations are performed using column-major ordering. However, as the actual ordering makes no difference mathematically and most people are used to thinking about matrices in row-major order,g the three.js documentation shows matrices in row-major order. Just bear in mind that if you are reading the source code, you'll have to take the [link:https://en.wikipedia.org/wiki/Transpose transpose] of any matrices outlined here to make sense of the calculations.<br />
			<br />
			Extracting position, rotation and scale<br />
			There are several options available for extracting position, rotation and scale from a Matrix4.<br />
			[page:Vector3.setFromMatrixPosition Vector3.setFromMatrixPosition]: can be used to extract the translation component.<br />
			[page:Vector3.setFromMatrixScale Vector3.setFromMatrixScale]: can be used to extract the scale component.<br />
			[page:Quaternion.setFromRotationMatrix Quaternion.setFromRotationMatrix], [page:Euler.setFromRotationMatrix Euler.setFromRotationMatrix] or *.extractRotation* can be used to extract the rotation component from a pure (unscaled) matrix.<br />
			*.decompose* can be used to extract position, rotation and scale all at once.
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="Matrix4Node">Matrix4Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Matrix4Node Matrix4Node](  [param:Matrix4 matrix]? ) <br />
			[constructor:Matrix4Node Matrix4Node](  [param:Matrix4 matrix]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Matrix4Node Matrix4Node](  [param:Matrix4 matrix]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Matrix4Node Matrix4Node](  [param:Matrix4 matrix]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] -  The elements.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Matrix4 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:Matrix4Node copy](  [param:Matrix4Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:Matrix4Node setLabel](  [param:string name] ) <br />
			[method:Matrix4Node setName](  [param:string name] ) <br />
			[method:Matrix4Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr; [page:FloatNode] &rarr;

		<h3 id="MaxMIPLevelNode">MaxMIPLevelNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MaxMIPLevelNode MaxMIPLevelNode](  [param:NodeNode texture] ) <br />
			[constructor:MaxMIPLevelNode MaxMIPLevelNode](  [param:NodeNode texture],  [param:number value]? ) <br />
			[constructor:MaxMIPLevelNode MaxMIPLevelNode](  [param:NodeNode texture],  [param:number value]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:MaxMIPLevelNode MaxMIPLevelNode](  [param:NodeNode texture],  [param:number value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:MaxMIPLevelNode MaxMIPLevelNode](  [param:NodeNode texture],  [param:number value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:number maxMIPLevel] -  The max m i p level.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:NodeNode texture] -  The texture.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:MaxMIPLevelNode copy](  [param:FloatNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:MaxMIPLevelNode setLabel](  [param:string name] ) <br />
			[method:MaxMIPLevelNode setName](  [param:string name] ) <br />
			[method:MaxMIPLevelNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Mesh">Mesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Mesh Mesh](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:Mesh Mesh](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - The constructor takes no arguments.<br />
			[constructor:Mesh Mesh](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:TGeometry geometry] - An instance of [page:BufferGeometry BufferGeometry] (or derived classes), defining the object's structure.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:TMaterial material] - An instance of material derived from the [page:Material Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial MeshBasicMaterial].<br />
			[property:any morphTargetDictionary]? - A dictionary of morphTargets based on the morphTarget.name property.<br />
			Undefined by default, but rebuilt [page:Mesh.updateMorphTargets updateMorphTargets].<br />
			[property:number[] morphTargetInfluences]? - An array of weights typically from 0-1 that specify how much of the morph is applied.<br />
			Undefined by default, but reset to a blank array by [page:Mesh.updateMorphTargets updateMorphTargets].<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Mesh add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Mesh applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Mesh attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Mesh clear](  ) - Removes all child objects.<br />
			[method:Mesh clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Mesh copy](  [param:Mesh source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:Mesh remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Mesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Mesh rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Mesh rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Mesh rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Mesh rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Mesh rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Mesh translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Mesh translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Mesh translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Mesh translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			Class representing triangular [link:https://en.wikipedia.org/wiki/Polygon_mesh polygon mesh] based objects.<br />
			Also serves as a base for other classes such as [page:SkinnedMesh SkinnedMesh].<br />
			<code data-type="javascript"><br />
			const geometry = new THREE.BoxGeometry( 1, 1, 1 );<br />
			const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );<br />
			const mesh = new THREE.Mesh( geometry, material );<br />
			scene.add( mesh );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="MeshBasicMaterial">MeshBasicMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshBasicMaterial MeshBasicMaterial](  [param:MeshBasicMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshBasicMaterial MeshBasicMaterial](  [param:MeshBasicMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshBasicMaterial MeshBasicMaterial](  [param:MeshBasicMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:Texture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:Combine combine] -  The combine.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:Texture envMap] -  The env map.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:Texture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:Texture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number reflectivity] -  The reflectivity.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:Texture specularMap] -  The specular map.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshBasicMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshBasicMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshBasicMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="MeshBasicMaterialParameters">MeshBasicMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:Texture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:Combine combine]? -  The combine.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:Texture envMap]? -  The env map.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:Texture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:Texture specularMap]? -  The specular map.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:string wireframeLinecap]? -  The wireframe linecap.<br />
			[property:string wireframeLinejoin]? -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			parameters is an object with one or more properties defining the material's appearance.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="MeshDepthMaterial">MeshDepthMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshDepthMaterial MeshDepthMaterial](  [param:MeshDepthMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshDepthMaterial MeshDepthMaterial](  [param:MeshDepthMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshDepthMaterial MeshDepthMaterial](  [param:MeshDepthMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:DepthPackingStrategies depthPacking] -  The depth packing.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:Texture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:Texture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshDepthMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshDepthMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshDepthMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="MeshDepthMaterialParameters">MeshDepthMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:DepthPackingStrategies depthPacking]? -  The depth packing.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:Texture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="MeshDistanceMaterial">MeshDistanceMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshDistanceMaterial MeshDistanceMaterial](  [param:MeshDistanceMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshDistanceMaterial MeshDistanceMaterial](  [param:MeshDistanceMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshDistanceMaterial MeshDistanceMaterial](  [param:MeshDistanceMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:Texture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:number farDistance] -  The far distance.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:Texture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:number nearDistance] -  The near distance.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Vector3 referencePosition] -  The reference position.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshDistanceMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshDistanceMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshDistanceMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="MeshDistanceMaterialParameters">MeshDistanceMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:Texture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:number farDistance]? -  The far distance.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number nearDistance]? -  The near distance.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Vector3 referencePosition]? -  The reference position.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="MeshLambertMaterial">MeshLambertMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshLambertMaterial MeshLambertMaterial](  [param:MeshLambertMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshLambertMaterial MeshLambertMaterial](  [param:MeshLambertMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshLambertMaterial MeshLambertMaterial](  [param:MeshLambertMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:Texture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:Combine combine] -  The combine.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:Color emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:Texture emissiveMap] -  The emissive map.<br />
			[property:Texture envMap] -  The env map.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:Texture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:Texture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number reflectivity] -  The reflectivity.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:Texture specularMap] -  The specular map.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshLambertMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshLambertMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshLambertMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="MeshLambertMaterialParameters">MeshLambertMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:Texture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:Combine combine]? -  The combine.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:ColorRepresentation emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:Texture emissiveMap]? -  The emissive map.<br />
			[property:Texture envMap]? -  The env map.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:Texture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:Texture specularMap]? -  The specular map.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:string wireframeLinecap]? -  The wireframe linecap.<br />
			[property:string wireframeLinejoin]? -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="MeshMatcapMaterial">MeshMatcapMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshMatcapMaterial MeshMatcapMaterial](  [param:MeshMatcapMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshMatcapMaterial MeshMatcapMaterial](  [param:MeshMatcapMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshMatcapMaterial MeshMatcapMaterial](  [param:MeshMatcapMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:Texture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:Texture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:Texture map] -  The map.<br />
			[property:Texture matcap] -  The matcap.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:Texture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshMatcapMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshMatcapMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshMatcapMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="MeshMatcapMaterialParameters">MeshMatcapMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:Texture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:Texture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture map]? -  The map.<br />
			[property:Texture matcap]? -  The matcap.<br />
			[property:string name]? -  The name.<br />
			[property:Texture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="MeshNormalMaterial">MeshNormalMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshNormalMaterial MeshNormalMaterial](  [param:MeshNormalMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshNormalMaterial MeshNormalMaterial](  [param:MeshNormalMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshNormalMaterial MeshNormalMaterial](  [param:MeshNormalMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:Texture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:Texture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:Texture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshNormalMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshNormalMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshNormalMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="MeshNormalMaterialParameters">MeshNormalMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:Texture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:Texture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string name]? -  The name.<br />
			[property:Texture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="MeshPhongMaterial">MeshPhongMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshPhongMaterial MeshPhongMaterial](  [param:MeshPhongMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshPhongMaterial MeshPhongMaterial](  [param:MeshPhongMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshPhongMaterial MeshPhongMaterial](  [param:MeshPhongMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:Texture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:Texture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:Combine combine] -  The combine.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:Texture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:Color emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:Texture emissiveMap] -  The emissive map.<br />
			[property:Texture envMap] -  The env map.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:Texture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:Texture map] -  The map.<br />
			[property:boolean metal] - deprecated - Use {@link MeshStandardMaterial THREE.MeshStandardMaterial} instead.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:Texture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number reflectivity] -  The reflectivity.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:number shininess] -  The shininess.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:Color specular] -  The specular.<br />
			[property:Texture specularMap] -  The specular map.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshPhongMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshPhongMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshPhongMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="MeshPhongMaterialParameters">MeshPhongMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:Texture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:Texture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? - geometry color in hexadecimal. Default is 0xffffff.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:Combine combine]? -  The combine.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:Texture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:ColorRepresentation emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:Texture emissiveMap]? -  The emissive map.<br />
			[property:Texture envMap]? -  The env map.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:Texture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:Texture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:number shininess]? -  The shininess.<br />
			[property:Side side]? -  The side.<br />
			[property:ColorRepresentation specular]? -  The specular.<br />
			[property:Texture specularMap]? -  The specular map.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:string wireframeLinecap]? -  The wireframe linecap.<br />
			[property:string wireframeLinejoin]? -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:MeshStandardMaterial] &rarr;

		<h3 id="MeshPhysicalMaterial">MeshPhysicalMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshPhysicalMaterial MeshPhysicalMaterial](  [param:MeshPhysicalMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshPhysicalMaterial MeshPhysicalMaterial](  [param:MeshPhysicalMaterialParameters parameters]?,  [param:MeshStandardMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshPhysicalMaterial MeshPhysicalMaterial](  [param:MeshPhysicalMaterialParameters parameters]?,  [param:MeshStandardMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshPhysicalMaterial MeshPhysicalMaterial](  [param:MeshPhysicalMaterialParameters parameters]?,  [param:MeshStandardMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:Texture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:Color attenuationColor] -  The attenuation color.<br />
			[property:number attenuationDistance] -  The attenuation distance.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:Texture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:number clearcoat] -  The clearcoat.<br />
			[property:Texture clearcoatMap] -  The clearcoat map.<br />
			[property:Texture clearcoatNormalMap] -  The clearcoat normal map.<br />
			[property:Vector2 clearcoatNormalScale] -  The clearcoat normal scale.<br />
			[property:number clearcoatRoughness] -  The clearcoat roughness.<br />
			[property:Texture clearcoatRoughnessMap] -  The clearcoat roughness map.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:Texture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:Color emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:Texture emissiveMap] -  The emissive map.<br />
			[property:Texture envMap] -  The env map.<br />
			[property:number envMapIntensity] -  The env map intensity.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:number ior] -  The ior.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isMeshStandardMaterial] -  The is mesh standard material.<br />
			[property:Texture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:Texture map] -  The map.<br />
			[property:number metalness] -  The metalness.<br />
			[property:Texture metalnessMap] -  The metalness map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:Texture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number reflectivity] -  The reflectivity.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:number roughness] -  The roughness.<br />
			[property:Texture roughnessMap] -  The roughness map.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:number sheen] -  The sheen.<br />
			[property:Color sheenColor] -  The sheen color.<br />
			[property:Texture sheenColorMap] -  The sheen color map.<br />
			[property:number sheenRoughness] -  The sheen roughness.<br />
			[property:Texture sheenRoughnessMap] -  The sheen roughness map.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:Color specularColor] -  The specular color.<br />
			[property:Texture specularColorMap] -  The specular color map.<br />
			[property:number specularIntensity] -  The specular intensity.<br />
			[property:Texture specularIntensityMap] -  The specular intensity map.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:number thickness] -  The thickness.<br />
			[property:Texture thicknessMap] -  The thickness map.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:number transmission] -  The transmission.<br />
			[property:Texture transmissionMap] -  The transmission map.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshPhysicalMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshPhysicalMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshStandardMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr; [page:MeshStandardMaterialParameters] &rarr;

		<h3 id="MeshPhysicalMaterialParameters">MeshPhysicalMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:Texture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:Color attenuationColor]? -  The attenuation color.<br />
			[property:number attenuationDistance]? -  The attenuation distance.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:Texture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:number clearcoat]? -  The clearcoat.<br />
			[property:Texture clearcoatMap]? -  The clearcoat map.<br />
			[property:Texture clearcoatNormalMap]? -  The clearcoat normal map.<br />
			[property:Vector2 clearcoatNormalScale]? -  The clearcoat normal scale.<br />
			[property:number clearcoatRoughness]? -  The clearcoat roughness.<br />
			[property:Texture clearcoatRoughnessMap]? -  The clearcoat roughness map.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:Texture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:ColorRepresentation emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:Texture emissiveMap]? -  The emissive map.<br />
			[property:Texture envMap]? -  The env map.<br />
			[property:number envMapIntensity]? -  The env map intensity.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:number ior]? -  The ior.<br />
			[property:Texture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:Texture map]? -  The map.<br />
			[property:number metalness]? -  The metalness.<br />
			[property:Texture metalnessMap]? -  The metalness map.<br />
			[property:string name]? -  The name.<br />
			[property:Texture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:number roughness]? -  The roughness.<br />
			[property:Texture roughnessMap]? -  The roughness map.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:number sheen]? -  The sheen.<br />
			[property:Color sheenColor]? -  The sheen color.<br />
			[property:number sheenRoughness]? -  The sheen roughness.<br />
			[property:Side side]? -  The side.<br />
			[property:Color specularColor]? -  The specular color.<br />
			[property:Texture specularColorMap]? -  The specular color map.<br />
			[property:number specularIntensity]? -  The specular intensity.<br />
			[property:Texture specularIntensityMap]? -  The specular intensity map.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:number transmission]? -  The transmission.<br />
			[property:Texture transmissionMap]? -  The transmission map.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="MeshStandardMaterial">MeshStandardMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshStandardMaterial MeshStandardMaterial](  [param:MeshStandardMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshStandardMaterial MeshStandardMaterial](  [param:MeshStandardMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshStandardMaterial MeshStandardMaterial](  [param:MeshStandardMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:Texture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:Texture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:Texture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:Color emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:Texture emissiveMap] -  The emissive map.<br />
			[property:Texture envMap] -  The env map.<br />
			[property:number envMapIntensity] -  The env map intensity.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isMeshStandardMaterial] -  The is mesh standard material.<br />
			[property:Texture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:Texture map] -  The map.<br />
			[property:number metalness] -  The metalness.<br />
			[property:Texture metalnessMap] -  The metalness map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:Texture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:number roughness] -  The roughness.<br />
			[property:Texture roughnessMap] -  The roughness map.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshStandardMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshStandardMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshStandardMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="MeshStandardMaterialParameters">MeshStandardMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:Texture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:Texture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:Texture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:ColorRepresentation emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:Texture emissiveMap]? -  The emissive map.<br />
			[property:Texture envMap]? -  The env map.<br />
			[property:number envMapIntensity]? -  The env map intensity.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:Texture map]? -  The map.<br />
			[property:number metalness]? -  The metalness.<br />
			[property:Texture metalnessMap]? -  The metalness map.<br />
			[property:string name]? -  The name.<br />
			[property:Texture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:number roughness]? -  The roughness.<br />
			[property:Texture roughnessMap]? -  The roughness map.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:StandardNode] &rarr;

		<h3 id="MeshStandardNode">MeshStandardNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshStandardNode MeshStandardNode](  ) <br />
			[constructor:MeshStandardNode MeshStandardNode](  ) <br />
			[constructor:MeshStandardNode MeshStandardNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any inputs] -  The inputs.<br />
			[property:any isNode] -  The is node.<br />
			[property:NodeNode metalness] -  The metalness.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:any properties] -  The properties.<br />
			[property:NodeNode roughness] -  The roughness.<br />
			[property:NodeNode sheenColor] -  The sheen color.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder] ) <br />
			[method:MeshStandardNode copy](  [param:StandardNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:MeshStandardNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:ShaderMaterial] &rarr; [page:NodeMaterial] &rarr;

		<h3 id="MeshStandardNodeMaterial">MeshStandardNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshStandardNodeMaterial MeshStandardNodeMaterial](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshStandardNodeMaterial MeshStandardNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshStandardNodeMaterial MeshStandardNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshStandardNodeMaterial MeshStandardNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshStandardNodeMaterial MeshStandardNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color|NodeNode color] -  The color.<br />
			[property:CubeTexture|NodeNode envMap] -  The env map.<br />
			[property:NodeNode|RawNode fragment] -  The fragment.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:Texture|NodeNode map] -  The map.<br />
			[property:number|NodeNode metalness] -  The metalness.<br />
			[property:Texture|NodeNode metalnessMap] -  The metalness map.<br />
			[property:Texture|NodeNode normalMap] -  The normal map.<br />
			[property:Vector2|NodeNode normalScale] -  The normal scale.<br />
			[property:object properties] -  The properties.<br />
			[property:number|NodeNode roughness] -  The roughness.<br />
			[property:Texture|NodeNode roughnessMap] -  The roughness map.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:NodeNode|RawNode vertex] -  The vertex.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshStandardNodeMaterial build](  [param:NodeMaterialBuildParams params]? ) <br />
			[method:MeshStandardNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshStandardNodeMaterial copy](  [param:NodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MeshSurfaceSampler">MeshSurfaceSampler <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshSurfaceSampler MeshSurfaceSampler](  [param:Mesh mesh] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Float32Array distribution] -  The distribution.<br />
			[property:BufferGeometry geometry] -  The geometry.<br />
			[property:Float32Array positionAttribute] -  The position attribute.<br />
			[property:string weightAttribute] -  The weight attribute.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number binarySearch](  [param:number x] ) <br />
			[method:MeshSurfaceSampler build](  ) <br />
			[method:MeshSurfaceSampler sample](  [param:Vector3 targetPosition],  [param:Vector3 targetNormal]?,  [param:Color targetColor]? ) <br />
			[method:MeshSurfaceSampler sampleFace](  [param:number faceIndex],  [param:Vector3 targetPosition],  [param:Vector3 targetNormal]?,  [param:Color targetColor]? ) <br />
			[method:MeshSurfaceSampler setWeightAttribute](  [param:string name] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="MeshToonMaterial">MeshToonMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MeshToonMaterial MeshToonMaterial](  [param:MeshToonMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshToonMaterial MeshToonMaterial](  [param:MeshToonMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:MeshToonMaterial MeshToonMaterial](  [param:MeshToonMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:Texture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:Texture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:Texture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:Color emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:Texture emissiveMap] -  The emissive map.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:Texture gradientMap] -  The gradient map.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:Texture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:Texture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:Texture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:MeshToonMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:MeshToonMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MeshToonMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="MeshToonMaterialParameters">MeshToonMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:Texture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:Texture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? - geometry color in hexadecimal. Default is 0xffffff.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:Texture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:ColorRepresentation emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:Texture emissiveMap]? -  The emissive map.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture gradientMap]? -  The gradient map.<br />
			[property:Texture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:Texture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:Texture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:string wireframeLinecap]? -  The wireframe linecap.<br />
			[property:string wireframeLinejoin]? -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MirrorShader">MirrorShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="MorphAnimMesh">MorphAnimMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MorphAnimMesh MorphAnimMesh](  [param:BufferGeometry geometry],  [param:Material material] ) <br />
			[constructor:MorphAnimMesh MorphAnimMesh](  [param:BufferGeometry geometry],  [param:Material material],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:MorphAnimMesh MorphAnimMesh](  [param:BufferGeometry geometry],  [param:Material material],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:MorphAnimMesh MorphAnimMesh](  [param:BufferGeometry geometry],  [param:Material material],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:AnimationAction activeAction] -  The active action.<br />
			[property:AnimationMixer mixer] -  The mixer.
		</p>
		<h4>Methods</h4>
		<p>
			[method:MorphAnimMesh add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:MorphAnimMesh applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:MorphAnimMesh attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:MorphAnimMesh clear](  ) - Removes all child objects.<br />
			[method:MorphAnimMesh clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:MorphAnimMesh copy](  [param:MorphAnimMesh source] ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void playAnimation](  [param:string label],  [param:number fps] ) <br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:MorphAnimMesh remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:MorphAnimMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:MorphAnimMesh rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:MorphAnimMesh rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:MorphAnimMesh rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:MorphAnimMesh rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:MorphAnimMesh rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setDirectionBackward](  ) <br />
			[method:void setDirectionForward](  ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:MorphAnimMesh translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:MorphAnimMesh translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:MorphAnimMesh translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:MorphAnimMesh translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateAnimation](  [param:number delta] ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="MorphBlendMesh">MorphBlendMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:MorphBlendMesh MorphBlendMesh](  [param:BufferGeometry geometry],  [param:Material material] ) <br />
			[constructor:MorphBlendMesh MorphBlendMesh](  [param:BufferGeometry geometry],  [param:Material material],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:MorphBlendMesh MorphBlendMesh](  [param:BufferGeometry geometry],  [param:Material material],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:MorphBlendMesh MorphBlendMesh](  [param:BufferGeometry geometry],  [param:Material material],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:object[] animationsList] -  The animations list.<br />
			[property:object animationsMap] -  The animations map.
		</p>
		<h4>Methods</h4>
		<p>
			[method:MorphBlendMesh add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:MorphBlendMesh applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:MorphBlendMesh attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:void autoCreateAnimations](  [param:number fps] ) <br />
			[method:MorphBlendMesh clear](  ) - Removes all child objects.<br />
			[method:MorphBlendMesh clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:MorphBlendMesh copy](  [param:MorphBlendMesh source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void createAnimation](  [param:string name],  [param:number start],  [param:number end],  [param:number fps] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:number getAnimationDuration](  [param:string name] ) <br />
			[method:number getAnimationTime](  [param:string name] ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void playAnimation](  [param:string name] ) <br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:MorphBlendMesh remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:MorphBlendMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:MorphBlendMesh rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:MorphBlendMesh rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:MorphBlendMesh rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:MorphBlendMesh rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:MorphBlendMesh rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setAnimationDirectionBackward](  [param:string name] ) <br />
			[method:void setAnimationDirectionForward](  [param:string name] ) <br />
			[method:void setAnimationDuration](  [param:string name],  [param:number duration] ) <br />
			[method:void setAnimationFPS](  [param:string name],  [param:number fps] ) <br />
			[method:void setAnimationTime](  [param:string name],  [param:number time] ) <br />
			[method:void setAnimationWeight](  [param:string name],  [param:number weight] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:void stopAnimation](  [param:string name] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:MorphBlendMesh translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:MorphBlendMesh translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:MorphBlendMesh translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:MorphBlendMesh translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  [param:number delta] ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="MorphTarget">MorphTarget <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string name] -  The name.<br />
			[property:Vector3[] vertices] -  The vertices.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NRRDLoader">NRRDLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NRRDLoader NRRDLoader](  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object fieldFunctions] -  The field functions.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Volume parse](  [param:string data] ) <br />
			[method:string parseChars](  [param:number[] array],  [param:number start]?,  [param:number end]? ) <br />
			[method:NRRDLoader setPath](  [param:string value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="NURBSCurve">NURBSCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NURBSCurve NURBSCurve](  [param:number degree],  [param:number[] knots],  [param:Vector3[]|Vector2[]|Vector4[] controlPoints],  [param:number startKnot],  [param:number endKnot] ) <br />
			[constructor:NURBSCurve NURBSCurve](  [param:number degree],  [param:number[] knots],  [param:Vector3[]|Vector2[]|Vector4[] controlPoints],  [param:number startKnot],  [param:number endKnot] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:NURBSCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:NURBSCurve copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:NURBSCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector3 getPoint](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getPointAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector3 getTangent](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getTangentAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NURBSSurface">NURBSSurface <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NURBSSurface NURBSSurface](  [param:number degree1],  [param:number degree2],  [param:number[] knots1],  [param:number[] knots2],  [param: controlPoints] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void getPoint](  [param:number t1],  [param:number t2],  [param:Vector3 target] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NURBSUtils">NURBSUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:Vector4[] calcBSplineDerivatives](  [param:number p],  [param:number[] U],  [param:Vector4[] P],  [param:number u],  [param:number nd] ) <br />
			[method:Vector4 calcBSplinePoint](  [param:number p],  [param:number[] U],  [param:Vector4[] P],  [param:number u] ) <br />
			[method:void calcBasisFunctionDerivatives](  [param:number span],  [param:number u],  [param:number p],  [param:number n],  [param:number[] U] ) <br />
			[method:number[] calcBasisFunctions](  [param:number span],  [param:number u],  [param:number p],  [param:number[] U] ) <br />
			[method:number calcKoverI](  [param:number k],  [param:number i] ) <br />
			[method:Vector3[] calcNURBSDerivatives](  [param:number p],  [param:number[] U],  [param:Vector4[] P],  [param:number u],  [param:number nd] ) <br />
			[method:Vector3[] calcRationalCurveDerivatives](  [param:Vector4[] Pders] ) <br />
			[method:Vector3 calcSurfacePoint](  [param:number p],  [param:number q],  [param:number[] U],  [param:number[] V],  [param:Vector4[] P],  [param:number u],  [param:number v],  [param:Vector3 target] ) <br />
			[method:number findSpan](  [param:number p],  [param:number u],  [param:number[] U] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Navigator">Navigator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XR xr]? -  The xr.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Node">Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Node[] children] -  The children.<br />
			[property:number expressID] -  The express i d.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeBuilder">NodeBuilder <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NodeBuilder NodeBuilder](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean analyzing] -  The analyzing.<br />
			[property:object attributes] -  The attributes.<br />
			[property:string[] caches] -  The caches.<br />
			[property:any code] -  The code.<br />
			[property:object[] contexts] -  The contexts.<br />
			[property:object defines] -  The defines.<br />
			[property:object extensions] -  The extensions.<br />
			[property:any finalCode] -  The final code.<br />
			[property:any includes] -  The includes.<br />
			[property:any inputs] -  The inputs.<br />
			[property:object keywords] -  The keywords.<br />
			[property:any nodeCode] -  The node code.<br />
			[property:object nodeData] -  The node data.<br />
			[property:object[] nodes] -  The nodes.<br />
			[property:any parsCode] -  The pars code.<br />
			[property:string prefixCode] -  The prefix code.<br />
			[property:any requires] -  The requires.<br />
			[property:any resultCode] -  The result code.<br />
			[property:string[] slots] -  The slots.<br />
			[property:object uniforms] -  The uniforms.<br />
			[property:object[] updaters] -  The updaters.
		</p>
		<h4>Methods</h4>
		<p>
			[method:NodeBuilder addCache](  [param:string name] ) <br />
			[method:void addCode](  [param:string code],  [param:string shader]? ) <br />
			[method:NodeBuilder addContext](  [param:object context] ) <br />
			[method:void addFinalCode](  [param:string code],  [param:string shader]? ) <br />
			[method:NodeBuilder addFlow](  [param:string slot],  [param:string cache]?,  [param:object context]? ) <br />
			[method:void addFragmentCode](  [param:string code] ) <br />
			[method:void addFragmentFinalCode](  [param:string code] ) <br />
			[method:void addFragmentNodeCode](  [param:string code] ) <br />
			[method:void addFragmentParsCode](  [param:string code] ) <br />
			[method:void addNodeCode](  [param:string code],  [param:string shader]? ) <br />
			[method:void addParsCode](  [param:string code],  [param:string shader]? ) <br />
			[method:NodeBuilder addSlot](  [param:string name] ) <br />
			[method:void addVaryCode](  [param:string code] ) <br />
			[method:void addVertexCode](  [param:string code] ) <br />
			[method:void addVertexFinalCode](  [param:string code] ) <br />
			[method:void addVertexNodeCode](  [param:string code] ) <br />
			[method:void addVertexParsCode](  [param:string code] ) <br />
			[method:NodeBuilder build](  [param:NodeNode vertex],  [param:NodeNode fragment] ) <br />
			[method:void buildShader](  [param:string shader],  [param:NodeNode node] ) <br />
			[method:string clearFragmentNodeCode](  ) <br />
			[method:string clearNodeCode](  [param:string shader] ) <br />
			[method:string clearVertexNodeCode](  ) <br />
			[method:string colorToVector](  [param:string color] ) <br />
			[method:string colorToVectorProperties](  [param:string color] ) <br />
			[method:NodeUniform createFragmentUniform](  [param:string type],  [param:NodeNode node],  [param:string ns]?,  [param:boolean needsUpdate]?,  [param:string label]? ) <br />
			[method:NodeUniform createUniform](  [param:string shader],  [param:string type],  [param:NodeNode node],  [param:string ns]?,  [param:boolean needsUpdate]?,  [param:string label]? ) <br />
			[method:NodeUniform createVertexUniform](  [param:string type],  [param:NodeNode node],  [param:string ns]?,  [param:boolean needsUpdate]?,  [param:string label]? ) <br />
			[method:void define](  [param:string name],  [param:any value] ) <br />
			[method:NodeNode findNode](  ) <br />
			[method:string format](  [param:string code],  [param:string from],  [param:string to] ) <br />
			[method:any getAttribute](  [param:string name],  [param:string type] ) <br />
			[method:string getCode](  [param:string shader] ) <br />
			[method:string getConstructorFromLength](  [param:number len] ) <br />
			[method:string getElementByIndex](  [param:number index] ) <br />
			[method:string getFormatByType](  [param:string type] ) <br />
			[method:object[] getIncludes](  [param:string type],  [param:string shader] ) <br />
			[method:string getIncludesCode](  [param:string type],  [param:string shader] ) <br />
			[method:number getIndexByElement](  [param:string elm] ) <br />
			[method:object getNodeData](  [param:NodeNode node] ) <br />
			[method:TextureEncoding getTextureEncodingFromMap](  [param:Texture map] ) <br />
			[method:string getTypeByFormat](  [param:string format] ) <br />
			[method:string getTypeFromLength](  [param:number len] ) <br />
			[method:number getTypeLength](  [param:string type] ) <br />
			[method:string getUuid](  [param:string uuid],  [param:boolean useCache]? ) <br />
			[method:object getVar](  [param:string uuid],  [param:string type],  [param:string ns],  [param:string labelOrShader]?,  [param:string prefix]?,  [param:string label]? ) <br />
			[method:string getVarListCode](  [param:object[] vars],  [param:string prefix]? ) <br />
			[method:object[] getVars](  [param:string shader] ) <br />
			[method:void include](  [param:NodeNode node],  [param:boolean parent]?,  [param:string source]? ) <br />
			[method:boolean isCache](  [param:string name] ) <br />
			[method:boolean isDefined](  [param:string name] ) <br />
			[method:boolean isShader](  [param:string shader] ) <br />
			[method:boolean isSlot](  [param:string name] ) <br />
			[method:boolean isTypeMatrix](  [param:string format] ) <br />
			[method:object mergeDefines](  [param:object defines] ) <br />
			[method:object mergeUniform](  [param:object uniforms] ) <br />
			[method:NodeBuilder removeCache](  ) <br />
			[method:NodeBuilder removeContext](  ) <br />
			[method:NodeBuilder removeFlow](  ) <br />
			[method:NodeBuilder removeSlot](  ) <br />
			[method:void resolve](  ) <br />
			[method:NodeBuilder setMaterial](  [param:Material material],  [param:WebGLRenderer renderer] ) <br />
			[method:NodeBuilder setShader](  [param:string shader] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeFlow">NodeFlow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string code] -  The code.<br />
			[property:object extra] -  The extra.<br />
			[property:string result] -  The result.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeFrame">NodeFrame <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NodeFrame NodeFrame](  [param:number time] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number delta] -  The delta.<br />
			[property:number id] -  The id.<br />
			[property:Texture renderTexture] -  The render texture.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:number time] -  The time.
		</p>
		<h4>Methods</h4>
		<p>
			[method:NodeFrame setRenderTexture](  [param:Texture renderTexture] ) <br />
			[method:NodeFrame setRenderer](  [param:WebGLRenderer renderer] ) <br />
			[method:NodeFrame update](  [param:number delta] ) <br />
			[method:NodeFrame updateNode](  [param:NodeNode node] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeLib">NodeLib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:object keywords] -  The keywords.<br />
			[property:object nodes] -  The nodes.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void add](  [param:NodeNode node] ) <br />
			[method:void addKeyword](  [param:string name],  [param:any callback],  [param:object cache]? ) <br />
			[method:boolean contains](  [param:string name] ) <br />
			[method:boolean containsKeyword](  [param:string name] ) <br />
			[method:NodeNode get](  [param:string name] ) <br />
			[method:any getKeyword](  [param:string name],  [param:NodeBuilder builder] ) <br />
			[method:NodeLibKeyword getKeywordData](  [param:string name] ) <br />
			[method:void remove](  [param:NodeNode node] ) <br />
			[method:void removeKeyword](  [param:string name] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeLibKeyword">NodeLibKeyword <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:object cache]? -  The cache.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void callback](  [param:NodeBuilder builder] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:ShaderMaterial] &rarr;

		<h3 id="NodeMaterial">NodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NodeMaterial NodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:NodeMaterial NodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:NodeMaterial NodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:NodeMaterial NodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode|RawNode fragment] -  The fragment.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:object properties] -  The properties.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:NodeNode|RawNode vertex] -  The vertex.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:NodeMaterial build](  [param:NodeMaterialBuildParams params]? ) <br />
			[method:NodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:NodeMaterial copy](  [param:NodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeMaterialBuildParams">NodeMaterialBuildParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:NodeBuilder builder]? -  The builder.<br />
			[property:WebGLRenderer renderer]? -  The renderer.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="NodeMaterialLoader">NodeMaterialLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NodeMaterialLoader NodeMaterialLoader](  [param:LoadingManager manager]?,  [param:any library]? ) <br />
			[constructor:NodeMaterialLoader NodeMaterialLoader](  [param:LoadingManager manager]?,  [param:any library]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:any getNode](  [param:string uuid] ) <br />
			[method:any getObjectById](  [param:string uuid] ) <br />
			[method:any getObjectByName](  [param:string uuid] ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:any resolve](  [param:any json] ) <br />
			[method:NodeMaterialLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:NodeMaterialLoader setPath](  [param:string path] ) <br />
			[method:NodeMaterialLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:NodeMaterialLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:NodeMaterialLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeNode">NodeNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NodeNode NodeNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:NodeNode copy](  [param:NodeNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:NodeNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr; [page:ShaderPass] &rarr;

		<h3 id="NodePass">NodePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NodePass NodePass](  ) <br />
			[constructor:NodePass NodePass](  [param:object shader],  [param:string textureID]? ) <br />
			[constructor:NodePass NodePass](  [param:object shader],  [param:string textureID]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ScreenNode input] -  The input.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:NodePass copy](  [param:NodePass source] ) <br />
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodePostProcessing">NodePostProcessing <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NodePostProcessing NodePostProcessing](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget renderTarget]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:OrthographicCamera camera] -  The camera.<br />
			[property:NodeMaterial material] -  The material.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:ScreenNode output] -  The output.<br />
			[property:Mesh quad] -  The quad.<br />
			[property:WebGLRenderTarget renderTarget] -  The render target.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:Scene scene] -  The scene.
		</p>
		<h4>Methods</h4>
		<p>
			[method:NodePostProcessing copy](  [param:NodePostProcessing source] ) <br />
			[method:void render](  [param:Scene scene],  [param:Camera camera],  [param:NodeFrame frame] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeUniform">NodeUniform <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NodeUniform NodeUniform](  [param:NodeUniformParams params]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:NodeNode node] -  The node.<br />
			[property:string type] -  The type.<br />
			[property:any value] -  The value.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeUniformParams">NodeUniformParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string name]? -  The name.<br />
			[property:boolean needsUpdate]? -  The needs update.<br />
			[property:NodeNode node]? -  The node.<br />
			[property:string type]? -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NodeUtils">NodeUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string[] elements] -  The elements.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addShortcuts](  [param:NodeNode proto],  [param:string proxy],  [param:any[] list] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="NoiseNode">NoiseNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NoiseNode NoiseNode](  [param:UVNode|UVTransformNode uv]? ) <br />
			[constructor:NoiseNode NoiseNode](  [param:UVNode|UVTransformNode uv]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:NoiseNode NoiseNode](  [param:UVNode|UVTransformNode uv]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:UVNode|UVTransformNode uv] -  The uv.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:NoiseNode copy](  [param:NoiseNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:NoiseNode setLabel](  [param:string name] ) <br />
			[method:NoiseNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="NormalMapNode">NormalMapNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NormalMapNode NormalMapNode](  [param:TextureNode value],  [param:Vector2Node scale]? ) <br />
			[constructor:NormalMapNode NormalMapNode](  [param:TextureNode value],  [param:Vector2Node scale]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:NormalMapNode NormalMapNode](  [param:TextureNode value],  [param:Vector2Node scale]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:Vector2Node scale] -  The scale.<br />
			[property:boolean shared] -  The shared.<br />
			[property:boolean toNormalMap] -  The to normal map.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:TextureNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:NormalMapNode copy](  [param:NormalMapNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:NormalMapNode setLabel](  [param:string name] ) <br />
			[method:NormalMapNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="NormalMapShader">NormalMapShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="NormalNode">NormalNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NormalNode NormalNode](  [param:string scope]? ) <br />
			[constructor:NormalNode NormalNode](  [param:string scope]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:NormalNode NormalNode](  [param:string scope]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string LOCAL] -  The l o c a l.<br />
			[property:string WORLD] -  The w o r l d.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:NormalNode copy](  [param:NormalNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:NormalNode setLabel](  [param:string name] ) <br />
			[method:NormalNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:KeyframeTrack] &rarr;

		<h3 id="NumberKeyframeTrack">NumberKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:NumberKeyframeTrack NumberKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) <br />
			[constructor:NumberKeyframeTrack NumberKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]?,  [param:string name],  [param:ArrayLike times],  [param:ArrayLike values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:LinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:CubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:NumberKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:KeyframeTrack optimize](  ) <br />
			[method:KeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:KeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:KeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:any toJSON](  [param:KeyframeTrack track] ) <br />
			[method:KeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="OBJExporter">OBJExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OBJExporter OBJExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:string parse](  [param:Object3D object] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="OBJLoader">OBJLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OBJLoader OBJLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:OBJLoader OBJLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:MaterialCreator materials] -  The materials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Group parse](  [param:string data] ) <br />
			[method:OBJLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:OBJLoader setMaterials](  [param:MaterialCreator materials] ) <br />
			[method:OBJLoader setPath](  [param:string path] ) <br />
			[method:OBJLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:OBJLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:OBJLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="Object3D">Object3D <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Object3D Object3D](  ) - The constructor takes no arguments.<br />
			[constructor:Object3D Object3D](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean DefaultMatrixAutoUpdate] - The default setting for *.matrixAutoUpdate* for newly created Object3Ds.<br />
			[property:Vector3 DefaultUp] - The default *.up* direction for objects, also used as the default position for [page:DirectionalLight DirectionalLight],<br />
			[page:HemisphereLight HemisphereLight] and [page:Spotlight Spotlight] (which creates lights shining from the top down).<br />
			Set to ( 0, 1, 0 ) by default.<br />
			[property:AnimationClip[] animations] - Array with object's animation clips.<br />
			[property:boolean castShadow] - Whether the object gets rendered into shadow map. Default is *false*.<br />
			[property:Object3D[] children] - Array with object's children. See [page:Group Group] for info on manually grouping objects.<br />
			[property:Material customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a [page:DirectionalLight DirectionalLight] or [page:SpotLight SpotLight], if you are modifying vertex positions in the vertex shader you must specify a customDepthMaterial for proper shadows. Default is *undefined*.<br />
			[property:Material customDistanceMaterial] - Same as *.customDepthMaterial*, but used with [page:PointLight PointLight]. Default is *undefined*.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object. If set to `false` the object gets rendered every frame even if it is not in the frustum of the camera. Default is `true`.<br />
			[property:BufferGeometry geometry]? - The BufferGeometry<br />
			[property:number id] - readonly  Unique number for this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:Layers layers] - The layer membership of the object. The object is only visible if it has at least one layer in common with the [page:Camera Camera] in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using [page:Raycaster Raycaster].<br />
			[property:Material|Material[] material]? - The Material<br />
			[property:Matrix4 matrix] - The local transform matrix.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also recalculates the matrixWorld property. Default is [page:Object3D.DefaultMatrixAutoUpdate Object3D.DefaultMatrixAutoUpdate] (true).<br />
			[property:Matrix4 matrixWorld] - The global transform of the object. If the Object3D has no parent, then it's identical to the local transform *.matrix*.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property  to false. Default is *false*.<br />
			[property:Matrix4 modelViewMatrix] - This is passed to the shader and used to calculate the position of the object.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique). Default is an empty string.<br />
			[property:Matrix3 normalMatrix] - This is passed to the shader and used to calculate lighting for the object. It is the transpose of the inverse of the upper left 3x3 sub-matrix of this object's modelViewMatrix.<br />
			The reason for this special matrix is that simply using the modelViewMatrix could result in a non-unit length of normals (on scaling) or in a non-perpendicular direction (on non-uniform scaling).<br />
			On the other hand the translation part of the modelViewMatrix is not relevant for the calculation of normals. Thus a Matrix3 is sufficient.<br />
			[property:Object3D parent] - Object's parent in the [link:https://en.wikipedia.org/wiki/Scene_graph scene graph]. An object can have at most one parent.<br />
			[property:Vector3 position] - A [page:Vector3 Vector3] representing the object's local position. Default is (0, 0, 0).<br />
			[property:Quaternion quaternion] - Object's local rotation as a [page:Quaternion Quaternion].<br />
			[property:boolean receiveShadow] - Whether the material receives shadows. Default is *false*.<br />
			[property:number renderOrder] - This value allows the default rendering order of [link:https://en.wikipedia.org/wiki/Scene_graph scene graph]<br />
			objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of [page:Group Group], all descendants objects will be sorted and rendered together.<br />
			Sorting is from lowest to highest renderOrder. Default value is *0*.<br />
			[property:Euler rotation] - Object's local rotation (see [link:https://en.wikipedia.org/wiki/Euler_angles Euler angles]), in radians.<br />
			[property:Vector3 scale] - The object's local scale. Default is [page:Vector3 Vector3]( 1, 1, 1 ).<br />
			[property:string type] -  The type.<br />
			[property:Vector3 up] - This is used by the *.lookAt* method, for example, to determine the orientation of the result.<br />
			Default is [page:Object3D.DefaultUp Object3D.DefaultUp] - that is, ( 0, 1, 0 ).<br />
			[property:any userData] - An object that can be used to store custom data about the Object3D. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - [link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID] of this object instance.<br />
			This gets automatically assigned, so this shouldn't be edited.<br />
			[property:boolean visible] - Object gets rendered if *true*. Default is *true*.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Object3D add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Object3D applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Object3D attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Object3D clear](  ) - Removes all child objects.<br />
			[method:Object3D clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Object3D copy](  [param:Object3D source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:E event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:Object3D remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Object3D removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Object3D rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Object3D rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Object3D rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Object3D rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Object3D rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Object3D translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Object3D translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Object3D translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Object3D translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			This is the base class for most objects in three.js and provides a set of properties and methods for manipulating objects in 3D space.<br />
			Note that this can be used for grouping objects via the *.add*( object ) method which adds the object as a child, however it is better to use [page:Group Group] for this.
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="ObjectLoader">ObjectLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ObjectLoader ObjectLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:ObjectLoader ObjectLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:T parse](  [param:any json],  [param:any onLoad]? ) <br />
			[method:AnimationClip[] parseAnimations](  [param:any json] ) <br />
			[method:Promise parseAsync](  [param:any json] ) <br />
			[method:void parseGeometries](  [param:any json] ) <br />
			[method:void parseImages](  [param:any json],  [param:any onLoad] ) <br />
			[method:Promise parseImagesAsync](  [param:any json] ) <br />
			[method:Material[] parseMaterials](  [param:any json],  [param:Texture[] textures] ) <br />
			[method:T parseObject](  [param:any data],  [param:any[] geometries],  [param:Material[] materials],  [param:AnimationClip[] animations] ) <br />
			[method:Texture[] parseTextures](  [param:any json],  [param:any images] ) <br />
			[method:ObjectLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ObjectLoader setPath](  [param:string path] ) <br />
			[method:ObjectLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ObjectLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ObjectLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:PolyhedronGeometry] &rarr;

		<h3 id="OctahedronBufferGeometry">OctahedronBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OctahedronGeometry OctahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:OctahedronGeometry OctahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:OctahedronGeometry OctahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:OctahedronGeometry OctahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:OctahedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:OctahedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:PolyhedronGeometry] &rarr;

		<h3 id="OctahedronGeometry">OctahedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OctahedronGeometry OctahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:OctahedronGeometry OctahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:OctahedronGeometry OctahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:OctahedronGeometry OctahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:OctahedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:OctahedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Octree">Octree <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Octree Octree](  [param:Box3 box]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Box3 box] -  The box.<br />
			[property:Octree[] subTrees] -  The sub trees.<br />
			[property:Triangle[] triangles] -  The triangles.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Octree addTriangle](  [param:Triangle triangle] ) <br />
			[method:Octree build](  ) <br />
			[method:Octree calcBox](  ) <br />
			[method:any capsuleIntersect](  [param:Capsule capsule] ) <br />
			[method:Octree fromGraphNode](  [param:Object3D group] ) <br />
			[method:Triangle[] getCapsuleTriangles](  [param:Capsule capsule],  [param:Triangle[] triangles] ) <br />
			[method:Triangle[] getRayTriangles](  [param:Ray ray],  [param:Triangle[] triangles] ) <br />
			[method:Triangle[] getSphereTriangles](  [param:Sphere sphere],  [param:Triangle[] triangles] ) <br />
			[method:any rayIntersect](  [param:Ray ray] ) <br />
			[method:any sphereIntersect](  [param:Sphere sphere] ) <br />
			[method:Octree split](  [param:number level] ) <br />
			[method:any triangleCapsuleIntersect](  [param:Capsule capsule],  [param:Triangle triangle] ) <br />
			[method:any triangleSphereIntersect](  [param:Sphere sphere],  [param:Triangle triangle] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="OculusHandModel">OculusHandModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OculusHandModel OculusHandModel](  [param:Object3D controller] ) - The constructor takes no arguments.<br />
			[constructor:OculusHandModel OculusHandModel](  [param:Object3D controller] ) - The constructor takes no arguments.<br />
			[constructor:OculusHandModel OculusHandModel](  [param:Object3D controller] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Object3D controller] -  The controller.<br />
			[property:Texture envMap] -  The env map.<br />
			[property:Mesh mesh] -  The mesh.<br />
			[property:Object3D motionController] -  The motion controller.
		</p>
		<h4>Methods</h4>
		<p>
			[method:OculusHandModel add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:OculusHandModel applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:OculusHandModel attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:void checkButton](  [param:Object3D button] ) <br />
			[method:OculusHandModel clear](  ) - Removes all child objects.<br />
			[method:OculusHandModel clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:OculusHandModel copy](  [param:OculusHandModel source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getPointerPosition](  ) <br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:boolean intersectBoxObject](  [param:Object3D boxObject] ) <br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:OculusHandModel remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:OculusHandModel removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:OculusHandModel rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:OculusHandModel rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:OculusHandModel rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:OculusHandModel rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:OculusHandModel rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:OculusHandModel translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:OculusHandModel translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:OculusHandModel translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:OculusHandModel translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="OculusHandPointerModel">OculusHandPointerModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OculusHandPointerModel OculusHandPointerModel](  [param:Object3D hand],  [param:Object3D controller] ) - The constructor takes no arguments.<br />
			[constructor:OculusHandPointerModel OculusHandPointerModel](  [param:Object3D hand],  [param:Object3D controller] ) - The constructor takes no arguments.<br />
			[constructor:OculusHandPointerModel OculusHandPointerModel](  [param:Object3D hand],  [param:Object3D controller] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean attached] -  The attached.<br />
			[property:Object3D controller] -  The controller.<br />
			[property:Mesh cursorObject] -  The cursor object.<br />
			[property:Texture envMap] -  The env map.<br />
			[property:Object3D hand] -  The hand.<br />
			[property:Mesh mesh] -  The mesh.<br />
			[property:Object3D motionController] -  The motion controller.<br />
			[property:boolean pinched] -  The pinched.<br />
			[property:BufferGeometry pointerGeometry] -  The pointer geometry.<br />
			[property:Mesh pointerMesh] -  The pointer mesh.<br />
			[property:Object3D pointerObject] -  The pointer object.<br />
			[property:Raycaster raycaster] -  The raycaster.<br />
			[property:boolean visible] - Object gets rendered if *true*. Default is *true*.<br />
			[property:unknown xrInputSource] -  The xr input source.
		</p>
		<h4>Methods</h4>
		<p>
			[method:OculusHandPointerModel add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:OculusHandPointerModel applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:OculusHandPointerModel attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:void checkIntersections](  [param:Object3D[] objects],  [param:boolean recursive]? ) <br />
			[method:OculusHandPointerModel clear](  ) - Removes all child objects.<br />
			[method:OculusHandPointerModel clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:OculusHandPointerModel copy](  [param:OculusHandPointerModel source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void createPointer](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void|Intersection[] intersectObject](  [param:Object3D object],  [param:boolean recursive]? ) <br />
			[method:void|Intersection[] intersectObjects](  [param:Object3D[] objects],  [param:boolean recursive]? ) <br />
			[method:boolean isAttached](  ) <br />
			[method:boolean isPinched](  ) <br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:OculusHandPointerModel remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:OculusHandPointerModel removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:OculusHandPointerModel rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:OculusHandPointerModel rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:OculusHandPointerModel rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:OculusHandPointerModel rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:OculusHandPointerModel rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setAttached](  [param:boolean attached] ) <br />
			[method:void setCursor](  [param:number distance] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:OculusHandPointerModel translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:OculusHandPointerModel translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:OculusHandPointerModel translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:OculusHandPointerModel translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			This is only available in worker JS contexts, not the DOM.
		</p>

		<hr class="interface-line"/>
		<h3 id="OimoPhysics">OimoPhysics <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OimoPhysics OimoPhysics](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addMesh](  [param:Mesh mesh],  [param:number mass] ) <br />
			[method:void setMeshPosition](  [param:Mesh mesh],  [param:Vector3 position],  [param:number index] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="OperatorNode">OperatorNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OperatorNode OperatorNode](  [param:NodeNode a],  [param:NodeNode b],  [param:string op] ) <br />
			[constructor:OperatorNode OperatorNode](  [param:NodeNode a],  [param:NodeNode b],  [param:string op],  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:OperatorNode OperatorNode](  [param:NodeNode a],  [param:NodeNode b],  [param:string op],  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string ADD] -  The a d d.<br />
			[property:string DIV] -  The d i v.<br />
			[property:string MUL] -  The m u l.<br />
			[property:string SUB] -  The s u b.<br />
			[property:NodeNode a] -  The a.<br />
			[property:NodeNode b] -  The b.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string op] -  The op.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:OperatorNode copy](  [param:OperatorNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:OperatorNode setLabel](  [param:string name] ) <br />
			[method:OperatorNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="OrbitControls">OrbitControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OrbitControls OrbitControls](  [param:Camera object],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoRotate] -  The auto rotate.<br />
			[property:number autoRotateSpeed] -  The auto rotate speed.<br />
			[property:Vector3 center] -  The center.<br />
			[property:number dampingFactor] -  The damping factor.<br />
			[property:HTMLElement|HTMLDocument domElement] -  The dom element.<br />
			[property:boolean enableDamping] -  The enable damping.<br />
			[property:boolean enableKeys] -  The enable keys.<br />
			[property:boolean enablePan] -  The enable pan.<br />
			[property:boolean enableRotate] -  The enable rotate.<br />
			[property:boolean enableZoom] -  The enable zoom.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:number keyPanSpeed] -  The key pan speed.<br />
			[property:any keys] -  The keys.<br />
			[property:number maxAzimuthAngle] -  The max azimuth angle.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number maxPolarAngle] -  The max polar angle.<br />
			[property:number maxZoom] -  The max zoom.<br />
			[property:number minAzimuthAngle] -  The min azimuth angle.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:number minPolarAngle] -  The min polar angle.<br />
			[property:number minZoom] -  The min zoom.<br />
			[property:any mouseButtons] -  The mouse buttons.<br />
			[property:Camera object] -  The object.<br />
			[property:number panSpeed] -  The pan speed.<br />
			[property:number rotateSpeed] -  The rotate speed.<br />
			[property:boolean screenSpacePanning] -  The screen space panning.<br />
			[property:Vector3 target] -  The target.<br />
			[property:any touches] -  The touches.<br />
			[property:number zoomSpeed] -  The zoom speed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void dispatchEvent](  [param:any event] ) <br />
			[method:void dispose](  ) <br />
			[method:number getAzimuthalAngle](  ) <br />
			[method:number getDistance](  ) <br />
			[method:number getPolarAngle](  ) <br />
			[method:boolean hasEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void listenToKeyEvents](  [param:HTMLElement domElement] ) <br />
			[method:void removeEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void reset](  ) <br />
			[method:void saveState](  ) <br />
			[method:boolean update](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Camera] &rarr;

		<h3 id="OrthographicCamera">OrthographicCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OrthographicCamera OrthographicCamera](  [param:number left]?,  [param:number right]?,  [param:number top]?,  [param:number bottom]?,  [param:number near]?,  [param:number far]? ) <br />
			[constructor:OrthographicCamera OrthographicCamera](  [param:number left]?,  [param:number right]?,  [param:number top]?,  [param:number bottom]?,  [param:number near]?,  [param:number far]? ) - This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.<br />
			[constructor:OrthographicCamera OrthographicCamera](  [param:number left]?,  [param:number right]?,  [param:number top]?,  [param:number bottom]?,  [param:number near]?,  [param:number far]? ) - The constructor takes no arguments.<br />
			[constructor:OrthographicCamera OrthographicCamera](  [param:number left]?,  [param:number right]?,  [param:number top]?,  [param:number bottom]?,  [param:number near]?,  [param:number far]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number bottom] - Camera frustum bottom plane.<br />
			[property:number far] - Camera frustum far plane.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:any isOrthographicCamera] -  The is orthographic camera.<br />
			[property:number left] - Camera frustum left plane.<br />
			[property:Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:number near] - Camera frustum near plane.<br />
			[property:Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:number right] - Camera frustum right plane.<br />
			[property:number top] - Camera frustum top plane.<br />
			[property:any type] -  The type.<br />
			[property:any view] -  The view.<br />
			[property:number zoom] -  The zoom.
		</p>
		<h4>Methods</h4>
		<p>
			[method:OrthographicCamera add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:OrthographicCamera applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:OrthographicCamera attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:OrthographicCamera clear](  ) - Removes all child objects.<br />
			[method:void clearViewOffset](  ) <br />
			[method:OrthographicCamera clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:OrthographicCamera copy](  [param:OrthographicCamera source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) <br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:OrthographicCamera remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:OrthographicCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:OrthographicCamera rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:OrthographicCamera rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:OrthographicCamera rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:OrthographicCamera rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:OrthographicCamera rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:void setViewOffset](  [param:number fullWidth],  [param:number fullHeight],  [param:number offsetX],  [param:number offsetY],  [param:number width],  [param:number height] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:OrthographicCamera translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:OrthographicCamera translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:OrthographicCamera translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:OrthographicCamera translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateProjectionMatrix](  ) - Updates the camera projection matrix. Must be called after change of parameters.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			Camera with orthographic projection<br />
			see {@link https://github.com/mrdoob/three.js/blob/master/src/cameras/OrthographicCamera.js|src/cameras/OrthographicCamera.js}
		</p>

		<hr class="interface-line"/>
		<h3 id="OutlineEffect">OutlineEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OutlineEffect OutlineEffect](  [param:WebGLRenderer renderer],  [param:OutlineEffectParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoClear] -  The auto clear.<br />
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:WebGLShadowMap shadowMap] -  The shadow map.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void clear](  [param:boolean color]?,  [param:boolean depth]?,  [param:boolean stencil]? ) <br />
			[method:number getPixelRatio](  ) <br />
			[method:Vector2 getSize](  [param:Vector2 target] ) <br />
			[method:void render](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void renderOutline](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void setPixelRatio](  [param:number value] ) <br />
			[method:void setRenderTarget](  [param:WebGLRenderTarget renderTarget] ) <br />
			[method:void setScissor](  [param:number|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) <br />
			[method:void setScissorTest](  [param:boolean enable] ) <br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:boolean updateStyle]? ) <br />
			[method:void setViewport](  [param:number|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="OutlineEffectParameters">OutlineEffectParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number defaultAlpha]? -  The default alpha.<br />
			[property:number[] defaultColor]? -  The default color.<br />
			[property:boolean defaultKeepAlive]? -  The default keep alive.<br />
			[property:number defaultThickness]? -  The default thickness.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="OutlinePass">OutlinePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:OutlinePass OutlinePass](  [param:Vector2 resolution],  [param:Scene scene],  [param:Camera camera],  [param:Object3D[] selectedObjects]? ) <br />
			[constructor:OutlinePass OutlinePass](  [param:Vector2 resolution],  [param:Scene scene],  [param:Camera camera],  [param:Object3D[] selectedObjects]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:MeshDepthMaterial depthMaterial] -  The depth material.<br />
			[property:number downSampleRatio] -  The down sample ratio.<br />
			[property:ShaderMaterial edgeDetectionMaterial] -  The edge detection material.<br />
			[property:number edgeGlow] -  The edge glow.<br />
			[property:number edgeStrength] -  The edge strength.<br />
			[property:number edgeThickness] -  The edge thickness.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:Color hiddenEdgeColor] -  The hidden edge color.<br />
			[property:MeshBasicMaterial maskBufferMaterial] -  The mask buffer material.<br />
			[property:ShaderMaterial materialCopy] -  The material copy.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number oldClearAlpha] -  The old clear alpha.<br />
			[property:Color oldClearColor] -  The old clear color.<br />
			[property:ShaderMaterial overlayMaterial] -  The overlay material.<br />
			[property:Texture patternTexture] -  The pattern texture.<br />
			[property:ShaderMaterial prepareMaskMaterial] -  The prepare mask material.<br />
			[property:number pulsePeriod] -  The pulse period.<br />
			[property:Camera renderCamera] -  The render camera.<br />
			[property:Scene renderScene] -  The render scene.<br />
			[property:WebGLRenderTarget renderTargetBlurBuffer1] -  The render target blur buffer1.<br />
			[property:WebGLRenderTarget renderTargetBlurBuffer2] -  The render target blur buffer2.<br />
			[property:WebGLRenderTarget renderTargetDepthBuffer] -  The render target depth buffer.<br />
			[property:WebGLRenderTarget renderTargetEdgeBuffer1] -  The render target edge buffer1.<br />
			[property:WebGLRenderTarget renderTargetEdgeBuffer2] -  The render target edge buffer2.<br />
			[property:WebGLRenderTarget renderTargetMaskBuffer] -  The render target mask buffer.<br />
			[property:WebGLRenderTarget renderTargetMaskDownSampleBuffer] -  The render target mask down sample buffer.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:Vector2 resolution] -  The resolution.<br />
			[property:Object3D[] selectedObjects] -  The selected objects.<br />
			[property:ShaderMaterial separableBlurMaterial1] -  The separable blur material1.<br />
			[property:ShaderMaterial separableBlurMaterial2] -  The separable blur material2.<br />
			[property:Color tempPulseColor1] -  The temp pulse color1.<br />
			[property:Color tempPulseColor2] -  The temp pulse color2.<br />
			[property:Matrix4 textureMatrix] -  The texture matrix.<br />
			[property:boolean usePatternTexture] -  The use pattern texture.<br />
			[property:Color visibleEdgeColor] -  The visible edge color.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void changeVisibilityOfNonSelectedObjects](  [param:boolean bVisible] ) <br />
			[method:void changeVisibilityOfSelectedObjects](  [param:boolean bVisible] ) <br />
			[method:void dispose](  ) <br />
			[method:ShaderMaterial getEdgeDetectionMaterial](  ) <br />
			[method:ShaderMaterial getOverlayMaterial](  ) <br />
			[method:ShaderMaterial getPrepareMaskMaterial](  ) <br />
			[method:ShaderMaterial getSeperableBlurMaterial](  ) <br />
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) <br />
			[method:void updateTextureMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="PCDLoader">PCDLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PCDLoader PCDLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:PCDLoader PCDLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean littleEndian] -  The little endian.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Points parse](  [param:string|ArrayBuffer data],  [param:string url] ) <br />
			[method:PCDLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:PCDLoader setPath](  [param:string path] ) <br />
			[method:PCDLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:PCDLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:PCDLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="PDBLoader">PDBLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PDBLoader PDBLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:PDBLoader PDBLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:PDB parse](  [param:string text] ) <br />
			[method:PDBLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:PDBLoader setPath](  [param:string path] ) <br />
			[method:PDBLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:PDBLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:PDBLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="PLYExporter">PLYExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PLYExporter PLYExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:string parse](  [param:Object3D object],  [param:any onDone],  [param:PLYExporterOptions options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="PLYExporterOptions">PLYExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean binary]? -  The binary.<br />
			[property:string[] excludeAttributes]? -  The exclude attributes.<br />
			[property:boolean littleEndian]? -  The little endian.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="PLYLoader">PLYLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PLYLoader PLYLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:PLYLoader PLYLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object propertyNameMapping] -  The property name mapping.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:BufferGeometry parse](  [param:string|ArrayBuffer data] ) <br />
			[method:PLYLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:PLYLoader setPath](  [param:string path] ) <br />
			[method:void setPropertyNameMapping](  [param:object mapping] ) <br />
			[method:PLYLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:PLYLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:PLYLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="PMREMGenerator">PMREMGenerator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PMREMGenerator PMREMGenerator](  [param:WebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void compileCubemapShader](  ) <br />
			[method:void compileEquirectangularShader](  ) <br />
			[method:void dispose](  ) <br />
			[method:WebGLRenderTarget fromCubemap](  [param:CubeTexture cubemap] ) <br />
			[method:WebGLRenderTarget fromEquirectangular](  [param:Texture equirectangular] ) <br />
			[method:WebGLRenderTarget fromScene](  [param:Scene scene],  [param:number sigma]?,  [param:number near]?,  [param:number far]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="PRWMLoader">PRWMLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PRWMLoader PRWMLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:PRWMLoader PRWMLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:boolean isBigEndianPlatform](  ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:BufferGeometry parse](  [param:ArrayBuffer data] ) <br />
			[method:PRWMLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:PRWMLoader setPath](  [param:string path] ) <br />
			[method:PRWMLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:PRWMLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:PRWMLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr; [page:CompressedTextureLoader] &rarr;

		<h3 id="PVRLoader">PVRLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PVRLoader PVRLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:PVRLoader PVRLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) <br />
			[constructor:PVRLoader PVRLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:CompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:PVR parse](  [param:ArrayBuffer buffer],  [param:boolean loadMipmaps] ) <br />
			[method:PVRLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:PVRLoader setPath](  [param:string path] ) <br />
			[method:PVRLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:PVRLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:PVRLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Panel">Panel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:HTMLCanvasElement dom] -  The dom.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void update](  [param:number value],  [param:number maxValue] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ParallaxBarrierEffect">ParallaxBarrierEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ParallaxBarrierEffect ParallaxBarrierEffect](  [param:WebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ParametricGeometries">ParametricGeometries <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ParametricPlaneGeometry PlaneGeometry] -  The plane geometry.<br />
			[property:ParametricSphereGeometry SphereGeometry] -  The sphere geometry.<br />
			[property:ParametricTorusKnotGeometry TorusKnotGeometry] -  The torus knot geometry.<br />
			[property:ParametricTubeGeometry TubeGeometry] -  The tube geometry.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Vector3 klein](  [param:number v],  [param:number u],  [param:Vector3 target] ) <br />
			[method:Vector3 mobius](  [param:number u],  [param:number t],  [param:Vector3 target] ) <br />
			[method:Vector3 mobius3d](  [param:number u],  [param:number t],  [param:Vector3 target] ) <br />
			[method:void plane](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="ParametricGeometry">ParametricGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ParametricGeometry ParametricGeometry](  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricGeometry ParametricGeometry](  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricGeometry ParametricGeometry](  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ParametricGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:ParametricGeometry] &rarr;

		<h3 id="ParametricPlaneGeometry">ParametricPlaneGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ParametricPlaneGeometry ParametricPlaneGeometry](  [param:number width],  [param:number depth],  [param:number segmentsWidth],  [param:number segmentsDepth] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricPlaneGeometry ParametricPlaneGeometry](  [param:number width],  [param:number depth],  [param:number segmentsWidth],  [param:number segmentsDepth],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricPlaneGeometry ParametricPlaneGeometry](  [param:number width],  [param:number depth],  [param:number segmentsWidth],  [param:number segmentsDepth],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricPlaneGeometry ParametricPlaneGeometry](  [param:number width],  [param:number depth],  [param:number segmentsWidth],  [param:number segmentsDepth],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ParametricPlaneGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:ParametricGeometry] &rarr;

		<h3 id="ParametricSphereGeometry">ParametricSphereGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ParametricSphereGeometry ParametricSphereGeometry](  [param:number size],  [param:number u],  [param:number v] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricSphereGeometry ParametricSphereGeometry](  [param:number size],  [param:number u],  [param:number v],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricSphereGeometry ParametricSphereGeometry](  [param:number size],  [param:number u],  [param:number v],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricSphereGeometry ParametricSphereGeometry](  [param:number size],  [param:number u],  [param:number v],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ParametricSphereGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:ParametricGeometry] &rarr; [page:ParametricTubeGeometry] &rarr;

		<h3 id="ParametricTorusKnotGeometry">ParametricTorusKnotGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ParametricTorusKnotGeometry ParametricTorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number segmentsT]?,  [param:number segmentsR]?,  [param:number p]?,  [param:number q]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricTorusKnotGeometry ParametricTorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number segmentsT]?,  [param:number segmentsR]?,  [param:number p]?,  [param:number q]?,  [param:Curve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricTorusKnotGeometry ParametricTorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number segmentsT]?,  [param:number segmentsR]?,  [param:number p]?,  [param:number q]?,  [param:Curve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricTorusKnotGeometry ParametricTorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number segmentsT]?,  [param:number segmentsR]?,  [param:number p]?,  [param:number q]?,  [param:Curve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricTorusKnotGeometry ParametricTorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number segmentsT]?,  [param:number segmentsR]?,  [param:number p]?,  [param:number q]?,  [param:Curve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ParametricTorusKnotGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:ParametricGeometry] &rarr;

		<h3 id="ParametricTubeGeometry">ParametricTubeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ParametricTubeGeometry ParametricTubeGeometry](  [param:Curve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricTubeGeometry ParametricTubeGeometry](  [param:Curve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricTubeGeometry ParametricTubeGeometry](  [param:Curve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ParametricTubeGeometry ParametricTubeGeometry](  [param:Curve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ParametricTubeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ParseTrackNameResults">ParseTrackNameResults <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string nodeName] -  The node name.<br />
			[property:string objectIndex] -  The object index.<br />
			[property:string objectName] -  The object name.<br />
			[property:string propertyIndex] -  The property index.<br />
			[property:string propertyName] -  The property name.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Pass">Pass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Pass Pass](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr; [page:CurvePath] &rarr;

		<h3 id="Path">Path <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Path Path](  [param:Vector2[] points]? ) <br />
			[constructor:Path Path](  [param:Vector2[] points]? ) <br />
			[constructor:Path Path](  [param:Vector2[] points]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:boolean autoClose] -  The auto close.<br />
			[property:Vector2 currentPoint] -  The current point.<br />
			[property:Curve[] curves] -  The curves.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Path absarc](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[method:Path absellipse](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[method:void add](  [param:Curve curve] ) <br />
			[method:Path arc](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[method:Path bezierCurveTo](  [param:number aCP1x],  [param:number aCP1y],  [param:number aCP2x],  [param:number aCP2y],  [param:number aX],  [param:number aY] ) <br />
			[method:Path clone](  ) <br />
			[method:void closePath](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:Path copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:Path ellipse](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[method:Path fromJSON](  [param:object json] ) <br />
			[method:Path fromPoints](  [param:Vector2[] vectors] ) - deprecated - Use {@link Path#setFromPoints .setFromPoints()} instead.<br />
			[method:number[] getCurveLengths](  ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:Path lineTo](  [param:number x],  [param:number y] ) <br />
			[method:Path moveTo](  [param:number x],  [param:number y] ) <br />
			[method:Path quadraticCurveTo](  [param:number aCPx],  [param:number aCPy],  [param:number aX],  [param:number aY] ) <br />
			[method:Path setFromPoints](  [param:Vector2[] vectors] ) <br />
			[method:Path splineThru](  [param:Vector2[] pts] ) <br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			a 2d path representation, comprising of points, lines, and cubes, similar to the html5 2d canvas api. It extends CurvePath.
		</p>

		<hr class="interface-line"/>
		<h3 id="PeppersGhostEffect">PeppersGhostEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PeppersGhostEffect PeppersGhostEffect](  [param:WebGLRenderer renderer] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number cameraDistance] -  The camera distance.<br />
			[property:boolean reflectFromAbove] -  The reflect from above.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Camera] &rarr;

		<h3 id="PerspectiveCamera">PerspectiveCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PerspectiveCamera PerspectiveCamera](  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) <br />
			[constructor:PerspectiveCamera PerspectiveCamera](  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) - This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.<br />
			[constructor:PerspectiveCamera PerspectiveCamera](  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) - The constructor takes no arguments.<br />
			[constructor:PerspectiveCamera PerspectiveCamera](  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number aspect] - Camera frustum aspect ratio, window width divided by window height.<br />
			[property:number far] - Camera frustum far plane.<br />
			[property:number filmGauge] -  The film gauge.<br />
			[property:number filmOffset] -  The film offset.<br />
			[property:number focus] -  The focus.<br />
			[property:number fov] - Camera frustum vertical field of view, from bottom to top of view, in degrees.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:any isPerspectiveCamera] -  The is perspective camera.<br />
			[property:Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:number near] - Camera frustum near plane.<br />
			[property:Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:any type] -  The type.<br />
			[property:any view] -  The view.<br />
			[property:number zoom] -  The zoom.
		</p>
		<h4>Methods</h4>
		<p>
			[method:PerspectiveCamera add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:PerspectiveCamera applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:PerspectiveCamera attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:PerspectiveCamera clear](  ) - Removes all child objects.<br />
			[method:void clearViewOffset](  ) <br />
			[method:PerspectiveCamera clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:PerspectiveCamera copy](  [param:PerspectiveCamera source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:number getEffectiveFOV](  ) <br />
			[method:number getFilmHeight](  ) <br />
			[method:number getFilmWidth](  ) <br />
			[method:number getFocalLength](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) <br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:PerspectiveCamera remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:PerspectiveCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:PerspectiveCamera rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PerspectiveCamera rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:PerspectiveCamera rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:PerspectiveCamera rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:PerspectiveCamera rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setFocalLength](  [param:number focalLength] ) <br />
			[method:void setLens](  [param:number focalLength],  [param:number frameHeight]? ) - deprecated - Use {@link PerspectiveCamera#setFocalLength .setFocalLength()} and {@link PerspectiveCamera#filmGauge .filmGauge} instead.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:void setViewOffset](  [param:number fullWidth],  [param:number fullHeight],  [param:number x],  [param:number y],  [param:number width],  [param:number height] ) - Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.<br />
			For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:<br />
			+---+---+---+<br />
			| A | B | C |<br />
			+---+---+---+<br />
			| D | E | F |<br />
			+---+---+---+<br />
			<br />
			then for each monitor you would call it like this:<br />
			<br />
			const w = 1920;<br />
			const h = 1080;<br />
			const fullWidth = w * 3;<br />
			const fullHeight = h * 2;<br />
			<br />
			// A<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h ) : this;<br />
			// B<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h ) : this;<br />
			// C<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h ) : this;<br />
			// D<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h ) : this;<br />
			// E<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h ) : this;<br />
			// F<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ) : this; Note there is no reason monitors have to be the same size or in a grid.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:PerspectiveCamera translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PerspectiveCamera translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:PerspectiveCamera translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:PerspectiveCamera translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateProjectionMatrix](  ) - Updates the camera projection matrix. Must be called after change of parameters.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			Camera with perspective projection.
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr;

		<h3 id="PhongNode">PhongNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PhongNode PhongNode](  ) <br />
			[constructor:PhongNode PhongNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:NodeNode shininess] -  The shininess.<br />
			[property:NodeNode specular] -  The specular.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder] ) <br />
			[method:PhongNode copy](  [param:PhongNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:PhongNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:ShaderMaterial] &rarr; [page:NodeMaterial] &rarr;

		<h3 id="PhongNodeMaterial">PhongNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PhongNodeMaterial PhongNodeMaterial](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:PhongNodeMaterial PhongNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:PhongNodeMaterial PhongNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:PhongNodeMaterial PhongNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:PhongNodeMaterial PhongNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode alpha] -  The alpha.<br />
			[property:NodeNode ambient] -  The ambient.<br />
			[property:NodeNode ao] -  The ao.<br />
			[property:NodeNode color] -  The color.<br />
			[property:NodeNode emissive] -  The emissive.<br />
			[property:NodeNode environment] -  The environment.<br />
			[property:NodeNode environmentAlpha] -  The environment alpha.<br />
			[property:NodeNode|RawNode fragment] -  The fragment.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:NodeNode light] -  The light.<br />
			[property:NodeNode mask] -  The mask.<br />
			[property:NodeNode normal] -  The normal.<br />
			[property:NodeNode position] -  The position.<br />
			[property:object properties] -  The properties.<br />
			[property:NodeNode shadow] -  The shadow.<br />
			[property:NodeNode shininess] -  The shininess.<br />
			[property:NodeNode specular] -  The specular.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:NodeNode|RawNode vertex] -  The vertex.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:PhongNodeMaterial build](  [param:NodeMaterialBuildParams params]? ) <br />
			[method:PhongNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:PhongNodeMaterial copy](  [param:NodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="PixelShader">PixelShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="PlacedGeometry">PlacedGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any color] -  The color.<br />
			[property:number[] flatTransformation] -  The flat transformation.<br />
			[property:number geometryExpressID] -  The geometry express i d.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Plane">Plane <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Plane Plane](  [param:Vector3 normal]?,  [param:number constant]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number constant] - the signed distance from the origin to the plane. Default is *0*.<br />
			[property:any isPlane] -  The is plane.<br />
			[property:Vector3 normal] - a unit length [page:Vector3 Vector3] defining the normal of the plane. Default is *(1, 0, 0)*.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Plane applyMatrix4](  [param:Matrix4 matrix],  [param:Matrix3 optionalNormalMatrix]? ) <br />
			[method:Plane clone](  ) - Returns : Returns a new plane with the same *.normal* and *.constant* as this one.<br />
			[method:Vector3 coplanarPoint](  [param:Vector3 target] ) - Returns : Returns a [page:Vector3 Vector3] coplanar to the plane, by calculating the projection of the normal vector at the origin onto the plane.<br />
			[method:Plane copy](  [param:Plane plane] ) - Copies the values of the passed plane's *.normal* and *.constant*<br />
			properties to this plane.<br />
			[method:number distanceToPoint](  [param:Vector3 point] ) - Returns : Returns the signed distance from the [page:Vector3 point] to the plane.<br />
			[method:number distanceToSphere](  [param:Sphere sphere] ) - Returns : Returns the signed distance from the [page:Sphere sphere] to the plane.<br />
			[method:boolean equals](  [param:Plane plane] ) - Checks to see if two planes are equal (their *.normal* and *.constant* properties match).<br />
			[method:Vector3 intersectLine](  [param:Line3 line],  [param:Vector3 target] ) - Returns : Returns the intersection point of the passed line and the plane. Returns null  if the line does not intersect. Returns the line's starting point if the line is  coplanar with the plane.<br />
			[method:boolean intersectsBox](  [param:Box3 box] ) <br />
			[method:boolean intersectsLine](  [param:Line3 line] ) <br />
			[method:boolean intersectsSphere](  [param:Sphere sphere] ) <br />
			[method:any isIntersectionLine](  [param:any l] ) - deprecated - Use {@link Plane#intersectsLine .intersectsLine()} instead.<br />
			[method:Plane negate](  ) - Negates both the normal vector and the constant.<br />
			[method:Plane normalize](  ) - Normalizes the *.normal* vector, and adjusts the *.constant*<br />
			value accordingly.<br />
			[method:Vector3 orthoPoint](  [param:Vector3 point],  [param:Vector3 target] ) - Returns : point<br />
			[method:Vector3 projectPoint](  [param:Vector3 point],  [param:Vector3 target] ) - Projects a [page:Vector3 point] onto the plane.<br />
			[method:Plane set](  [param:Vector3 normal],  [param:number constant] ) - Sets this plane's *.normal* and *.constant* properties by copying the values from the given normal.<br />
			[method:Plane setComponents](  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Set the individual components that define the plane.<br />
			[method:Plane setFromCoplanarPoints](  [param:Vector3 a],  [param:Vector3 b],  [param:Vector3 c] ) - Defines the plane based on the 3 provided points. The winding order is assumed to be counter-clockwise, and determines the direction of the *.normal*.<br />
			[method:Plane setFromNormalAndCoplanarPoint](  [param:Vector3 normal],  [param:Vector3 point] ) - Sets the plane's properties as defined by a [page:Vector3 normal] and an arbitrary coplanar [page:Vector3 point].<br />
			[method:Plane translate](  [param:Vector3 offset] ) - Translates the plane by the distance defined by the [page:Vector3 offset] vector.<br />
			Note that this only affects the plane constant and will not affect the normal vector.
		</p>

		<p class="desc">
			A two dimensional surface that extends infinitely in 3d space, represented in [link:http://mathworld.wolfram.com/HessianNormalForm.html Hessian normal form]<br />
			by a unit length normal vector and a constant.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="PlaneBufferGeometry">PlaneBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PlaneGeometry PlaneGeometry](  [param:number width]?,  [param:number height]?,  [param:number widthSegments]?,  [param:number heightSegments]? ) <br />
			[constructor:PlaneGeometry PlaneGeometry](  [param:number width]?,  [param:number height]?,  [param:number widthSegments]?,  [param:number heightSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:PlaneGeometry PlaneGeometry](  [param:number width]?,  [param:number height]?,  [param:number widthSegments]?,  [param:number heightSegments]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:PlaneGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:PlaneGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="PlaneGeometry">PlaneGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PlaneGeometry PlaneGeometry](  [param:number width]?,  [param:number height]?,  [param:number widthSegments]?,  [param:number heightSegments]? ) <br />
			[constructor:PlaneGeometry PlaneGeometry](  [param:number width]?,  [param:number height]?,  [param:number widthSegments]?,  [param:number heightSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:PlaneGeometry PlaneGeometry](  [param:number width]?,  [param:number height]?,  [param:number widthSegments]?,  [param:number heightSegments]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:PlaneGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:PlaneGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="PlaneHelper">PlaneHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PlaneHelper PlaneHelper](  [param:Plane plane],  [param:number size]?,  [param:number hex]? ) <br />
			[constructor:PlaneHelper PlaneHelper](  [param:Plane plane],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:PlaneHelper PlaneHelper](  [param:Plane plane],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:PlaneHelper PlaneHelper](  [param:Plane plane],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:PlaneHelper PlaneHelper](  [param:Plane plane],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Plane plane] -  The plane.<br />
			[property:number size] -  The size.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:PlaneHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:PlaneHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:PlaneHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:PlaneHelper clear](  ) - Removes all child objects.<br />
			[method:PlaneHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:PlaneHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:PlaneHelper copy](  [param:PlaneHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:PlaneHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:PlaneHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:PlaneHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PlaneHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:PlaneHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:PlaneHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:PlaneHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:PlaneHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PlaneHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:PlaneHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:PlaneHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Light] &rarr;

		<h3 id="PointLight">PointLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PointLight PointLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number decay]? ) - The constructor takes no arguments.<br />
			[constructor:PointLight PointLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:PointLight PointLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:PointLight PointLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number decay] -  The decay.<br />
			[property:number distance] - If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.<br />
			[property:number intensity] - Light's intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:number power] -  The power.<br />
			[property:PointLightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:PointLight add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:PointLight applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:PointLight attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:PointLight clear](  ) - Removes all child objects.<br />
			[method:PointLight clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:PointLight copy](  [param:PointLight source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:PointLight remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:PointLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:PointLight rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PointLight rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:PointLight rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:PointLight rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:PointLight rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:PointLight translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PointLight translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:PointLight translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:PointLight translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="PointLightHelper">PointLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PointLightHelper PointLightHelper](  [param:PointLight light],  [param:number sphereSize]?,  [param:ColorRepresentation color]? ) - The constructor takes no arguments.<br />
			[constructor:PointLightHelper PointLightHelper](  [param:PointLight light],  [param:number sphereSize]?,  [param:ColorRepresentation color]? ) - The constructor takes no arguments.<br />
			[constructor:PointLightHelper PointLightHelper](  [param:PointLight light],  [param:number sphereSize]?,  [param:ColorRepresentation color]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:ColorRepresentation color] -  The color.<br />
			[property:PointLight light] -  The light.<br />
			[property:Matrix4 matrix] - The local transform matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:PointLightHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:PointLightHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:PointLightHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:PointLightHelper clear](  ) - Removes all child objects.<br />
			[method:PointLightHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:PointLightHelper copy](  [param:PointLightHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:PointLightHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:PointLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:PointLightHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PointLightHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:PointLightHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:PointLightHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:PointLightHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:PointLightHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PointLightHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:PointLightHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:PointLightHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:LightShadow] &rarr;

		<h3 id="PointLightShadow">PointLightShadow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PointLightShadow PointLightShadow](  [param:Camera camera] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:number bias] -  The bias.<br />
			[property:number blurSamples] -  The blur samples.<br />
			[property:PerspectiveCamera camera] -  The camera.<br />
			[property:WebGLRenderTarget map] -  The map.<br />
			[property:WebGLRenderTarget mapPass] -  The map pass.<br />
			[property:Vector2 mapSize] -  The map size.<br />
			[property:Matrix4 matrix] -  The matrix.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number normalBias] -  The normal bias.<br />
			[property:number radius] -  The radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:PointLightShadow clone](  [param:boolean recursive]? ) <br />
			[method:PointLightShadow copy](  [param:LightShadow source] ) <br />
			[method:void dispose](  ) <br />
			[method:Vector2 getFrameExtents](  ) <br />
			[method:number getFrustum](  ) <br />
			[method:Vector4 getViewport](  [param:number viewportIndex] ) <br />
			[method:any toJSON](  ) <br />
			[method:void updateMatrices](  [param:Light light],  [param:number viewportIndex]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="PointerLockControls">PointerLockControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PointerLockControls PointerLockControls](  [param:Camera camera],  [param:HTMLElement domElement]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:PointerLockControls PointerLockControls](  [param:Camera camera],  [param:HTMLElement domElement]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:boolean isLocked] -  The is locked.<br />
			[property:number maxPolarAngle] -  The max polar angle.<br />
			[property:number minPolarAngle] -  The min polar angle.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void connect](  ) <br />
			[method:void disconnect](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Vector3 getDirection](  [param:Vector3 v] ) <br />
			[method:Camera getObject](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lock](  ) <br />
			[method:void moveForward](  [param:number distance] ) <br />
			[method:void moveRight](  [param:number distance] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void unlock](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Points">Points <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Points Points](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:Points Points](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - The constructor takes no arguments.<br />
			[constructor:Points Points](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:TGeometry geometry] - An instance of [page:BufferGeometry BufferGeometry] (or derived classes), defining the object's structure.<br />
			[property:any isPoints] -  The is points.<br />
			[property:TMaterial material] - An instance of [page:Material Material], defining the object's appearance.<br />
			Default is a [page:PointsMaterial PointsMaterial].<br />
			[property:any morphTargetDictionary]? - A dictionary of morphTargets based on the morphTarget.name property.<br />
			Undefined by default, but rebuilt [page:Points.updateMorphTargets updateMorphTargets].<br />
			[property:number[] morphTargetInfluences]? - An array of weights typically from 0-1 that specify how much of the morph is applied.<br />
			Undefined by default, but reset to a blank array by [page:Points.updateMorphTargets updateMorphTargets].<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Points add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Points applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Points attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Points clear](  ) - Removes all child objects.<br />
			[method:Points clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Points copy](  [param:Points source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this Points.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:Points remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Points removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Points rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Points rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Points rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Points rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Points rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Points translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Points translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Points translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Points translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Points.morphTargetInfluences morphTargetInfluences] and [page:Points.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			A class for displaying points.<br />
			The points are rendered by the [page:WebGLRenderer WebGLRenderer] using [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements gl.POINTS].
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="PointsMaterial">PointsMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PointsMaterial PointsMaterial](  [param:PointsMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:PointsMaterial PointsMaterial](  [param:PointsMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:PointsMaterial PointsMaterial](  [param:PointsMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:Texture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:number size] -  The size.<br />
			[property:boolean sizeAttenuation] -  The size attenuation.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:PointsMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:PointsMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:PointsMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="PointsMaterialParameters">PointsMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:number size]? -  The size.<br />
			[property:boolean sizeAttenuation]? -  The size attenuation.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="PolarGridHelper">PolarGridHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PolarGridHelper PolarGridHelper](  [param:number radius]?,  [param:number radials]?,  [param:number circles]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]? ) <br />
			[constructor:PolarGridHelper PolarGridHelper](  [param:number radius]?,  [param:number radials]?,  [param:number circles]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:PolarGridHelper PolarGridHelper](  [param:number radius]?,  [param:number radials]?,  [param:number circles]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:PolarGridHelper PolarGridHelper](  [param:number radius]?,  [param:number radials]?,  [param:number circles]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:PolarGridHelper PolarGridHelper](  [param:number radius]?,  [param:number radials]?,  [param:number circles]?,  [param:number divisions]?,  [param:ColorRepresentation color1]?,  [param:ColorRepresentation color2]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:PolarGridHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:PolarGridHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:PolarGridHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:PolarGridHelper clear](  ) - Removes all child objects.<br />
			[method:PolarGridHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:PolarGridHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:PolarGridHelper copy](  [param:PolarGridHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:PolarGridHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:PolarGridHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:PolarGridHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PolarGridHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:PolarGridHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:PolarGridHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:PolarGridHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:PolarGridHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PolarGridHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:PolarGridHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:PolarGridHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="PolyhedronBufferGeometry">PolyhedronBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PolyhedronGeometry PolyhedronGeometry](  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:PolyhedronGeometry PolyhedronGeometry](  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:PolyhedronGeometry PolyhedronGeometry](  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:PolyhedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:PolyhedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="PolyhedronGeometry">PolyhedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PolyhedronGeometry PolyhedronGeometry](  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:PolyhedronGeometry PolyhedronGeometry](  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:PolyhedronGeometry PolyhedronGeometry](  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:PolyhedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:PolyhedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Position">Position <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number x] -  The x.<br />
			[property:number y] -  The y.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void set](  [param:number x],  [param:number y] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="PositionNode">PositionNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PositionNode PositionNode](  [param:string scope]? ) <br />
			[constructor:PositionNode PositionNode](  [param:string scope]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:PositionNode PositionNode](  [param:string scope]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string LOCAL] -  The l o c a l.<br />
			[property:string PROJECTION] -  The p r o j e c t i o n.<br />
			[property:string VIEW] -  The v i e w.<br />
			[property:string WORLD] -  The w o r l d.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:PositionNode copy](  [param:PositionNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:PositionNode setLabel](  [param:string name] ) <br />
			[method:PositionNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Audio] &rarr;

		<h3 id="PositionalAudio">PositionalAudio <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PositionalAudio PositionalAudio](  [param:AudioListener listener] ) - The constructor takes no arguments.<br />
			[constructor:PositionalAudio PositionalAudio](  [param:AudioListener listener],  [param:AudioListener listener] ) - The constructor takes no arguments.<br />
			[constructor:PositionalAudio PositionalAudio](  [param:AudioListener listener],  [param:AudioListener listener] ) - The constructor takes no arguments.<br />
			[constructor:PositionalAudio PositionalAudio](  [param:AudioListener listener],  [param:AudioListener listener] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoplay] -  The autoplay.<br />
			[property:AudioBuffer buffer] -  The buffer.<br />
			[property:AudioContext context] -  The context.<br />
			[property:number detune] -  The detune.<br />
			[property:number duration] -  The duration.<br />
			[property:AudioNode[] filters] -  The filters.<br />
			[property:GainNode gain] -  The gain.<br />
			[property:boolean hasPlaybackControl] -  The has playback control.<br />
			[property:boolean isPlaying] -  The is playing.<br />
			[property:AudioListener listener] -  The listener.<br />
			[property:boolean loop] -  The loop.<br />
			[property:number loopEnd] -  The loop end.<br />
			[property:number loopStart] -  The loop start.<br />
			[property:number offset] -  The offset.<br />
			[property:PannerNode panner] -  The panner.<br />
			[property:number playbackRate] -  The playback rate.<br />
			[property:AudioBufferSourceNode source] -  The source.<br />
			[property:string sourceType] -  The source type.<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:PositionalAudio add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:PositionalAudio applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:PositionalAudio attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:PositionalAudio clear](  ) - Removes all child objects.<br />
			[method:PositionalAudio clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:PositionalAudio connect](  ) <br />
			[method:PositionalAudio copy](  [param:PositionalAudio source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:PositionalAudio disconnect](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:number getDetune](  ) <br />
			[method:string getDistanceModel](  ) <br />
			[method:AudioNode getFilter](  ) <br />
			[method:AudioNode[] getFilters](  ) <br />
			[method:boolean getLoop](  ) <br />
			[method:number getMaxDistance](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:PannerNode getOutput](  ) <br />
			[method:number getPlaybackRate](  ) <br />
			[method:number getRefDistance](  ) <br />
			[method:number getRolloffFactor](  ) <br />
			[method:number getVolume](  ) <br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Audio load](  [param:string file] ) - deprecated - Use {@link AudioLoader} instead.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onEnded](  ) <br />
			[method:PositionalAudio pause](  ) <br />
			[method:PositionalAudio play](  [param:number delay]? ) <br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:PositionalAudio remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:PositionalAudio removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:PositionalAudio rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PositionalAudio rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:PositionalAudio rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:PositionalAudio rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:PositionalAudio rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:PositionalAudio setBuffer](  [param:AudioBuffer audioBuffer] ) <br />
			[method:PositionalAudio setDetune](  [param:number value] ) <br />
			[method:PositionalAudio setDirectionalCone](  [param:number coneInnerAngle],  [param:number coneOuterAngle],  [param:number coneOuterGain] ) <br />
			[method:PositionalAudio setDistanceModel](  [param:string value] ) <br />
			[method:PositionalAudio setFilter](  [param:AudioNode filter] ) <br />
			[method:PositionalAudio setFilters](  [param:AudioNode[] value] ) <br />
			[method:PositionalAudio setLoop](  [param:boolean value] ) <br />
			[method:PositionalAudio setLoopEnd](  [param:number value] ) <br />
			[method:PositionalAudio setLoopStart](  [param:number value] ) <br />
			[method:PositionalAudio setMaxDistance](  [param:number value] ) <br />
			[method:PositionalAudio setMediaElementSource](  [param:HTMLMediaElement mediaElement] ) <br />
			[method:PositionalAudio setMediaStreamSource](  [param:MediaStream mediaStream] ) <br />
			[method:PositionalAudio setNodeSource](  [param:AudioBufferSourceNode audioNode] ) <br />
			[method:PositionalAudio setPlaybackRate](  [param:number value] ) <br />
			[method:PositionalAudio setRefDistance](  [param:number value] ) <br />
			[method:PositionalAudio setRolloffFactor](  [param:number value] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:PositionalAudio setVolume](  [param:number value] ) <br />
			[method:PositionalAudio stop](  ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:PositionalAudio translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PositionalAudio translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:PositionalAudio translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:PositionalAudio translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr;

		<h3 id="PositionalAudioHelper">PositionalAudioHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PositionalAudioHelper PositionalAudioHelper](  [param:PositionalAudio audio],  [param:number range]?,  [param:number divisionsInnerAngle]?,  [param:number divisionsOuterAngle]? ) <br />
			[constructor:PositionalAudioHelper PositionalAudioHelper](  [param:PositionalAudio audio],  [param:number range]?,  [param:number divisionsInnerAngle]?,  [param:number divisionsOuterAngle]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:PositionalAudioHelper PositionalAudioHelper](  [param:PositionalAudio audio],  [param:number range]?,  [param:number divisionsInnerAngle]?,  [param:number divisionsOuterAngle]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:PositionalAudioHelper PositionalAudioHelper](  [param:PositionalAudio audio],  [param:number range]?,  [param:number divisionsInnerAngle]?,  [param:number divisionsOuterAngle]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:PositionalAudio audio] -  The audio.<br />
			[property:number divisionsInnerAngle] -  The divisions inner angle.<br />
			[property:number divisionsOuterAngle] -  The divisions outer angle.<br />
			[property:number range] -  The range.
		</p>
		<h4>Methods</h4>
		<p>
			[method:PositionalAudioHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:PositionalAudioHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:PositionalAudioHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:PositionalAudioHelper clear](  ) - Removes all child objects.<br />
			[method:PositionalAudioHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:PositionalAudioHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:PositionalAudioHelper copy](  [param:PositionalAudioHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:PositionalAudioHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:PositionalAudioHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:PositionalAudioHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PositionalAudioHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:PositionalAudioHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:PositionalAudioHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:PositionalAudioHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:PositionalAudioHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:PositionalAudioHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:PositionalAudioHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:PositionalAudioHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ProgressiveLightMap">ProgressiveLightMap <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ProgressiveLightMap ProgressiveLightMap](  [param:WebGLRenderer renderer],  [param:number res]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Mesh blurringPlane] -  The blurring plane.<br />
			[property:boolean buffer1Active] -  The buffer1 active.<br />
			[property:boolean compiled] -  The compiled.<br />
			[property:boolean firstUpdate] -  The first update.<br />
			[property:MeshBasicMaterial labelMaterial] -  The label material.<br />
			[property:Mesh labelMesh] -  The label mesh.<br />
			[property:PlaneGeometry labelPlane] -  The label plane.<br />
			[property:LightMapContainers[] lightMapContainers] -  The light map containers.<br />
			[property:WebGLRenderTarget progressiveLightMap1] -  The progressive light map1.<br />
			[property:WebGLRenderTarget progressiveLightMap2] -  The progressive light map2.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:number res] -  The res.<br />
			[property:Scene scene] -  The scene.<br />
			[property:WebGLRenderTarget tinyTarget] -  The tiny target.<br />
			[property:MeshPhongMaterial uvMat] -  The uv mat.<br />
			[property:UVBoxes[] uv_boxes] -  The uv_boxes.<br />
			[property:boolean warned] -  The warned.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void _initializeBlurPlane](  [param:number res],  [param:Texture lightMap]? ) <br />
			[method:void addObjectsToLightMap](  [param:Object3D[] objects] ) <br />
			[method:void showDebugLightmap](  [param:boolean visible],  [param:Vector3 position]? ) <br />
			[method:void update](  [param:Camera camera],  [param:number blendWindow]?,  [param:boolean blurEdges]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Projector">Projector <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Projector Projector](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:any projectScene](  [param:Scene scene],  [param:Camera camera],  [param:boolean sortObjects],  [param:boolean sortElements] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="PropertyBinding">PropertyBinding <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PropertyBinding PropertyBinding](  [param:any rootNode],  [param:string path],  [param:any parsedPath]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any BindingType] -  The binding type.<br />
			[property:any GetterByBindingType] -  The getter by binding type.<br />
			[property:any SetterByBindingTypeAndVersioning] -  The setter by binding type and versioning.<br />
			[property:any Versioning] -  The versioning.<br />
			[property:any node] -  The node.<br />
			[property:any parsedPath] -  The parsed path.<br />
			[property:string path] -  The path.<br />
			[property:any rootNode] -  The root node.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void bind](  ) <br />
			[method:PropertyBinding|Composite create](  [param:any root],  [param:any path],  [param:any parsedPath]? ) <br />
			[method:any findNode](  [param:any root],  [param:string nodeName] ) <br />
			[method:any getValue](  [param:any targetArray],  [param:number offset] ) <br />
			[method:ParseTrackNameResults parseTrackName](  [param:string trackName] ) <br />
			[method:string sanitizeNodeName](  [param:string name] ) <br />
			[method:void setValue](  [param:any sourceArray],  [param:number offset] ) <br />
			[method:void unbind](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="PropertyMixer">PropertyMixer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PropertyMixer PropertyMixer](  [param:any binding],  [param:string typeName],  [param:number valueSize] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any binding] -  The binding.<br />
			[property:any buffer] -  The buffer.<br />
			[property:number cumulativeWeight] -  The cumulative weight.<br />
			[property:number cumulativeWeightAdditive] -  The cumulative weight additive.<br />
			[property:number referenceCount] -  The reference count.<br />
			[property:number useCount] -  The use count.<br />
			[property:number valueSize] -  The value size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void accumulate](  [param:number accuIndex],  [param:number weight] ) <br />
			[method:void accumulateAdditive](  [param:number weight] ) <br />
			[method:void apply](  [param:number accuIndex] ) <br />
			[method:void restoreOriginalState](  ) <br />
			[method:void saveOriginalState](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="PropertyNode">PropertyNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:PropertyNode PropertyNode](  [param:object object],  [param:string property],  [param:string type] ) <br />
			[constructor:PropertyNode PropertyNode](  [param:object object],  [param:string property],  [param:string type],  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:PropertyNode PropertyNode](  [param:object object],  [param:string property],  [param:string type],  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:PropertyNode PropertyNode](  [param:object object],  [param:string property],  [param:string type],  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:object object] -  The object.<br />
			[property:string property] -  The property.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:any value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:PropertyNode copy](  [param:InputNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:PropertyNode setLabel](  [param:string name] ) <br />
			[method:PropertyNode setName](  [param:string name] ) <br />
			[method:PropertyNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="PropsNames">PropsNames <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any aggregates] -  The aggregates.<br />
			[property:any materials] -  The materials.<br />
			[property:any psets] -  The psets.<br />
			[property:any spatial] -  The spatial.<br />
			[property:any type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="QuadraticBezierCurve">QuadraticBezierCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:QuadraticBezierCurve QuadraticBezierCurve](  [param:Vector2 v0],  [param:Vector2 v1],  [param:Vector2 v2] ) <br />
			[constructor:QuadraticBezierCurve QuadraticBezierCurve](  [param:Vector2 v0],  [param:Vector2 v1],  [param:Vector2 v2] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:Vector2 v0] -  The v0.<br />
			[property:Vector2 v1] -  The v1.<br />
			[property:Vector2 v2] -  The v2.
		</p>
		<h4>Methods</h4>
		<p>
			[method:QuadraticBezierCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:QuadraticBezierCurve copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:QuadraticBezierCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="QuadraticBezierCurve3">QuadraticBezierCurve3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:QuadraticBezierCurve3 QuadraticBezierCurve3](  [param:Vector3 v0],  [param:Vector3 v1],  [param:Vector3 v2] ) <br />
			[constructor:QuadraticBezierCurve3 QuadraticBezierCurve3](  [param:Vector3 v0],  [param:Vector3 v1],  [param:Vector3 v2] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:Vector3 v0] -  The v0.<br />
			[property:Vector3 v1] -  The v1.<br />
			[property:Vector3 v2] -  The v2.
		</p>
		<h4>Methods</h4>
		<p>
			[method:QuadraticBezierCurve3 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:QuadraticBezierCurve3 copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:QuadraticBezierCurve3 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector3 getPoint](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getPointAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector3 getTangent](  [param:number t],  [param:Vector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector3 getTangentAt](  [param:number u],  [param:Vector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Quaternion">Quaternion <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Quaternion Quaternion](  [param:number x]?,  [param:number y]?,  [param:number z]?,  [param:number w]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isQuaternion] -  The is quaternion.<br />
			[property:number w] - w coordinate<br />
			[property:number x] - x coordinate<br />
			[property:number y] - y coordinate<br />
			[property:number z] - z coordinate
		</p>
		<h4>Methods</h4>
		<p>
			[method:Quaternion _onChange](  [param:any callback] ) <br />
			[method:void _onChangeCallback](  ) <br />
			[method:number angleTo](  [param:Quaternion q] ) - Returns : Returns the angle between this quaternion and quaternion [page:Quaternion q] in radians.<br />
			[method:Quaternion clone](  ) - Creates a new Quaternion with identical *.x*, *.y*, *.z* and *.w* properties to this one.<br />
			[method:Quaternion conjugate](  ) - Returns : Returns the rotational conjugate of this quaternion. The conjugate of a quaternion represents the same rotation in the opposite direction about the rotational axis.<br />
			[method:Quaternion copy](  [param:Quaternion q] ) - Copies the *.x*, *.y*,	*.z* and *.w* properties of [page:Quaternion q] into this quaternion.<br />
			[method:number dot](  [param:Quaternion v] ) - Calculates the [link:https://en.wikipedia.org/wiki/Dot_product dot product] of quaternions [page:Quaternion v] and this one.<br />
			[method:boolean equals](  [param:Quaternion v] ) - Compares the *.x*, *.y*,	*.z* and *.w* properties of [page:Quaternion v] to the equivalent properties of this quaternion to determine if they represent the same rotation.<br />
			[method:Quaternion fromBufferAttribute](  [param:BufferAttribute attribute],  [param:number index]? ) - Sets *.x*, *.y*, *.z*, *.w* properties of this quaternion from the [page:BufferAttribute attribute].<br />
			[method:Quaternion identity](  ) - Sets this quaternion to the identity quaternion; that is, to the quaternion that represents "no rotation".<br />
			[method:Quaternion inverse](  ) - deprecated - Use {@link Quaternion#invert .invert()} instead.<br />
			[method:Quaternion invert](  ) - Inverts this quaternion - calculates the *.conjugate*. The quaternion is assumed to have unit length.<br />
			[method:number length](  ) - Computes the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length] (straight-line length) of this quaternion, considered as a 4 dimensional vector.<br />
			[method:number lengthSq](  ) - Computes the squared [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length] (straight-line length) of this quaternion, considered as a 4 dimensional vector. This can be useful if you are comparing the lengths of two quaternions, as this is a slightly more efficient calculation than *.length*().<br />
			[method:Quaternion multiply](  [param:Quaternion q] ) - Multiplies this quaternion by [page:Quaternion q].<br />
			[method:Quaternion multiplyQuaternions](  [param:Quaternion a],  [param:Quaternion b] ) - Sets this quaternion to [page:Quaternion a] x [page:Quaternion b].<br />
			Adapted from the method outlined [link:http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm here].<br />
			[method:number[] multiplyQuaternionsFlat](  [param:number[] dst],  [param:number dstOffset],  [param:number[] src0],  [param:number srcOffset],  [param:number[] src1],  [param:number stcOffset1] ) <br />
			[method:any multiplyVector3](  [param:any v] ) - deprecated - Use {@link Vector#applyQuaternion vector.applyQuaternion( quaternion )} instead.<br />
			[method:Quaternion normalize](  ) - [link:https://en.wikipedia.org/wiki/Normalized_vector Normalizes] this quaternion - that is, calculated the quaternion that performs the same rotation as this one, but has  *.length* equal to *1*.<br />
			[method:Quaternion premultiply](  [param:Quaternion q] ) - Pre-multiplies this quaternion by [page:Quaternion q].<br />
			[method:Quaternion random](  ) - Sets this quaternion to a uniformly random, normalized quaternion.<br />
			[method:Quaternion rotateTowards](  [param:Quaternion q],  [param:number step] ) <br />
			[method:Quaternion set](  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets *.x*, *.y*, *.z*, *.w* properties of this quaternion.<br />
			[method:Quaternion setFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Sets this quaternion from rotation specified by [page:Vector3 axis] and [page:Float angle].<br />
			Adapted from the method [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm here].<br />
			*Axis* is assumed to be normalized, *angle* is in radians.<br />
			[method:Quaternion setFromEuler](  [param:Euler euler],  [param:boolean update]? ) - Sets this quaternion from the rotation specified by [page:Euler Euler] angle.<br />
			[method:Quaternion setFromRotationMatrix](  [param:Matrix4 m] ) - Sets this quaternion from rotation component of [page:Matrix4 m].<br />
			Adapted from the method [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm here].<br />
			[method:Quaternion setFromUnitVectors](  [param:Vector3 vFrom],  [param:Vector3 vTo] ) - Sets this quaternion to the rotation required to rotate direction vector [page:Vector3 vFrom] to direction vector [page:Vector3 vTo].<br />
			Adapted from the method [link:http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors here].<br />
			[page:Vector3 vFrom] and [page:Vector3 vTo] are assumed to be normalized.<br />
			[method:Quaternion slerp](  [param:Quaternion qb],  [param:number t] ) <br />
			[method:number slerp](  [param:Quaternion qb],  [param:number t],  [param:Quaternion qa],  [param:Quaternion qb],  [param:Quaternion qm],  [param:number t] ) - deprecated - Use qm.slerpQuaternions( qa, qb, t ) instead..<br />
			[method:Quaternion slerpFlat](  [param:number[] dst],  [param:number dstOffset],  [param:number[] src0],  [param:number srcOffset],  [param:number[] src1],  [param:number stcOffset1],  [param:number t] ) <br />
			[method:Quaternion slerpQuaternions](  [param:Quaternion qa],  [param:Quaternion qb],  [param:number t] ) - Performs a spherical linear interpolation between the given quaternions and stores the result in this quaternion.<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Sets this quaternion's *.x*, *.y*,	*.z* and *.w* properties from an array.<br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:ArrayLike array],  [param:number offset]? ) - Copies x, y, z and w into the provided array-like.<br />
			<br />
			Returns : The provided array-like.
		</p>

		<p class="desc">
			Implementation of a [quaternion](http://en.wikipedia.org/wiki/Quaternion).<br />
			Quaternions are used in three.js to represent [rotations](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation).<br />
			<code data-type="javascript"><br />
			const quaternion = new THREE.Quaternion();<br />
			quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );<br />
			const vector = new THREE.Vector3( 1, 0, 0 );<br />
			vector.applyQuaternion( quaternion );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:KeyframeTrack] &rarr;

		<h3 id="QuaternionKeyframeTrack">QuaternionKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:QuaternionKeyframeTrack QuaternionKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) <br />
			[constructor:QuaternionKeyframeTrack QuaternionKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]?,  [param:string name],  [param:ArrayLike times],  [param:ArrayLike values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:LinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:CubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:QuaternionKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:KeyframeTrack optimize](  ) <br />
			[method:KeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:KeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:KeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:any toJSON](  [param:KeyframeTrack track] ) <br />
			[method:KeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Interpolant] &rarr;

		<h3 id="QuaternionLinearInterpolant">QuaternionLinearInterpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:QuaternionLinearInterpolant QuaternionLinearInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]? ) <br />
			[constructor:QuaternionLinearInterpolant QuaternionLinearInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]?,  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) - Note: This is not designed to be called directly.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] - array of positions<br />
			[property:any resultBuffer] - buffer to store the interpolation results.<br />
			[property:any sampleValues] - array of samples<br />
			[property:number valueSize] - number of samples
		</p>
		<h4>Methods</h4>
		<p>
			[method:number[] evaluate](  [param:number t] ) - Evaluate the interpolant at position *t*.<br />
			[method:any interpolate_](  [param:number i1],  [param:number t0],  [param:number t],  [param:number t1] ) 
		</p>

		<p class="desc">
			Quaternion linear interpolant<br />
			<code data-type="javascript"><br />
			const interpolant = new THREE.QuaternionLinearInterpolant(<br />
			new Float32Array( 2 ), new Float32Array( 2 ),, n, new Float32Array( 1 ) );<br />
			interpolant.evaluate( 0.5 );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		<h3 id="RGBE">RGBE <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Uint8Array|Float32Array data] -  The data.<br />
			[property:number exposure] -  The exposure.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:number gamma] -  The gamma.<br />
			[property:string header] -  The header.<br />
			[property:number height] -  The height.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number width] -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr; [page:DataTextureLoader] &rarr;

		<h3 id="RGBELoader">RGBELoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RGBELoader RGBELoader](  [param:LoadingManager manager]? ) <br />
			[constructor:RGBELoader RGBELoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) <br />
			[constructor:RGBELoader RGBELoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:TextureDataType type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DataTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:RGBE parse](  [param:ArrayBuffer buffer] ) <br />
			[method:RGBELoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:RGBELoader setDataType](  [param:TextureDataType type] ) <br />
			[method:RGBELoader setPath](  [param:string path] ) <br />
			[method:RGBELoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:RGBELoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:RGBELoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RGBM">RGBM <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Uint8Array data] -  The data.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:string header] -  The header.<br />
			[property:number height] -  The height.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number width] -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr; [page:DataTextureLoader] &rarr;

		<h3 id="RGBMLoader">RGBMLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RGBMLoader RGBMLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:RGBMLoader RGBMLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) <br />
			[constructor:RGBMLoader RGBMLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:DataTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:CubeTexture loadCubemap](  [param:string[] urls],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:RGBM parse](  [param:ArrayBuffer buffer] ) <br />
			[method:RGBMLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:RGBMLoader setPath](  [param:string path] ) <br />
			[method:RGBMLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:RGBMLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:RGBMLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RGBShiftShader">RGBShiftShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr; [page:TextureNode] &rarr;

		<h3 id="RTTNode">RTTNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RTTNode RTTNode](  [param:number width],  [param:number height],  [param:TextureNode input],  [param:RTTNodeOptions options]? ) <br />
			[constructor:RTTNode RTTNode](  [param:number width],  [param:number height],  [param:TextureNode input],  [param:RTTNodeOptions options]?,  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]? ) <br />
			[constructor:RTTNode RTTNode](  [param:number width],  [param:number height],  [param:TextureNode input],  [param:RTTNodeOptions options]?,  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:RTTNode RTTNode](  [param:number width],  [param:number height],  [param:TextureNode input],  [param:RTTNodeOptions options]?,  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:RTTNode RTTNode](  [param:number width],  [param:number height],  [param:TextureNode input],  [param:RTTNodeOptions options]?,  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode bias] -  The bias.<br />
			[property:OrthographicCamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:TextureNode input] -  The input.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:object material] -  The material.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean project] -  The project.<br />
			[property:Mesh quad] -  The quad.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean render] -  The render.<br />
			[property:WebGLRenderTarget renderTarget] -  The render target.<br />
			[property:Scene scene] -  The scene.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:UVNode|UVTransformNode uv] -  The uv.<br />
			[property:Texture value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:RTTNode copy](  [param:RTTNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getTexture](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:RTTNode setLabel](  [param:string name] ) <br />
			[method:RTTNode setName](  [param:string name] ) <br />
			[method:RTTNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:NodeFrame frame] ) <br />
			[method:void updateFramesaveTo](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:WebGLRenderTargetOptions] &rarr;

		<h3 id="RTTNodeOptions">RTTNodeOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean clear]? -  The clear.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RandomGenerator">RandomGenerator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:number getSeed](  ) <br />
			[method:number random](  ) <br />
			[method:void setSeed](  [param:number seed] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RawLineData">RawLineData <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number ID] -  The i d.<br />
			[property:any[] arguments] -  The arguments.<br />
			[property:number type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr;

		<h3 id="RawNode">RawNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RawNode RawNode](  [param:NodeNode value] ) <br />
			[constructor:RawNode RawNode](  [param:NodeNode value],  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:NodeNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:RawNode copy](  [param:RawNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:RawNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:ShaderMaterial] &rarr;

		<h3 id="RawShaderMaterial">RawShaderMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RawShaderMaterial RawShaderMaterial](  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:RawShaderMaterial RawShaderMaterial](  [param:ShaderMaterialParameters parameters]?,  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:RawShaderMaterial RawShaderMaterial](  [param:ShaderMaterialParameters parameters]?,  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:RawShaderMaterial RawShaderMaterial](  [param:ShaderMaterialParameters parameters]?,  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] - deprecated - Use {@link ShaderMaterial#extensions.derivatives extensions.derivatives} instead.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:RawShaderMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:RawShaderMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RayParameters">RayParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number birthTime]? -  The birth time.<br />
			[property:number deathTime]? -  The death time.<br />
			[property:Vector3 destOffset]? -  The dest offset.<br />
			[property:boolean generateUVs]? -  The generate u vs.<br />
			[property:boolean isEternal]? -  The is eternal.<br />
			[property:boolean isStatic]? -  The is static.<br />
			[property:number maxIterations]? -  The max iterations.<br />
			[property:number maxSubrayRecursion]? -  The max subray recursion.<br />
			[property:number minRadius]? -  The min radius.<br />
			[property:number noiseSeed]? -  The noise seed.<br />
			[property:number propagationTimeFactor]? -  The propagation time factor.<br />
			[property:number radius0]? -  The radius0.<br />
			[property:number radius0Factor]? -  The radius0 factor.<br />
			[property:number radius1]? -  The radius1.<br />
			[property:number radius1Factor]? -  The radius1 factor.<br />
			[property:number ramification]? -  The ramification.<br />
			[property:RandomGenerator randomGenerator]? -  The random generator.<br />
			[property:number recursionProbability]? -  The recursion probability.<br />
			[property:number roughness]? -  The roughness.<br />
			[property:Vector3 sourceOffset]? -  The source offset.<br />
			[property:number straightness]? -  The straightness.<br />
			[property:number subrayDutyCycle]? -  The subray duty cycle.<br />
			[property:number subrayPeriod]? -  The subray period.<br />
			[property:number timeScale]? -  The time scale.<br />
			[property:Vector3 up0]? -  The up0.<br />
			[property:Vector3 up1]? -  The up1.<br />
			[property:number vanishingTimeFactor]? -  The vanishing time factor.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void onDecideSubrayCreation](  [param:LightningSegment segment],  [param:LightningStrike lightningStrike] ) <br />
			[method:void onSubrayCreation](  [param:LightningSegment segment],  [param:LightningSubray parentSubray],  [param:LightningSubray childSubray],  [param:LightningStrike lightningStrike] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Raycaster">Raycaster <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Raycaster Raycaster](  [param:Vector3 origin]?,  [param:Vector3 direction]?,  [param:number near]?,  [param:number far]? ) - This creates a new raycaster object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Camera camera] - The camera to use when raycasting against view-dependent objects such as billboarded objects like [page:Sprites Sprites]. This field can be set manually or is set when calling "setFromCamera".<br />
			Defaults to null.<br />
			[property:number far] - The far factor of the raycaster. This value indicates which objects can be discarded based on the distance.<br />
			This value shouldn't be negative and should be larger than the near property.<br />
			[property:Layers layers] - Used by Raycaster to selectively ignore 3D objects when performing intersection tests. The following code example ensures that only 3D objects on layer *1* will be honored by the instance of Raycaster.<br />
			raycaster.layers.set( 1 );<br />
			object.layers.enable( 1 );<br />
			[property:number near] - The near factor of the raycaster. This value indicates which objects can be discarded based on the distance.<br />
			This value shouldn't be negative and should be smaller than the far property.<br />
			[property:RaycasterParameters params] - An object with the following properties:<br />
			Where threshold is the precision of the raycaster when intersecting objects, in world units.<br />
			[property:Ray ray] - The [page:Ray Ray] used for the raycasting.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Intersection[] intersectObject](  [param:Object3D object],  [param:boolean recursive]?,  [param:Intersection[] optionalTarget]? ) - Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first.<br />
			An array of intersections is returned... [ { distance, point, face, faceIndex, object }, ... ]<br />
			distance - Second set of U,V coordinates at point of intersection [page:Integer instanceId]  The index number of the instance where the ray intersects the InstancedMesh *Raycaster* delegates to the [page:Object3D.raycast raycast] method of the passed object, when evaluating whether the ray intersects the object or not. This allows [page:Mesh meshes] to respond differently to ray casting than [page:Line lines] and [page:Points pointclouds].<br />
			*Note* that for meshes, faces must be pointed towards the origin of the *.ray* in order to be detected; intersections of the ray passing through the back of a face will not be detected. To raycast against both faces of an object, you'll want to set the [page:Mesh.material material]'s [page:Material.side side] property to *THREE.DoubleSide*.<br />
			[method:Intersection[] intersectObjects](  [param:Object3D[] objects],  [param:boolean recursive]?,  [param:Intersection[] optionalTarget]? ) - Checks all intersection between the ray and the objects with or without the descendants. Intersections are returned sorted by distance, closest first. Intersections are of the same form as those returned by *.intersectObject*.<br />
			[method:void set](  [param:Vector3 origin],  [param:Vector3 direction] ) - Updates the ray with a new origin and direction. Please note that this method only copies the values from the arguments.<br />
			[method:void setFromCamera](  [param:any coords],  [param:Camera camera] ) - Updates the ray with a new origin and direction.
		</p>

		<p class="desc">
			This class is designed to assist with [raycasting](https://en.wikipedia.org/wiki/Ray_casting).<br />
			Raycasting is used for mouse picking (working out what objects in the 3d space the mouse is over) amongst other things.<br />
			[example:webgl_interactive_cubes Raycasting to a Mesh]<br />
			[example:webgl_interactive_cubes_ortho Raycasting to a Mesh in using an OrthographicCamera]<br />
			[example:webgl_interactive_buffergeometry Raycasting to a Mesh with BufferGeometry]<br />
			[example:webgl_instancing_raycast Raycasting to a InstancedMesh]<br />
			[example:webgl_interactive_lines Raycasting to a Line]<br />
			[example:webgl_interactive_raycasting_points Raycasting to Points]<br />
			[example:webgl_geometry_terrain_raycast Terrain raycasting]<br />
			[example:webgl_interactive_voxelpainter Raycasting to paint voxels]<br />
			[example:webgl_raycast_texture Raycast to a Texture]<br />
			<br />
			<code data-type="javascript"><br />
			const raycaster = new THREE.Raycaster();<br />
			const mouse = new THREE.Vector2();<br />
			function onMouseMove( event ) {<br />
			 //  calculate mouse position in normalized device coordinates // (-1 to +1) for both components<br />
			 mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;<br />
			 mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;<br />
			}<br />
			function render() {<br />
			 //  update the picking ray with the camera and mouse position raycaster.setFromCamera( mouse, camera );<br />
			 //  calculate objects intersecting the picking ray const intersects = raycaster.intersectObjects( scene.children );<br />
			 for ( let i = 0; i &lt; intersects.length; i ++ ) {<br />
			     intersects[ i ].object.material.color.set( 0xff0000 );<br />
			 }<br />
			 renderer.render( scene, camera );<br />
			}<br />
			window.addEventListener( 'mousemove', onMouseMove, false );<br />
			window.requestAnimationFrame(render);<br />
			</code>
		</p>

		<hr class="interface-line"/>
		<h3 id="RaycasterParameters">RaycasterParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any LOD]? -  The l o d.<br />
			[property:any Line]? -  The line.<br />
			[property:any Mesh]? -  The mesh.<br />
			[property:any Points]? -  The points.<br />
			[property:any Sprite]? -  The sprite.
		</p>

		<p class="desc">
			Raycaster parameters
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Light] &rarr;

		<h3 id="RectAreaLight">RectAreaLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RectAreaLight RectAreaLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number width]?,  [param:number height]? ) - The constructor takes no arguments.<br />
			[constructor:RectAreaLight RectAreaLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number width]?,  [param:number height]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:RectAreaLight RectAreaLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number width]?,  [param:number height]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:RectAreaLight RectAreaLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number width]?,  [param:number height]?,  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number height] -  The height.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isRectAreaLight] -  The is rect area light.<br />
			[property:number power] -  The power.<br />
			[property:LightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:string type] -  The type.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:RectAreaLight add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:RectAreaLight applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:RectAreaLight attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:RectAreaLight clear](  ) - Removes all child objects.<br />
			[method:RectAreaLight clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:RectAreaLight copy](  [param:RectAreaLight source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:RectAreaLight remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:RectAreaLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:RectAreaLight rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:RectAreaLight rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:RectAreaLight rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:RectAreaLight rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:RectAreaLight rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:RectAreaLight translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:RectAreaLight translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:RectAreaLight translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:RectAreaLight translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr;

		<h3 id="RectAreaLightHelper">RectAreaLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RectAreaLightHelper RectAreaLightHelper](  [param:RectAreaLight light],  [param:ColorRepresentation color]? ) <br />
			[constructor:RectAreaLightHelper RectAreaLightHelper](  [param:RectAreaLight light],  [param:ColorRepresentation color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:RectAreaLightHelper RectAreaLightHelper](  [param:RectAreaLight light],  [param:ColorRepresentation color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:RectAreaLightHelper RectAreaLightHelper](  [param:RectAreaLight light],  [param:ColorRepresentation color]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:ColorRepresentation color] -  The color.<br />
			[property:RectAreaLight light] -  The light.
		</p>
		<h4>Methods</h4>
		<p>
			[method:RectAreaLightHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:RectAreaLightHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:RectAreaLightHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:RectAreaLightHelper clear](  ) - Removes all child objects.<br />
			[method:RectAreaLightHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:RectAreaLightHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:RectAreaLightHelper copy](  [param:RectAreaLightHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:RectAreaLightHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:RectAreaLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:RectAreaLightHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:RectAreaLightHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:RectAreaLightHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:RectAreaLightHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:RectAreaLightHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:RectAreaLightHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:RectAreaLightHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:RectAreaLightHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:RectAreaLightHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RectAreaLightUniformsLib">RectAreaLightUniformsLib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void init](  ) <br />
			[method:void init](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="ReflectNode">ReflectNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ReflectNode ReflectNode](  [param:string scope]? ) <br />
			[constructor:ReflectNode ReflectNode](  [param:string scope]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ReflectNode ReflectNode](  [param:string scope]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string CUBE] -  The c u b e.<br />
			[property:string SPHERE] -  The s p h e r e.<br />
			[property:string VECTOR] -  The v e c t o r.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ReflectNode copy](  [param:NodeNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ReflectNode setLabel](  [param:string name] ) <br />
			[method:ReflectNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="Reflector">Reflector <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Reflector Reflector](  [param:BufferGeometry geometry]?,  [param:ReflectorOptions options]? ) <br />
			[constructor:Reflector Reflector](  [param:BufferGeometry geometry]?,  [param:ReflectorOptions options]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:Reflector Reflector](  [param:BufferGeometry geometry]?,  [param:ReflectorOptions options]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:Reflector Reflector](  [param:BufferGeometry geometry]?,  [param:ReflectorOptions options]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Reflector add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Reflector applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Reflector attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Reflector clear](  ) - Removes all child objects.<br />
			[method:Reflector clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Reflector copy](  [param:Reflector source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:WebGLRenderTarget getRenderTarget](  ) <br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:Reflector remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Reflector removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Reflector rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Reflector rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Reflector rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Reflector rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Reflector rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Reflector translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Reflector translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Reflector translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Reflector translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="ReflectorForSSRPass">ReflectorForSSRPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ReflectorForSSRPass ReflectorForSSRPass](  [param:BufferGeometry geometry],  [param:ReflectorForSSRPassOptions options] ) <br />
			[constructor:ReflectorForSSRPass ReflectorForSSRPass](  [param:BufferGeometry geometry],  [param:ReflectorForSSRPassOptions options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:ReflectorForSSRPass ReflectorForSSRPass](  [param:BufferGeometry geometry],  [param:ReflectorForSSRPassOptions options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:ReflectorForSSRPass ReflectorForSSRPass](  [param:BufferGeometry geometry],  [param:ReflectorForSSRPassOptions options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:ReflectorShader ReflectorShader] -  The reflector shader.<br />
			[property:ShaderMaterial material] - An instance of material derived from the [page:Material Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial MeshBasicMaterial].<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number opacity] -  The opacity.<br />
			[property:ReflectorOptions options] -  The options.<br />
			[property:WebGLRenderTarget renderTarget] -  The render target.<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ReflectorForSSRPass add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:ReflectorForSSRPass applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:ReflectorForSSRPass attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:ReflectorForSSRPass clear](  ) - Removes all child objects.<br />
			[method:ReflectorForSSRPass clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:ReflectorForSSRPass copy](  [param:ReflectorForSSRPass source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void doRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:WebGLRenderTarget getRenderTarget](  ) <br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:ReflectorForSSRPass remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:ReflectorForSSRPass removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ReflectorForSSRPass rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ReflectorForSSRPass rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:ReflectorForSSRPass rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:ReflectorForSSRPass rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:ReflectorForSSRPass rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ReflectorForSSRPass translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ReflectorForSSRPass translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:ReflectorForSSRPass translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:ReflectorForSSRPass translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ReflectorForSSRPassOptions">ReflectorForSSRPassOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number clipBias]? -  The clip bias.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:object|ReflectorShader shader]? -  The shader.<br />
			[property:number textureHeight]? -  The texture height.<br />
			[property:number textureWidth]? -  The texture width.<br />
			[property:boolean useDepthTexture]? -  The use depth texture.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="ReflectorNode">ReflectorNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ReflectorNode ReflectorNode](  [param:ReflectorRTT mirror]? ) <br />
			[constructor:ReflectorNode ReflectorNode](  [param:ReflectorRTT mirror]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ReflectorNode ReflectorNode](  [param:ReflectorRTT mirror]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:PositionNode localPosition] -  The local position.<br />
			[property:ReflectorRTT mirror] -  The mirror.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:TextureNode texture] -  The texture.<br />
			[property:Matrix4Node textureMatrix] -  The texture matrix.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:OperatorNode uv] -  The uv.<br />
			[property:OperatorNode uvResult] -  The uv result.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ReflectorNode copy](  [param:ReflectorNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ReflectorNode setLabel](  [param:string name] ) <br />
			[method:ReflectorNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ReflectorOptions">ReflectorOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number clipBias]? -  The clip bias.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:object shader]? -  The shader.<br />
			[property:number textureHeight]? -  The texture height.<br />
			[property:number textureWidth]? -  The texture width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr; [page:ReflectorForSSRPass] &rarr;

		<h3 id="ReflectorRTT">ReflectorRTT <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ReflectorRTT ReflectorRTT](  [param:BufferGeometry geometry]?,  [param:ReflectorForSSRPassOptions options]? ) <br />
			[constructor:ReflectorRTT ReflectorRTT](  [param:BufferGeometry geometry]?,  [param:ReflectorForSSRPassOptions options]?,  [param:BufferGeometry geometry],  [param:ReflectorForSSRPassOptions options] ) <br />
			[constructor:ReflectorRTT ReflectorRTT](  [param:BufferGeometry geometry]?,  [param:ReflectorForSSRPassOptions options]?,  [param:BufferGeometry geometry],  [param:ReflectorForSSRPassOptions options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:ReflectorRTT ReflectorRTT](  [param:BufferGeometry geometry]?,  [param:ReflectorForSSRPassOptions options]?,  [param:BufferGeometry geometry],  [param:ReflectorForSSRPassOptions options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:ReflectorRTT ReflectorRTT](  [param:BufferGeometry geometry]?,  [param:ReflectorForSSRPassOptions options]?,  [param:BufferGeometry geometry],  [param:ReflectorForSSRPassOptions options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:ReflectorShader ReflectorShader] -  The reflector shader.<br />
			[property:ShaderMaterial material] - An instance of material derived from the [page:Material Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial MeshBasicMaterial].<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number opacity] -  The opacity.<br />
			[property:ReflectorOptions options] -  The options.<br />
			[property:WebGLRenderTarget renderTarget] -  The render target.<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ReflectorRTT add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:ReflectorRTT applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:ReflectorRTT attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:ReflectorRTT clear](  ) - Removes all child objects.<br />
			[method:ReflectorRTT clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:ReflectorRTT copy](  [param:ReflectorRTT source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void doRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:WebGLRenderTarget getRenderTarget](  ) <br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:ReflectorRTT remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:ReflectorRTT removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ReflectorRTT rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ReflectorRTT rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:ReflectorRTT rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:ReflectorRTT rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:ReflectorRTT rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ReflectorRTT translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ReflectorRTT translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:ReflectorRTT translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:ReflectorRTT translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ReflectorShader">ReflectorShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="Refractor">Refractor <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Refractor Refractor](  [param:BufferGeometry geometry]?,  [param:RefractorOptions options]? ) <br />
			[constructor:Refractor Refractor](  [param:BufferGeometry geometry]?,  [param:RefractorOptions options]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:Refractor Refractor](  [param:BufferGeometry geometry]?,  [param:RefractorOptions options]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:Refractor Refractor](  [param:BufferGeometry geometry]?,  [param:RefractorOptions options]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Refractor add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Refractor applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Refractor attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Refractor clear](  ) - Removes all child objects.<br />
			[method:Refractor clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Refractor copy](  [param:Refractor source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:WebGLRenderTarget getRenderTarget](  ) <br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:Refractor remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Refractor removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Refractor rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Refractor rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Refractor rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Refractor rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Refractor rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Refractor translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Refractor translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Refractor translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Refractor translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RefractorOptions">RefractorOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number clipBias]? -  The clip bias.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:object shader]? -  The shader.<br />
			[property:number textureHeight]? -  The texture height.<br />
			[property:number textureWidth]? -  The texture width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RenderItem">RenderItem <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:BufferGeometry geometry] -  The geometry.<br />
			[property:Group group] -  The group.<br />
			[property:number groupOrder] -  The group order.<br />
			[property:number id] -  The id.<br />
			[property:Material material] -  The material.<br />
			[property:Object3D object] -  The object.<br />
			[property:WebGLProgram program] -  The program.<br />
			[property:number renderOrder] -  The render order.<br />
			[property:number z] -  The z.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="RenderPass">RenderPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RenderPass RenderPass](  [param:Scene scene],  [param:Camera camera],  [param:Material overrideMaterial]?,  [param:Color clearColor]?,  [param:number clearAlpha]? ) <br />
			[constructor:RenderPass RenderPass](  [param:Scene scene],  [param:Camera camera],  [param:Material overrideMaterial]?,  [param:Color clearColor]?,  [param:number clearAlpha]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Camera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:number clearAlpha] -  The clear alpha.<br />
			[property:Color clearColor] -  The clear color.<br />
			[property:boolean clearDepth] -  The clear depth.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:Material overrideMaterial] -  The override material.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:Scene scene] -  The scene.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RenderableFace">RenderableFace <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:number id] -  The id.<br />
			[property:Material material] -  The material.<br />
			[property:Vector3 normalModel] -  The normal model.<br />
			[property:number renderOrder] -  The render order.<br />
			[property:Vector2[] uvs] -  The uvs.<br />
			[property:RenderableVertex v1] -  The v1.<br />
			[property:RenderableVertex v2] -  The v2.<br />
			[property:RenderableVertex v3] -  The v3.<br />
			[property:number vertexNormalsLength] -  The vertex normals length.<br />
			[property:Vector3[] vertexNormalsModel] -  The vertex normals model.<br />
			[property:number z] -  The z.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RenderableLine">RenderableLine <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number id] -  The id.<br />
			[property:Material material] -  The material.<br />
			[property:number renderOrder] -  The render order.<br />
			[property:RenderableVertex v1] -  The v1.<br />
			[property:RenderableVertex v2] -  The v2.<br />
			[property:Color[] vertexColors] -  The vertex colors.<br />
			[property:number z] -  The z.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RenderableObject">RenderableObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number id] -  The id.<br />
			[property:Object3D object] -  The object.<br />
			[property:number renderOrder] -  The render order.<br />
			[property:number z] -  The z.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RenderableSprite">RenderableSprite <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number id] -  The id.<br />
			[property:Material material] -  The material.<br />
			[property:Object3D object] -  The object.<br />
			[property:number renderOrder] -  The render order.<br />
			[property:number rotation] -  The rotation.<br />
			[property:Vector2 scale] -  The scale.<br />
			[property:number x] -  The x.<br />
			[property:number y] -  The y.<br />
			[property:number z] -  The z.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RenderableVertex">RenderableVertex <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Vector3 position] -  The position.<br />
			[property:Vector4 positionScreen] -  The position screen.<br />
			[property:Vector3 positionWorld] -  The position world.<br />
			[property:boolean visible] -  The visible.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void copy](  [param:RenderableVertex vertex] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Renderer">Renderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Renderer Renderer](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLCanvasElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:Object3D scene],  [param:Camera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:boolean updateStyle]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr; [page:Vector2Node] &rarr;

		<h3 id="ResolutionNode">ResolutionNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ResolutionNode ResolutionNode](  ) <br />
			[constructor:ResolutionNode ResolutionNode](  [param:number|Vector2 x],  [param:number y]? ) <br />
			[constructor:ResolutionNode ResolutionNode](  [param:number|Vector2 x],  [param:number y]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ResolutionNode ResolutionNode](  [param:number|Vector2 x],  [param:number y]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ResolutionNode ResolutionNode](  [param:number|Vector2 x],  [param:number y]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:Vector2 size] -  The size.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Vector2 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ResolutionNode copy](  [param:ResolutionNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ResolutionNode setLabel](  [param:string name] ) <br />
			[method:ResolutionNode setName](  [param:string name] ) <br />
			[method:ResolutionNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ResourceManager">ResourceManager <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ResourceManager ResourceManager](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object[] quaternions] -  The quaternions.<br />
			[property:Euler[] threeEulers] -  The three eulers.<br />
			[property:Matrix4[] threeMatrix4s] -  The three matrix4s.<br />
			[property:Quaternion[] threeQuaternions] -  The three quaternions.<br />
			[property:Vector3[] threeVector3s] -  The three vector3s.<br />
			[property:object[] transforms] -  The transforms.<br />
			[property:object[] vector3s] -  The vector3s.
		</p>
		<h4>Methods</h4>
		<p>
			[method:object addVector3](  [param:object v1],  [param:object v2] ) <br />
			[method:void allocQuaternion](  ) <br />
			[method:void allocThreeEuler](  ) <br />
			[method:void allocThreeMatrix4](  ) <br />
			[method:void allocThreeQuaternion](  ) <br />
			[method:void allocThreeVector3](  ) <br />
			[method:void allocTransform](  ) <br />
			[method:void allocVector3](  ) <br />
			[method:object columnOfMatrix3](  [param:object m],  [param:number i] ) <br />
			[method:void copyOrigin](  [param:object t1],  [param:object t2] ) <br />
			[method:number dotVectors3](  [param:object v1],  [param:object v2] ) <br />
			[method:void freeQuaternion](  [param:object q] ) <br />
			[method:void freeThreeEuler](  [param:Euler e] ) <br />
			[method:void freeThreeMatrix4](  [param:Matrix4 m] ) <br />
			[method:void freeThreeQuaternion](  [param:Quaternion q] ) <br />
			[method:void freeThreeVector3](  [param:Vector3 v] ) <br />
			[method:void freeTransform](  [param:object t] ) <br />
			[method:void freeVector3](  [param:object v] ) <br />
			[method:object getBasis](  [param:object t] ) <br />
			[method:object getBasisAsMatrix3](  [param:object t] ) <br />
			[method:object getOrigin](  [param:object t] ) <br />
			[method:object inverseTransform](  [param:object t] ) <br />
			[method:object matrix3ToQuaternion](  [param:object m] ) <br />
			[method:object multiplyMatrices3](  [param:object m1],  [param:object m2] ) <br />
			[method:object multiplyMatrix3ByVector3](  [param:object m],  [param:object v] ) <br />
			[method:object multiplyTransforms](  [param:object t1],  [param:object t2] ) <br />
			[method:object negativeVector3](  [param:object v] ) <br />
			[method:object quaternionToMatrix3](  [param:object q] ) <br />
			[method:object rowOfMatrix3](  [param:object m],  [param:number i] ) <br />
			[method:void setBasis](  [param:object t],  [param:object q] ) <br />
			[method:void setBasisFromArray3](  [param:object t],  [param:number[] a] ) <br />
			[method:void setBasisFromMatrix3](  [param:object t],  [param:object m] ) <br />
			[method:void setBasisFromThreeQuaternion](  [param:object t],  [param:Quaternion a] ) <br />
			[method:void setIdentity](  ) <br />
			[method:void setOrigin](  [param:object t],  [param:object v] ) <br />
			[method:void setOriginFromArray3](  [param:object t],  [param:number[] a] ) <br />
			[method:void setOriginFromThreeVector3](  [param:object t],  [param:Vector3 v] ) <br />
			[method:object transposeMatrix3](  [param:object m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="Rhino3dmLoader">Rhino3dmLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Rhino3dmLoader Rhino3dmLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:Rhino3dmLoader Rhino3dmLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:Rhino3dmLoader dispose](  ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void parse](  [param:ArrayBufferLike data],  [param:any onLoad],  [param:any onError]? ) <br />
			[method:Rhino3dmLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:Rhino3dmLoader setLibraryPath](  [param:string path] ) <br />
			[method:Rhino3dmLoader setPath](  [param:string path] ) <br />
			[method:Rhino3dmLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:Rhino3dmLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:Rhino3dmLoader setWithCredentials](  [param:boolean value] ) <br />
			[method:Rhino3dmLoader setWorkerLimit](  [param:number workerLimit] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RigidBody">RigidBody <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RigidBody RigidBody](  [param:SkinnedMesh mesh],  [param:object world],  [param:object params],  [param:ResourceManager manager] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object body] -  The body.<br />
			[property:Bone bone] -  The bone.<br />
			[property:object boneOffsetForm] -  The bone offset form.<br />
			[property:object boneOffsetFormInverse] -  The bone offset form inverse.<br />
			[property:ResourceManager manager] -  The manager.<br />
			[property:SkinnedMesh mesh] -  The mesh.<br />
			[property:object params] -  The params.<br />
			[property:object world] -  The world.
		</p>
		<h4>Methods</h4>
		<p>
			[method:RigidBody reset](  ) <br />
			[method:RigidBody updateBone](  ) <br />
			[method:RigidBody updateFromBone](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="RingBufferGeometry">RingBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RingGeometry RingGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:RingGeometry RingGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RingGeometry RingGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:RingGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:RingGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="RingGeometry">RingGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RingGeometry RingGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:RingGeometry RingGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RingGeometry RingGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:RingGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:RingGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="RollerCoasterGeometry">RollerCoasterGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RollerCoasterGeometry RollerCoasterGeometry](  [param:Curve curve],  [param:number divisions] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterGeometry RollerCoasterGeometry](  [param:Curve curve],  [param:number divisions] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterGeometry RollerCoasterGeometry](  [param:Curve curve],  [param:number divisions] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:RollerCoasterGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="RollerCoasterLiftersGeometry">RollerCoasterLiftersGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RollerCoasterLiftersGeometry RollerCoasterLiftersGeometry](  [param:Curve curve],  [param:number divisions] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterLiftersGeometry RollerCoasterLiftersGeometry](  [param:Curve curve],  [param:number divisions] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterLiftersGeometry RollerCoasterLiftersGeometry](  [param:Curve curve],  [param:number divisions] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:RollerCoasterLiftersGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="RollerCoasterShadowGeometry">RollerCoasterShadowGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RollerCoasterShadowGeometry RollerCoasterShadowGeometry](  [param:Curve curve],  [param:number divisions] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterShadowGeometry RollerCoasterShadowGeometry](  [param:Curve curve],  [param:number divisions] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterShadowGeometry RollerCoasterShadowGeometry](  [param:Curve curve],  [param:number divisions] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:RollerCoasterShadowGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="RollerCoasterSkyGeometry">RollerCoasterSkyGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RollerCoasterSkyGeometry RollerCoasterSkyGeometry](  [param:Curve curve],  [param:number divisions] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterSkyGeometry RollerCoasterSkyGeometry](  [param:Curve curve],  [param:number divisions] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterSkyGeometry RollerCoasterSkyGeometry](  [param:Curve curve],  [param:number divisions] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:RollerCoasterSkyGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="RollerCoasterTreesGeometry">RollerCoasterTreesGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RollerCoasterTreesGeometry RollerCoasterTreesGeometry](  [param:Mesh landscape] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterTreesGeometry RollerCoasterTreesGeometry](  [param:Mesh landscape] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RollerCoasterTreesGeometry RollerCoasterTreesGeometry](  [param:Mesh landscape] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:RollerCoasterTreesGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Scene] &rarr;

		<h3 id="RoomEnvironment">RoomEnvironment <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RoomEnvironment RoomEnvironment](  ) - The constructor takes no arguments.<br />
			[constructor:RoomEnvironment RoomEnvironment](  ) - The constructor takes no arguments.<br />
			[constructor:RoomEnvironment RoomEnvironment](  ) - The constructor takes no arguments.<br />
			[constructor:RoomEnvironment RoomEnvironment](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:RoomEnvironment add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:RoomEnvironment applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:RoomEnvironment attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:RoomEnvironment clear](  ) - Removes all child objects.<br />
			[method:RoomEnvironment clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:RoomEnvironment copy](  [param:RoomEnvironment source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera] ) - Calls after rendering scene<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:any renderTarget] ) - Calls before rendering scene<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:RoomEnvironment remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:RoomEnvironment removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:RoomEnvironment rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:RoomEnvironment rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:RoomEnvironment rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:RoomEnvironment rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:RoomEnvironment rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:RoomEnvironment translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:RoomEnvironment translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:RoomEnvironment translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:RoomEnvironment translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="RoughnessMipmapper">RoughnessMipmapper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RoughnessMipmapper RoughnessMipmapper](  [param:WebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void generateMipmaps](  [param:MeshStandardMaterial material] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:BoxGeometry] &rarr;

		<h3 id="RoundedBoxGeometry">RoundedBoxGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:RoundedBoxGeometry RoundedBoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number segments]?,  [param:number radius]? ) <br />
			[constructor:RoundedBoxGeometry RoundedBoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number segments]?,  [param:number radius]?,  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) <br />
			[constructor:RoundedBoxGeometry RoundedBoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number segments]?,  [param:number radius]?,  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:RoundedBoxGeometry RoundedBoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number segments]?,  [param:number radius]?,  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:RoundedBoxGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BoxGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="SAOPass">SAOPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SAOPass SAOPass](  [param:Scene scene],  [param:Camera camera],  [param:boolean depthTexture]?,  [param:boolean useNormals]?,  [param:Vector2 resolution]? ) <br />
			[constructor:SAOPass SAOPass](  [param:Scene scene],  [param:Camera camera],  [param:boolean depthTexture]?,  [param:boolean useNormals]?,  [param:Vector2 resolution]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:OUTPUT OUTPUT] -  The o u t p u t.<br />
			[property:WebGLRenderTarget beautyRenderTarget] -  The beauty render target.<br />
			[property:WebGLRenderTarget blurIntermediateRenderTarget] -  The blur intermediate render target.<br />
			[property:Camera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:ShaderMaterial depthCopy] -  The depth copy.<br />
			[property:MeshDepthMaterial depthMaterial] -  The depth material.<br />
			[property:WebGLRenderTarget depthRenderTarget] -  The depth render target.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ShaderMaterial hBlurMaterial] -  The h blur material.<br />
			[property:ShaderMaterial materialCopy] -  The material copy.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:MeshNormalMaterial normalMaterial] -  The normal material.<br />
			[property:WebGLRenderTarget normalRenderTarget] -  The normal render target.<br />
			[property:number oldClearAlpha] -  The old clear alpha.<br />
			[property:Color oldClearColor] -  The old clear color.<br />
			[property:Color originalClearColor] -  The original clear color.<br />
			[property:SAOPassParams params] -  The params.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:Vector2 resolution] -  The resolution.<br />
			[property:ShaderMaterial saoMaterial] -  The sao material.<br />
			[property:WebGLRenderTarget saoRenderTarget] -  The sao render target.<br />
			[property:Scene scene] -  The scene.<br />
			[property:boolean supportsDepthTextureExtension] -  The supports depth texture extension.<br />
			[property:boolean supportsNormalTexture] -  The supports normal texture.<br />
			[property:ShaderMaterial vBlurMaterial] -  The v blur material.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void renderOverride](  [param:WebGLRenderer renderer],  [param:Material overrideMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor]?,  [param:number clearAlpha]? ) <br />
			[method:void renderPass](  [param:WebGLRenderer renderer],  [param:Material passMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor]?,  [param:number clearAlpha]? ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SAOPassParams">SAOPassParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:OUTPUT output] -  The output.<br />
			[property:number saoBias] -  The sao bias.<br />
			[property:boolean saoBlur] -  The sao blur.<br />
			[property:number saoBlurDepthCutoff] -  The sao blur depth cutoff.<br />
			[property:number saoBlurRadius] -  The sao blur radius.<br />
			[property:number saoBlurStdDev] -  The sao blur std dev.<br />
			[property:number saoIntensity] -  The sao intensity.<br />
			[property:number saoKernelRadius] -  The sao kernel radius.<br />
			[property:number saoMinResolution] -  The sao min resolution.<br />
			[property:number saoScale] -  The sao scale.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SAOShader">SAOShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SMAABlendShader">SMAABlendShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SMAAEdgesShader">SMAAEdgesShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="SMAAPass">SMAAPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SMAAPass SMAAPass](  [param:number width],  [param:number height] ) <br />
			[constructor:SMAAPass SMAAPass](  [param:number width],  [param:number height] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture areaTexture] -  The area texture.<br />
			[property:boolean clear] -  The clear.<br />
			[property:WebGLRenderTarget edgesRT] -  The edges r t.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ShaderMaterial materialBlend] -  The material blend.<br />
			[property:ShaderMaterial materialEdges] -  The material edges.<br />
			[property:ShaderMaterial materialWeights] -  The material weights.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:Texture searchTexture] -  The search texture.<br />
			[property:object uniformsBlend] -  The uniforms blend.<br />
			[property:object uniformsEdges] -  The uniforms edges.<br />
			[property:object uniformsWeights] -  The uniforms weights.<br />
			[property:WebGLRenderTarget weightsRT] -  The weights r t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:string getAreaTexture](  ) <br />
			[method:string getSearchTexture](  ) <br />
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SMAAWeightsShader">SMAAWeightsShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="SSAARenderPass">SSAARenderPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SSAARenderPass SSAARenderPass](  [param:Scene scene],  [param:Camera camera],  [param:ColorRepresentation clearColor],  [param:number clearAlpha] ) <br />
			[constructor:SSAARenderPass SSAARenderPass](  [param:Scene scene],  [param:Camera camera],  [param:ColorRepresentation clearColor],  [param:number clearAlpha] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Camera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:number clearAlpha] -  The clear alpha.<br />
			[property:ColorRepresentation clearColor] -  The clear color.<br />
			[property:ShaderMaterial copyMaterial] -  The copy material.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:number sampleLevel] -  The sample level.<br />
			[property:WebGLRenderTarget sampleRenderTarget] -  The sample render target.<br />
			[property:Scene scene] -  The scene.<br />
			[property:boolean unbiased] -  The unbiased.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SSAOBlurShader">SSAOBlurShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SSAODepthShader">SSAODepthShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="SSAOPass">SSAOPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SSAOPass SSAOPass](  [param:Scene scene],  [param:Camera camera],  [param:number width]?,  [param:number height]? ) <br />
			[constructor:SSAOPass SSAOPass](  [param:Scene scene],  [param:Camera camera],  [param:number width]?,  [param:number height]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:SSAOPassOUTPUT OUTPUT] -  The o u t p u t.<br />
			[property:WebGLRenderTarget beautyRenderTarget] -  The beauty render target.<br />
			[property:ShaderMaterial blurMaterial] -  The blur material.<br />
			[property:WebGLRenderTarget blurRenderTarget] -  The blur render target.<br />
			[property:Camera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:ShaderMaterial copyMaterial] -  The copy material.<br />
			[property:ShaderMaterial depthRenderMaterial] -  The depth render material.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:boolean height] -  The height.<br />
			[property:Vector3[] kernel] -  The kernel.<br />
			[property:number kernelRadius] -  The kernel radius.<br />
			[property:number kernelSize] -  The kernel size.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:DataTexture noiseTexture] -  The noise texture.<br />
			[property:MeshNormalMaterial normalMaterial] -  The normal material.<br />
			[property:WebGLRenderTarget normalRenderTarget] -  The normal render target.<br />
			[property:Color originalClearColor] -  The original clear color.<br />
			[property:SSAOPassOUTPUT output] -  The output.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:Scene scene] -  The scene.<br />
			[property:ShaderMaterial ssaoMaterial] -  The ssao material.<br />
			[property:WebGLRenderTarget ssaoRenderTarget] -  The ssao render target.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dipose](  ) <br />
			[method:void generateRandomKernelRotations](  ) <br />
			[method:Vector3[] generateSampleKernel](  ) <br />
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void renderOverride](  [param:WebGLRenderer renderer],  [param:Material overrideMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor]?,  [param:number clearAlpha]? ) <br />
			[method:void renderPass](  [param:WebGLRenderer renderer],  [param:Material passMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor]?,  [param:number clearAlpha]? ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SSAOShader">SSAOShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SSRBlurShader">SSRBlurShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SSRDepthShader">SSRDepthShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="SSRPass">SSRPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SSRPass SSRPass](  [param:SSRPassParams params] ) <br />
			[constructor:SSRPass SSRPass](  [param:SSRPassParams params] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any OUTPUT] -  The o u t p u t.<br />
			[property:WebGLRenderTarget beautyRenderTarget] -  The beauty render target.<br />
			[property:boolean blur] -  The blur.<br />
			[property:ShaderMaterial blurMaterial] -  The blur material.<br />
			[property:ShaderMaterial blurMaterial2] -  The blur material2.<br />
			[property:WebGLRenderTarget blurRenderTarget] -  The blur render target.<br />
			[property:WebGLRenderTarget blurRenderTarget2] -  The blur render target2.<br />
			[property:Camera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:ShaderMaterial copyMaterial] -  The copy material.<br />
			[property:ShaderMaterial depthRenderMaterial] -  The depth render material.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:FullScreenQuad fsQuad] -  The fs quad.<br />
			[property:Reflector groundReflector] -  The ground reflector.<br />
			[property:number height] -  The height.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:MeshBasicMaterial metalnessOffMaterial] -  The metalness off material.<br />
			[property:MeshBasicMaterial metalnessOnMaterial] -  The metalness on material.<br />
			[property:WebGLRenderTarget metalnessRenderTarget] -  The metalness render target.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:MeshNormalMaterial normalMaterial] -  The normal material.<br />
			[property:WebGLRenderTarget normalRenderTarget] -  The normal render target.<br />
			[property:number opacity] -  The opacity.<br />
			[property:Color originalClearColor] -  The original clear color.<br />
			[property:number output] -  The output.<br />
			[property:WebGLRenderTarget prevRenderTarget] -  The prev render target.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:Scene scene] -  The scene.<br />
			[property:boolean selective] -  The selective.<br />
			[property:ShaderMaterial ssrMaterial] -  The ssr material.<br />
			[property:WebGLRenderTarget ssrRenderTarget] -  The ssr render target.<br />
			[property:Color tempColor] -  The temp color.<br />
			[property:number thickTolerance] -  The thick tolerance.<br />
			[property:number thickness] -  The thickness.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void renderMetalness](  [param:WebGLRenderer renderer],  [param:Material passMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor],  [param:ColorRepresentation clearAlpha] ) <br />
			[method:void renderOverride](  [param:WebGLRenderer renderer],  [param:Material passMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor],  [param:ColorRepresentation clearAlpha] ) <br />
			[method:void renderPass](  [param:WebGLRenderer renderer],  [param:Material passMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor],  [param:ColorRepresentation clearAlpha] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SSRPassParams">SSRPassParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Camera camera] -  The camera.<br />
			[property:Reflector groundReflector] -  The ground reflector.<br />
			[property:number height]? -  The height.<br />
			[property:boolean isBouncing]? -  The is bouncing.<br />
			[property:boolean isPerspectiveCamera]? -  The is perspective camera.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:Scene scene] -  The scene.<br />
			[property:Mesh[] selects] -  The selects.<br />
			[property:number width]? -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SSRShader">SSRShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			References:<br />
			https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html
		</p>

		<hr class="interface-line"/>
		<h3 id="SSRrDepthShader">SSRrDepthShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="SSRrPass">SSRrPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SSRrPass SSRrPass](  [param:SSRrPassParams params] ) <br />
			[constructor:SSRrPass SSRrPass](  [param:SSRrPassParams params] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean _fillHole] -  The _fill hole.<br />
			[property:boolean _infiniteThick] -  The _infinite thick.<br />
			[property:boolean _specular] -  The _specular.<br />
			[property:WebGLRenderTarget beautyRenderTarget] -  The beauty render target.<br />
			[property:Camera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:Color color] -  The color.<br />
			[property:ShaderMaterial copyMaterial] -  The copy material.<br />
			[property:ShaderMaterial depthRenderMaterial] -  The depth render material.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:FullScreenQuad fsQuad] -  The fs quad.<br />
			[property:number height] -  The height.<br />
			[property:number ior] -  The ior.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:MeshNormalMaterial normalMaterial] -  The normal material.<br />
			[property:WebGLRenderTarget normalSelectsRenderTarget] -  The normal selects render target.<br />
			[property:Color originalClearColor] -  The original clear color.<br />
			[property:number output] -  The output.<br />
			[property:MeshBasicMaterial refractiveOffMaterial] -  The refractive off material.<br />
			[property:MeshBasicMaterial refractiveOnMaterial] -  The refractive on material.<br />
			[property:WebGLRenderTarget refractiveRenderTarget] -  The refractive render target.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:Scene scene] -  The scene.<br />
			[property:Mesh[] seleects] -  The seleects.<br />
			[property:MeshStandardMaterial specularMaterial] -  The specular material.<br />
			[property:WebGLRenderTarget specularRenderTarget] -  The specular render target.<br />
			[property:ShaderMaterial ssrrMaterial] -  The ssrr material.<br />
			[property:WebGLRenderTarget ssrrRenderTarget] -  The ssrr render target.<br />
			[property:number surfDist] -  The surf dist.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer] ) <br />
			[method:void renderOverride](  [param:WebGLRenderer renderer],  [param:Material passMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor],  [param:ColorRepresentation clearAlpha] ) <br />
			[method:void renderPass](  [param:WebGLRenderer renderer],  [param:Material passMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor],  [param:ColorRepresentation clearAlpha] ) <br />
			[method:void renderRefractive](  [param:WebGLRenderer renderer],  [param:Material passMaterial],  [param:WebGLRenderTarget renderTarget],  [param:ColorRepresentation clearColor],  [param:ColorRepresentation clearAlpha] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SSRrPassParams">SSRrPassParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Camera camera] -  The camera.<br />
			[property:number height]? -  The height.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:Scene scene] -  The scene.<br />
			[property:Mesh[] selects] -  The selects.<br />
			[property:number width]? -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SSRrShader">SSRrShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="STLExporter">STLExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:STLExporter STLExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:string parse](  [param:Object3D scene],  [param:STLExporterOptions options]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="STLExporterOptions">STLExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean binary]? -  The binary.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="STLLoader">STLLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:STLLoader STLLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:STLLoader STLLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:BufferGeometry parse](  [param:string|ArrayBuffer data] ) <br />
			[method:STLLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:STLLoader setPath](  [param:string path] ) <br />
			[method:STLLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:STLLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:STLLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="SVGLoader">SVGLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SVGLoader SVGLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:SVGLoader SVGLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number defaultDPI] -  The default d p i.<br />
			[property:string defaultUnit] -  The default unit.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Shape[] createShapes](  [param:ShapePath shapePath] ) <br />
			[method:StrokeStyle getStrokeStyle](  [param:number width]?,  [param:string color]?,  [param:string lineJoin]?,  [param:string lineCap]?,  [param:number miterLimit]? ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:SVGResult parse](  [param:string text] ) <br />
			[method:BufferGeometry pointsToStroke](  [param:Vector3[] points],  [param:StrokeStyle style],  [param:number arcDivisions]?,  [param:number minDistance]? ) <br />
			[method:number pointsToStrokeWithBuffers](  [param:Vector3[] points],  [param:StrokeStyle style],  [param:number arcDivisions]?,  [param:number minDistance]?,  [param:number[] vertices]?,  [param:number[] normals]?,  [param:number[] uvs]?,  [param:number vertexOffset]? ) <br />
			[method:SVGLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:SVGLoader setPath](  [param:string path] ) <br />
			[method:SVGLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:SVGLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:SVGLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="SVGObject">SVGObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SVGObject SVGObject](  [param:SVGElement node] ) - The constructor takes no arguments.<br />
			[constructor:SVGObject SVGObject](  [param:SVGElement node] ) - The constructor takes no arguments.<br />
			[constructor:SVGObject SVGObject](  [param:SVGElement node] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:SVGElement node] -  The node.
		</p>
		<h4>Methods</h4>
		<p>
			[method:SVGObject add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:SVGObject applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:SVGObject attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:SVGObject clear](  ) - Removes all child objects.<br />
			[method:SVGObject clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:SVGObject copy](  [param:SVGObject source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:SVGObject remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:SVGObject removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:SVGObject rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SVGObject rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:SVGObject rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:SVGObject rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:SVGObject rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:SVGObject translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SVGObject translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:SVGObject translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:SVGObject translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SVGRenderer">SVGRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SVGRenderer SVGRenderer](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoClear] -  The auto clear.<br />
			[property:SVGElement domElement] -  The dom element.<br />
			[property:any info] -  The info.<br />
			[property:number overdraw] -  The overdraw.<br />
			[property:boolean sortElements] -  The sort elements.<br />
			[property:boolean sortObjects] -  The sort objects.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void clear](  ) <br />
			[method:void getSize](  ) <br />
			[method:void render](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void setClearColor](  [param:Color color],  [param:number alpha] ) <br />
			[method:void setPixelRatio](  ) <br />
			[method:void setPrecision](  [param:number precision] ) <br />
			[method:void setQuality](  [param:string quality] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SVGResult">SVGResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:SVGResultPaths[] paths] -  The paths.<br />
			[property:XMLDocument xml] -  The xml.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ShapePath] &rarr;

		<h3 id="SVGResultPaths">SVGResultPaths <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SVGResultPaths SVGResultPaths](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any userData]? -  The user data.
		</p>
		<h4>Methods</h4>
		<p>
			[method:SVGResultPaths bezierCurveTo](  [param:number aCP1x],  [param:number aCP1y],  [param:number aCP2x],  [param:number aCP2y],  [param:number aX],  [param:number aY] ) <br />
			[method:SVGResultPaths lineTo](  [param:number x],  [param:number y] ) <br />
			[method:SVGResultPaths moveTo](  [param:number x],  [param:number y] ) <br />
			[method:SVGResultPaths quadraticCurveTo](  [param:number aCPx],  [param:number aCPy],  [param:number aX],  [param:number aY] ) <br />
			[method:SVGResultPaths splineThru](  [param:Vector2[] pts] ) <br />
			[method:Shape[] toShapes](  [param:boolean isCCW],  [param:boolean noHoles]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="SavePass">SavePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SavePass SavePass](  [param:WebGLRenderTarget renderTarget] ) <br />
			[constructor:SavePass SavePass](  [param:WebGLRenderTarget renderTarget] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:WebGLRenderTarget renderTarget] -  The render target.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Scene">Scene <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Scene Scene](  ) - The constructor takes no arguments.<br />
			[constructor:Scene Scene](  ) - The constructor takes no arguments.<br />
			[constructor:Scene Scene](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:Color|Texture background] -  The background.<br />
			[property:Texture environment] -  The environment.<br />
			[property:FogBase fog] - A fog instance defining the type of fog that affects everything rendered in the scene. Default is null.<br />
			[property:any isScene] -  The is scene.<br />
			[property:Material overrideMaterial] - If not null, it will force everything in the scene to be rendered with that material. Default is null.<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Scene add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Scene applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Scene attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Scene clear](  ) - Removes all child objects.<br />
			[method:Scene clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Scene copy](  [param:Scene source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera] ) - Calls after rendering scene<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:any renderTarget] ) - Calls before rendering scene<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:Scene remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Scene removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Scene rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Scene rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Scene rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Scene rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Scene rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Scene translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Scene translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Scene translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Scene translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.
		</p>

		<hr class="interface-line"/>
		<h3 id="SceneUtils">SceneUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void attach](  [param:Object3D child],  [param:Scene scene],  [param:Object3D parent] ) - deprecated - Use parent.attach( child ) instead.<br />
			[method:Group createMeshesFromInstancedMesh](  [param:InstancedMesh instancedMesh] ) <br />
			[method:Group createMultiMaterialObject](  [param:BufferGeometry geometry],  [param:Material[] materials] ) <br />
			[method:void detach](  [param:Object3D child],  [param:Object3D parent],  [param:Scene scene] ) - deprecated - Use scene.attach( child ) instead.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr; [page:TextureNode] &rarr;

		<h3 id="ScreenNode">ScreenNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ScreenNode ScreenNode](  [param:UVNode uv]? ) <br />
			[constructor:ScreenNode ScreenNode](  [param:UVNode uv]?,  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]? ) <br />
			[constructor:ScreenNode ScreenNode](  [param:UVNode uv]?,  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ScreenNode ScreenNode](  [param:UVNode uv]?,  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ScreenNode ScreenNode](  [param:UVNode uv]?,  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode bias] -  The bias.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean project] -  The project.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:UVNode|UVTransformNode uv] -  The uv.<br />
			[property:Texture value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ScreenNode copy](  [param:TextureNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getTexture](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ScreenNode setLabel](  [param:string name] ) <br />
			[method:ScreenNode setName](  [param:string name] ) <br />
			[method:ScreenNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="ScreenUVNode">ScreenUVNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ScreenUVNode ScreenUVNode](  [param:ResolutionNode resolution]? ) <br />
			[constructor:ScreenUVNode ScreenUVNode](  [param:ResolutionNode resolution]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:ScreenUVNode ScreenUVNode](  [param:ResolutionNode resolution]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:ResolutionNode resolution] -  The resolution.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ScreenUVNode copy](  [param:ScreenUVNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ScreenUVNode setLabel](  [param:string name] ) <br />
			[method:ScreenUVNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SelectionBox">SelectionBox <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SelectionBox SelectionBox](  [param:Camera camera],  [param:Scene scene],  [param:number deep]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Camera camera] -  The camera.<br />
			[property:Mesh[] collection] -  The collection.<br />
			[property:number deep] -  The deep.<br />
			[property:Vector3 endPoint] -  The end point.<br />
			[property:Scene scene] -  The scene.<br />
			[property:Vector3 startPoint] -  The start point.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void searchChildInFrustum](  [param:Frustum frustum],  [param:Object3D object] ) <br />
			[method:Mesh[] select](  [param:Vector3 startPoint]?,  [param:Vector3 endPoint]? ) <br />
			[method:void updateFrustum](  [param:Vector3 startPoint],  [param:Vector3 endPoint] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SelectionHelper">SelectionHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SelectionHelper SelectionHelper](  [param:SelectionBox selectionBox],  [param:WebGLRenderer renderer],  [param:string cssClassName] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement element] -  The element.<br />
			[property:boolean isDown] -  The is down.<br />
			[property:Vector2 pointBottomRight] -  The point bottom right.<br />
			[property:Vector2 pointTopLeft] -  The point top left.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:Vector2 startPoint] -  The start point.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void onSelectMove](  [param:Event event] ) <br />
			[method:void onSelectOver](  [param:Event event] ) <br />
			[method:void onSelectStart](  [param:Event event] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SepiaShader">SepiaShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SessionLightProbe">SessionLightProbe <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SessionLightProbe SessionLightProbe](  [param:XREstimatedLight xrLight],  [param:WebGLRenderer renderer],  [param:unknown lightProbe],  [param:boolean environmentEstimation],  [param:any estimationStartCallback] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:unknown lightProbe] -  The light probe.<br />
			[property:WebGLRenderer renderer] -  The renderer.<br />
			[property:XREstimatedLight xrLight] -  The xr light.<br />
			[property:unknown xrWebGLBinding] -  The xr web g l binding.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void estimationStartCallback](  ) <br />
			[method:void frameCallback](  [param:number time],  [param:XRFrame xrFrame] ) <br />
			[method:void onXRFrame](  [param:number time],  [param:XRFrame xrFrame] ) <br />
			[method:void updateReflection](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Shader">Shader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ShaderChunk">ShaderChunk <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string alphamap_fragment] -  The alphamap_fragment.<br />
			[property:string alphamap_pars_fragment] -  The alphamap_pars_fragment.<br />
			[property:string alphatest_fragment] -  The alphatest_fragment.<br />
			[property:string aomap_fragment] -  The aomap_fragment.<br />
			[property:string aomap_pars_fragment] -  The aomap_pars_fragment.<br />
			[property:string begin_vertex] -  The begin_vertex.<br />
			[property:string beginnormal_vertex] -  The beginnormal_vertex.<br />
			[property:string bsdfs] -  The bsdfs.<br />
			[property:string bumpmap_pars_fragment] -  The bumpmap_pars_fragment.<br />
			[property:string clearcoat_normal_fragment_begin] -  The clearcoat_normal_fragment_begin.<br />
			[property:string clearcoat_normal_fragment_maps] -  The clearcoat_normal_fragment_maps.<br />
			[property:string clearcoat_pars_fragment] -  The clearcoat_pars_fragment.<br />
			[property:string clipping_planes_fragment] -  The clipping_planes_fragment.<br />
			[property:string clipping_planes_pars_fragment] -  The clipping_planes_pars_fragment.<br />
			[property:string clipping_planes_pars_vertex] -  The clipping_planes_pars_vertex.<br />
			[property:string clipping_planes_vertex] -  The clipping_planes_vertex.<br />
			[property:string color_fragment] -  The color_fragment.<br />
			[property:string color_pars_fragment] -  The color_pars_fragment.<br />
			[property:string color_pars_vertex] -  The color_pars_vertex.<br />
			[property:string color_vertex] -  The color_vertex.<br />
			[property:string common] -  The common.<br />
			[property:string cube_frag] -  The cube_frag.<br />
			[property:string cube_uv_reflection_fragment] -  The cube_uv_reflection_fragment.<br />
			[property:string cube_vert] -  The cube_vert.<br />
			[property:string defaultnormal_vertex] -  The defaultnormal_vertex.<br />
			[property:string depth_frag] -  The depth_frag.<br />
			[property:string depth_vert] -  The depth_vert.<br />
			[property:string displacementmap_pars_vertex] -  The displacementmap_pars_vertex.<br />
			[property:string displacementmap_vertex] -  The displacementmap_vertex.<br />
			[property:string distanceRGBA_frag] -  The distance r g b a_frag.<br />
			[property:string distanceRGBA_vert] -  The distance r g b a_vert.<br />
			[property:string emissivemap_fragment] -  The emissivemap_fragment.<br />
			[property:string emissivemap_pars_fragment] -  The emissivemap_pars_fragment.<br />
			[property:string encodings_fragment] -  The encodings_fragment.<br />
			[property:string encodings_pars_fragment] -  The encodings_pars_fragment.<br />
			[property:string envmap_common_pars_fragment] -  The envmap_common_pars_fragment.<br />
			[property:string envmap_fragment] -  The envmap_fragment.<br />
			[property:string envmap_pars_fragment] -  The envmap_pars_fragment.<br />
			[property:string envmap_pars_vertex] -  The envmap_pars_vertex.<br />
			[property:string envmap_physical_pars_fragment] -  The envmap_physical_pars_fragment.<br />
			[property:string envmap_vertex] -  The envmap_vertex.<br />
			[property:string equirect_frag] -  The equirect_frag.<br />
			[property:string equirect_vert] -  The equirect_vert.<br />
			[property:string fog_fragment] -  The fog_fragment.<br />
			[property:string fog_pars_fragment] -  The fog_pars_fragment.<br />
			[property:string lightmap_fragment] -  The lightmap_fragment.<br />
			[property:string lightmap_pars_fragment] -  The lightmap_pars_fragment.<br />
			[property:string lights_fragment_begin] -  The lights_fragment_begin.<br />
			[property:string lights_fragment_end] -  The lights_fragment_end.<br />
			[property:string lights_fragment_maps] -  The lights_fragment_maps.<br />
			[property:string lights_lambert_vertex] -  The lights_lambert_vertex.<br />
			[property:string lights_pars_begin] -  The lights_pars_begin.<br />
			[property:string lights_pars_map] -  The lights_pars_map.<br />
			[property:string lights_phong_fragment] -  The lights_phong_fragment.<br />
			[property:string lights_phong_pars_fragment] -  The lights_phong_pars_fragment.<br />
			[property:string lights_physical_fragment] -  The lights_physical_fragment.<br />
			[property:string lights_physical_pars_fragment] -  The lights_physical_pars_fragment.<br />
			[property:string linedashed_frag] -  The linedashed_frag.<br />
			[property:string linedashed_vert] -  The linedashed_vert.<br />
			[property:string logdepthbuf_fragment] -  The logdepthbuf_fragment.<br />
			[property:string logdepthbuf_pars_fragment] -  The logdepthbuf_pars_fragment.<br />
			[property:string logdepthbuf_pars_vertex] -  The logdepthbuf_pars_vertex.<br />
			[property:string logdepthbuf_vertex] -  The logdepthbuf_vertex.<br />
			[property:string map_fragment] -  The map_fragment.<br />
			[property:string map_pars_fragment] -  The map_pars_fragment.<br />
			[property:string map_particle_fragment] -  The map_particle_fragment.<br />
			[property:string map_particle_pars_fragment] -  The map_particle_pars_fragment.<br />
			[property:string meshbasic_frag] -  The meshbasic_frag.<br />
			[property:string meshbasic_vert] -  The meshbasic_vert.<br />
			[property:string meshlambert_frag] -  The meshlambert_frag.<br />
			[property:string meshlambert_vert] -  The meshlambert_vert.<br />
			[property:string meshphong_frag] -  The meshphong_frag.<br />
			[property:string meshphong_vert] -  The meshphong_vert.<br />
			[property:string meshphysical_frag] -  The meshphysical_frag.<br />
			[property:string meshphysical_vert] -  The meshphysical_vert.<br />
			[property:string metalnessmap_fragment] -  The metalnessmap_fragment.<br />
			[property:string metalnessmap_pars_fragment] -  The metalnessmap_pars_fragment.<br />
			[property:string morphnormal_vertex] -  The morphnormal_vertex.<br />
			[property:string morphtarget_pars_vertex] -  The morphtarget_pars_vertex.<br />
			[property:string morphtarget_vertex] -  The morphtarget_vertex.<br />
			[property:string normal_flip] -  The normal_flip.<br />
			[property:string normal_frag] -  The normal_frag.<br />
			[property:string normal_fragment_begin] -  The normal_fragment_begin.<br />
			[property:string normal_fragment_maps] -  The normal_fragment_maps.<br />
			[property:string normal_vert] -  The normal_vert.<br />
			[property:string normalmap_pars_fragment] -  The normalmap_pars_fragment.<br />
			[property:string packing] -  The packing.<br />
			[property:string points_frag] -  The points_frag.<br />
			[property:string points_vert] -  The points_vert.<br />
			[property:string premultiplied_alpha_fragment] -  The premultiplied_alpha_fragment.<br />
			[property:string project_vertex] -  The project_vertex.<br />
			[property:string roughnessmap_fragment] -  The roughnessmap_fragment.<br />
			[property:string roughnessmap_pars_fragment] -  The roughnessmap_pars_fragment.<br />
			[property:string shadow_frag] -  The shadow_frag.<br />
			[property:string shadow_vert] -  The shadow_vert.<br />
			[property:string shadowmap_pars_fragment] -  The shadowmap_pars_fragment.<br />
			[property:string shadowmap_pars_vertex] -  The shadowmap_pars_vertex.<br />
			[property:string shadowmap_vertex] -  The shadowmap_vertex.<br />
			[property:string shadowmask_pars_fragment] -  The shadowmask_pars_fragment.<br />
			[property:string skinbase_vertex] -  The skinbase_vertex.<br />
			[property:string skinning_pars_vertex] -  The skinning_pars_vertex.<br />
			[property:string skinning_vertex] -  The skinning_vertex.<br />
			[property:string skinnormal_vertex] -  The skinnormal_vertex.<br />
			[property:string specularmap_fragment] -  The specularmap_fragment.<br />
			[property:string specularmap_pars_fragment] -  The specularmap_pars_fragment.<br />
			[property:string tonemapping_fragment] -  The tonemapping_fragment.<br />
			[property:string tonemapping_pars_fragment] -  The tonemapping_pars_fragment.<br />
			[property:string uv2_pars_fragment] -  The uv2_pars_fragment.<br />
			[property:string uv2_pars_vertex] -  The uv2_pars_vertex.<br />
			[property:string uv2_vertex] -  The uv2_vertex.<br />
			[property:string uv_pars_fragment] -  The uv_pars_fragment.<br />
			[property:string uv_pars_vertex] -  The uv_pars_vertex.<br />
			[property:string uv_vertex] -  The uv_vertex.<br />
			[property:string worldpos_vertex] -  The worldpos_vertex.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ShaderLib">ShaderLib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Shader background] -  The background.<br />
			[property:Shader basic] -  The basic.<br />
			[property:Shader cube] -  The cube.<br />
			[property:Shader dashed] -  The dashed.<br />
			[property:Shader depth] -  The depth.<br />
			[property:Shader distanceRGBA] -  The distance r g b a.<br />
			[property:Shader equirect] -  The equirect.<br />
			[property:Shader lambert] -  The lambert.<br />
			[property:Shader matcap] -  The matcap.<br />
			[property:Shader normal] -  The normal.<br />
			[property:Shader phong] -  The phong.<br />
			[property:Shader physical] -  The physical.<br />
			[property:Shader points] -  The points.<br />
			[property:Shader shadow] -  The shadow.<br />
			[property:Shader sprite] -  The sprite.<br />
			[property:Shader standard] -  The standard.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="ShaderMaterial">ShaderMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ShaderMaterial ShaderMaterial](  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:ShaderMaterial ShaderMaterial](  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:ShaderMaterial ShaderMaterial](  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] - deprecated - Use {@link ShaderMaterial#extensions.derivatives extensions.derivatives} instead.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:ShaderMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:ShaderMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="ShaderMaterialParameters">ShaderMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:boolean clipping]? -  The clipping.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:any extensions]? -  The extensions.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string fragmentShader]? -  The fragment shader.<br />
			[property:GLSLVersion glslVersion]? -  The glsl version.<br />
			[property:boolean lights]? -  The lights.<br />
			[property:number linewidth]? -  The linewidth.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any uniforms]? -  The uniforms.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:string vertexShader]? -  The vertex shader.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="ShaderPass">ShaderPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ShaderPass ShaderPass](  [param:object shader],  [param:string textureID]? ) <br />
			[constructor:ShaderPass ShaderPass](  [param:object shader],  [param:string textureID]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ShadowMapViewer">ShadowMapViewer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ShadowMapViewer ShadowMapViewer](  [param:Light light] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean enabled] -  The enabled.<br />
			[property:Position position] -  The position.<br />
			[property:Size size] -  The size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:Renderer renderer] ) <br />
			[method:void update](  ) <br />
			[method:void updateForWindowResize](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="ShadowMaterial">ShadowMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ShadowMaterial ShadowMaterial](  [param:ShadowMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:ShadowMaterial ShadowMaterial](  [param:ShadowMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:ShadowMaterial ShadowMaterial](  [param:ShadowMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] -  The transparent.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:ShadowMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:ShadowMaterial copy](  [param:Material material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:MaterialParameters values] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="ShadowMaterialParameters">ShadowMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="ShadowMesh">ShadowMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ShadowMesh ShadowMesh](  [param:Mesh mesh] ) <br />
			[constructor:ShadowMesh ShadowMesh](  [param:Mesh mesh],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:ShadowMesh ShadowMesh](  [param:Mesh mesh],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:ShadowMesh ShadowMesh](  [param:Mesh mesh],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ShadowMesh add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:ShadowMesh applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:ShadowMesh attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:ShadowMesh clear](  ) - Removes all child objects.<br />
			[method:ShadowMesh clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:ShadowMesh copy](  [param:ShadowMesh source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:ShadowMesh remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:ShadowMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ShadowMesh rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ShadowMesh rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:ShadowMesh rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:ShadowMesh rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:ShadowMesh rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ShadowMesh translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ShadowMesh translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:ShadowMesh translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:ShadowMesh translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  [param:Plane plane],  [param:Vector4 lightPosition4D] ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr; [page:CurvePath] &rarr; [page:Path] &rarr;

		<h3 id="Shape">Shape <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Shape Shape](  [param:Vector2[] points]? ) <br />
			[constructor:Shape Shape](  [param:Vector2[] points]?,  [param:Vector2[] points]? ) <br />
			[constructor:Shape Shape](  [param:Vector2[] points]?,  [param:Vector2[] points]? ) <br />
			[constructor:Shape Shape](  [param:Vector2[] points]?,  [param:Vector2[] points]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:boolean autoClose] -  The auto close.<br />
			[property:Vector2 currentPoint] -  The current point.<br />
			[property:Curve[] curves] -  The curves.<br />
			[property:Path[] holes] -  The holes.<br />
			[property:string type] -  The type.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Shape absarc](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[method:Shape absellipse](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[method:void add](  [param:Curve curve] ) <br />
			[method:Shape arc](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[method:Shape bezierCurveTo](  [param:number aCP1x],  [param:number aCP1y],  [param:number aCP2x],  [param:number aCP2y],  [param:number aX],  [param:number aY] ) <br />
			[method:Shape clone](  ) <br />
			[method:void closePath](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:Shape copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:Shape ellipse](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[method:void extractPoints](  [param:number divisions] ) <br />
			[method:Shape fromJSON](  [param:object json] ) <br />
			[method:Shape fromPoints](  [param:Vector2[] vectors] ) - deprecated - Use {@link Path#setFromPoints .setFromPoints()} instead.<br />
			[method:number[] getCurveLengths](  ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:void getPointsHoles](  [param:number divisions] ) <br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:Shape lineTo](  [param:number x],  [param:number y] ) <br />
			[method:Shape moveTo](  [param:number x],  [param:number y] ) <br />
			[method:Shape quadraticCurveTo](  [param:number aCPx],  [param:number aCPy],  [param:number aX],  [param:number aY] ) <br />
			[method:Shape setFromPoints](  [param:Vector2[] vectors] ) <br />
			[method:Shape splineThru](  [param:Vector2[] pts] ) <br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			Defines a 2d shape plane using paths.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="ShapeBufferGeometry">ShapeBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ShapeGeometry ShapeGeometry](  [param:Shape|Shape[] shapes]?,  [param:number curveSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ShapeGeometry ShapeGeometry](  [param:Shape|Shape[] shapes]?,  [param:number curveSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ShapeGeometry ShapeGeometry](  [param:Shape|Shape[] shapes]?,  [param:number curveSegments]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ShapeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:ShapeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="ShapeGeometry">ShapeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ShapeGeometry ShapeGeometry](  [param:Shape|Shape[] shapes]?,  [param:number curveSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ShapeGeometry ShapeGeometry](  [param:Shape|Shape[] shapes]?,  [param:number curveSegments]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:ShapeGeometry ShapeGeometry](  [param:Shape|Shape[] shapes]?,  [param:number curveSegments]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ShapeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:ShapeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ShapePath">ShapePath <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ShapePath ShapePath](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Color color] -  The color.<br />
			[property:any currentPath] -  The current path.<br />
			[property:any[] subPaths] -  The sub paths.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ShapePath bezierCurveTo](  [param:number aCP1x],  [param:number aCP1y],  [param:number aCP2x],  [param:number aCP2y],  [param:number aX],  [param:number aY] ) <br />
			[method:ShapePath lineTo](  [param:number x],  [param:number y] ) <br />
			[method:ShapePath moveTo](  [param:number x],  [param:number y] ) <br />
			[method:ShapePath quadraticCurveTo](  [param:number aCPx],  [param:number aCPy],  [param:number aX],  [param:number aY] ) <br />
			[method:ShapePath splineThru](  [param:Vector2[] pts] ) <br />
			[method:Shape[] toShapes](  [param:boolean isCCW],  [param:boolean noHoles]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ShapeUtils">ShapeUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:number area](  [param:Vec2[] contour] ) <br />
			[method:boolean isClockWise](  [param:Vec2[] pts] ) <br />
			[method:void triangulateShape](  [param:Vec2[] contour],  [param:any holes] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SimplexNoise">SimplexNoise <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SimplexNoise SimplexNoise](  [param:object r]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:number dot](  [param:number[] g],  [param:number x],  [param:number y] ) <br />
			[method:number dot3](  [param:number[] g],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:number dot4](  [param:number[] g],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:number noise](  [param:number xin],  [param:number yin] ) <br />
			[method:number noise3d](  [param:number xin],  [param:number yin],  [param:number zin] ) <br />
			[method:number noise4d](  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SimplifyModifier">SimplifyModifier <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SimplifyModifier SimplifyModifier](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry modify](  [param:BufferGeometry geometry],  [param:number count] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Size">Size <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number height] -  The height.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void set](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Skeleton">Skeleton <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Skeleton Skeleton](  [param:Bone[] bones],  [param:Matrix4[] boneInverses]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Matrix4[] boneInverses] -  The bone inverses.<br />
			[property:Float32Array boneMatrices] -  The bone matrices.<br />
			[property:DataTexture boneTexture] -  The bone texture.<br />
			[property:number boneTextureSize] -  The bone texture size.<br />
			[property:Bone[] bones] -  The bones.<br />
			[property:number frame] -  The frame.<br />
			[property:boolean useVertexTexture] - deprecated - This property has been removed completely.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void calculateInverses](  ) <br />
			[method:Skeleton clone](  ) <br />
			[method:Skeleton computeBoneTexture](  ) <br />
			[method:void dispose](  ) <br />
			[method:Bone getBoneByName](  [param:string name] ) <br />
			[method:void init](  ) <br />
			[method:void pose](  ) <br />
			[method:void update](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="SkeletonHelper">SkeletonHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SkeletonHelper SkeletonHelper](  [param:Object3D object] ) <br />
			[constructor:SkeletonHelper SkeletonHelper](  [param:Object3D object],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:SkeletonHelper SkeletonHelper](  [param:Object3D object],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:SkeletonHelper SkeletonHelper](  [param:Object3D object],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:SkeletonHelper SkeletonHelper](  [param:Object3D object],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Bone[] bones] -  The bones.<br />
			[property:any isSkeletonHelper] -  The is skeleton helper.<br />
			[property:Matrix4 matrix] - The local transform matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:Object3D root] -  The root.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:SkeletonHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:SkeletonHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:SkeletonHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:SkeletonHelper clear](  ) - Removes all child objects.<br />
			[method:SkeletonHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:SkeletonHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:SkeletonHelper copy](  [param:SkeletonHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Bone[] getBoneList](  [param:Object3D object] ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:SkeletonHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:SkeletonHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:SkeletonHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SkeletonHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:SkeletonHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:SkeletonHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:SkeletonHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:SkeletonHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SkeletonHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:SkeletonHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:SkeletonHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SkeletonUtils">SkeletonUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:Object3D clone](  [param:Object3D source] ) <br />
			[method:void findBoneTrackData](  [param:string name],  [param:any[] tracks] ) <br />
			[method:Bone getBoneByName](  [param:string name],  [param:Skeleton skeleton] ) <br />
			[method:Bone[] getBones](  [param:Skeleton|Bone[] skeleton] ) <br />
			[method:string[] getEqualsBonesNames](  [param:Skeleton skeleton],  [param:Skeleton targetSkeleton] ) <br />
			[method:SkeletonHelper getHelperFromSkeleton](  [param:Skeleton skeleton] ) <br />
			[method:Bone getNearestBone](  [param:Bone bone],  [param:any names] ) <br />
			[method:Matrix4[] getSkeletonOffsets](  [param:Object3D|Skeleton target],  [param:Object3D|Skeleton source],  [param:any options] ) <br />
			[method:any renameBones](  [param:Skeleton skeleton],  [param:any names] ) <br />
			[method:void retarget](  [param:Object3D|Skeleton target],  [param:Object3D|Skeleton source],  [param:any options] ) <br />
			[method:AnimationClip retargetClip](  [param:Object3D|Skeleton target],  [param:Object3D|Skeleton source],  [param:AnimationClip clip],  [param:any options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="SkinnedMesh">SkinnedMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SkinnedMesh SkinnedMesh](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:boolean useVertexTexture]? ) <br />
			[constructor:SkinnedMesh SkinnedMesh](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:boolean useVertexTexture]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:SkinnedMesh SkinnedMesh](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:boolean useVertexTexture]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - The constructor takes no arguments.<br />
			[constructor:SkinnedMesh SkinnedMesh](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:boolean useVertexTexture]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Matrix4 bindMatrix] -  The bind matrix.<br />
			[property:Matrix4 bindMatrixInverse] -  The bind matrix inverse.<br />
			[property:string bindMode] -  The bind mode.<br />
			[property:TGeometry geometry] - An instance of [page:BufferGeometry BufferGeometry] (or derived classes), defining the object's structure.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isSkinnedMesh] -  The is skinned mesh.<br />
			[property:TMaterial material] - An instance of material derived from the [page:Material Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial MeshBasicMaterial].<br />
			[property:any morphTargetDictionary]? - A dictionary of morphTargets based on the morphTarget.name property.<br />
			Undefined by default, but rebuilt [page:Mesh.updateMorphTargets updateMorphTargets].<br />
			[property:number[] morphTargetInfluences]? - An array of weights typically from 0-1 that specify how much of the morph is applied.<br />
			Undefined by default, but reset to a blank array by [page:Mesh.updateMorphTargets updateMorphTargets].<br />
			[property:Skeleton skeleton] -  The skeleton.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:SkinnedMesh add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:SkinnedMesh applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:SkinnedMesh attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:void bind](  [param:Skeleton skeleton],  [param:Matrix4 bindMatrix]? ) <br />
			[method:Vector3 boneTransform](  [param:number index],  [param:Vector3 target] ) <br />
			[method:SkinnedMesh clear](  ) - Removes all child objects.<br />
			[method:SkinnedMesh clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:SkinnedMesh copy](  [param:SkinnedMesh source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void normalizeSkinWeights](  ) <br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void pose](  ) <br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:SkinnedMesh remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:SkinnedMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:SkinnedMesh rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SkinnedMesh rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:SkinnedMesh rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:SkinnedMesh rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:SkinnedMesh rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:SkinnedMesh translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SkinnedMesh translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:SkinnedMesh translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:SkinnedMesh translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SobelOperatorShader">SobelOperatorShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="SpecularMIPLevelNode">SpecularMIPLevelNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SpecularMIPLevelNode SpecularMIPLevelNode](  [param:NodeNode texture] ) <br />
			[constructor:SpecularMIPLevelNode SpecularMIPLevelNode](  [param:NodeNode texture],  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:SpecularMIPLevelNode SpecularMIPLevelNode](  [param:NodeNode texture],  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:MaxMIPLevelNode maxMIPLevel] -  The max m i p level.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:NodeNode texture] -  The texture.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:SpecularMIPLevelNode copy](  [param:SpecularMIPLevelNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:SpecularMIPLevelNode setLabel](  [param:string name] ) <br />
			[method:SpecularMIPLevelNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Sphere">Sphere <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Sphere Sphere](  [param:Vector3 center]?,  [param:number radius]? ) - Creates a new Sphere.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Vector3 center] - A [page:Vector3 Vector3] defining the center of the sphere. Default is (0, 0, 0).<br />
			[property:number radius] - The radius of the sphere. Default is -1.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Sphere applyMatrix4](  [param:Matrix4 matrix] ) <br />
			[method:Vector3 clampPoint](  [param:Vector3 point],  [param:Vector3 target] ) - Clamps a point within the sphere. If the point is outside the sphere, it will clamp it to the closest point on the edge of the sphere. Points already inside the sphere will not be affected.<br />
			[method:Sphere clone](  ) - Returns : Returns a new sphere with the same *.center* and *.radius* as this one.<br />
			[method:boolean containsPoint](  [param:Vector3 point] ) <br />
			[method:Sphere copy](  [param:Sphere sphere] ) - Copies the values of the passed sphere's *.center* and *.radius*<br />
			properties to this sphere.<br />
			[method:number distanceToPoint](  [param:Vector3 point] ) - Returns : Returns the closest distance from the boundary of the sphere to the [page:Vector3 point]. If the sphere contains the point, the distance will be negative.<br />
			[method:any empty](  ) - deprecated - Use {@link Sphere#isEmpty .isEmpty()} instead.<br />
			[method:boolean equals](  [param:Sphere sphere] ) - Checks to see if the two spheres' centers and radii are equal.<br />
			[method:Sphere expandByPoint](  [param:Vector3 point] ) - Expands the boundaries of this sphere to include [page:Vector3 point].<br />
			[method:Box3 getBoundingBox](  [param:Box3 target] ) - Returns : Returns a[link:https://en.wikipedia.org/wiki/Minimum_bounding_box Minimum Bounding Box] for the sphere.<br />
			[method:boolean intersectsBox](  [param:Box3 box] ) - Determines whether or not this sphere intersects a given [page:Box3 box].<br />
			[method:boolean intersectsPlane](  [param:Plane plane] ) <br />
			[method:boolean intersectsSphere](  [param:Sphere sphere] ) - Checks to see if two spheres intersect.<br />
			[method:boolean isEmpty](  ) - Checks to see if the sphere is empty (the radius set to a negative number).&lt;/br&gt;<br />
			Spheres with a radius of 0 contain only their center point and are not considered to be empty.<br />
			[method:Sphere makeEmpty](  ) - Makes the sphere empty by setting *.center* to (0, 0, 0) and *.radius* to -1.<br />
			[method:Sphere set](  [param:Vector3 center],  [param:number radius] ) - Sets the *.center* and *.radius* properties of this sphere.<br />
			Please note that this method only copies the values from the given center.<br />
			[method:Sphere setFromPoints](  [param:Vector3[] points],  [param:Vector3 optionalCenter]? ) - Computes the minimum bounding sphere for an array of [page:Array points]. If  [page:Vector3 optionalCenter]is given, it is used as the sphere's center. Otherwise, the center of the axis-aligned bounding box encompassing [page:Array points] is calculated.<br />
			[method:Sphere translate](  [param:Vector3 offset] ) <br />
			[method:Sphere union](  [param:Sphere sphere] ) - Expands this sphere to enclose both the original sphere and the given sphere.
		</p>

		<p class="desc">
			A sphere defined by a center and radius.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="SphereBufferGeometry">SphereBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SphereGeometry SphereGeometry](  [param:number radius]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:SphereGeometry SphereGeometry](  [param:number radius]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:SphereGeometry SphereGeometry](  [param:number radius]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:SphereGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:SphereGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="SphereGeometry">SphereGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SphereGeometry SphereGeometry](  [param:number radius]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:SphereGeometry SphereGeometry](  [param:number radius]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:SphereGeometry SphereGeometry](  [param:number radius]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:SphereGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:SphereGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Spherical">Spherical <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Spherical Spherical](  [param:number radius]?,  [param:number phi]?,  [param:number theta]? ) - The poles (phi) are at the positive and negative y axis. The equator (theta) starts at positive z.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number phi] - polar angle in radians from the y (up) axis. Default is *0*.<br />
			[property:number radius] - the radius, or the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean distance] (straight-line distance) from the point to the origin. Default is *1.0*.<br />
			[property:number theta] - equator angle in radians around the y (up) axis. Default is *0*.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Spherical clone](  ) - Returns : Returns a new spherical with the same *.radius*, *.phi* and *.theta* properties as this one.<br />
			[method:Spherical copy](  [param:Spherical other] ) - Copies the values of the passed Spherical's *.radius*, *.phi* and *.theta* properties to this spherical.<br />
			[method:Spherical makeSafe](  ) - Restricts the polar angle *.phi* to be between 0.000001 and pi - 0.000001.<br />
			[method:Spherical set](  [param:number radius],  [param:number phi],  [param:number theta] ) - Sets values of this spherical's *.radius*, *.phi* and *.theta* properties.<br />
			[method:Spherical setFromCartesianCoords](  [param:number x],  [param:number y],  [param:number z] ) - Sets values of this spherical's *.radius*, *.phi* and *.theta* properties from Cartesian coordinates.<br />
			[method:Spherical setFromVector3](  [param:Vector3 v] ) - Sets values of this spherical's *.radius*, *.phi* and *.theta* properties from the [page:Vector3 Vector3].
		</p>

		<p class="desc">
			A point's [link:https://en.wikipedia.org/wiki/Spherical_coordinate_system spherical coordinates].
		</p>

		<hr class="interface-line"/>
		<h3 id="SphericalHarmonics3">SphericalHarmonics3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SphericalHarmonics3 SphericalHarmonics3](  ) - Creates a new instance of SphericalHarmonics3.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Vector3[] coefficients] - An array holding the (9) SH coefficients. A single coefficient is represented as an instance of [page:Vector3 Vector3].<br />
			[property:any isSphericalHarmonics3] -  The is spherical harmonics3.
		</p>
		<h4>Methods</h4>
		<p>
			[method:SphericalHarmonics3 add](  [param:SphericalHarmonics3 sh] ) - Adds the given SH to this instance.<br />
			[method:SphericalHarmonics3 addScaledSH](  [param:SphericalHarmonics3 sh],  [param:number s] ) - A convenience method for performing *.add*() and *.scale*() at once.<br />
			[method:SphericalHarmonics3 clone](  ) - Returns : Returns a new instance of [name] with equal coefficients.<br />
			[method:SphericalHarmonics3 copy](  [param:SphericalHarmonics3 sh] ) - Copies the given SH to this instance.<br />
			[method:boolean equals](  [param:SphericalHarmonics3 sh] ) - Returns : Returns true if the given SH and this instance have equal coefficients.<br />
			[method:SphericalHarmonics3 fromArray](  [param:ArrayLike|number[] array],  [param:number offset]? ) - Sets the coefficients of this instance from the given array.<br />
			[method:Vector3 getAt](  [param:Vector3 normal],  [param:Vector3 target] ) - Returns : Returns the radiance in the direction of the given normal.<br />
			[method:void getBasisAt](  [param:Vector3 normal],  [param:number[] shBasis] ) - Computes the SH basis for the given normal vector.<br />
			[method:Vector3 getIrradianceAt](  [param:Vector3 normal],  [param:Vector3 target] ) - Returns : Returns the irradiance (radiance convolved with cosine lobe) in the direction of the given normal.<br />
			[method:SphericalHarmonics3 lerp](  [param:SphericalHarmonics3 sh],  [param:number alpha] ) - Linear interpolates between the given SH and this instance by the given alpha factor.<br />
			[method:SphericalHarmonics3 scale](  [param:number s] ) - Scales this SH by the given scale factor.<br />
			[method:SphericalHarmonics3 set](  [param:Vector3[] coefficients] ) - Sets the given SH coefficients to this instance.<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns : Returns an array with the coefficients, or copies them into the provided array. The coefficients are represented as numbers.<br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:ArrayLike array],  [param:number offset]? ) - Returns an array with the values of this spherical harmonics, or copies them into the provided array-like.<br />
			<br />
			Returns : The provided array-like.<br />
			[method:SphericalHarmonics3 zero](  ) - Sets all SH coefficients to 0.
		</p>

		<p class="desc">
			Represents a third-order spherical harmonics (SH). Light probes use this class to encode lighting information.
		</p>

		<hr class="interface-line"/>
		[page:Curve] &rarr;

		<h3 id="SplineCurve">SplineCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SplineCurve SplineCurve](  [param:Vector2[] points]? ) <br />
			[constructor:SplineCurve SplineCurve](  [param:Vector2[] points]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:Vector2[] points] -  The points.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:SplineCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:SplineCurve copy](  [param:Curve source] ) <br />
			[method:void create](  [param:any constructorFunc],  [param:any getPointFunc] ) - deprecated - since r84.<br />
			[method:SplineCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:Vector2 getPoint](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getPointAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:Vector2[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:Vector2[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:Vector2 getTangent](  [param:number t],  [param:Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:Vector2 getTangentAt](  [param:number u],  [param:Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SplineUniform">SplineUniform <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Uniform flow] -  The flow.<br />
			[property:Uniform pathOffset] -  The path offset.<br />
			[property:Uniform pathSegment] -  The path segment.<br />
			[property:Uniform spineOffset] -  The spine offset.<br />
			[property:Uniform spineTexture] -  The spine texture.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Light] &rarr;

		<h3 id="SpotLight">SpotLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SpotLight SpotLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number angle]?,  [param:number penumbra]?,  [param:number decay]? ) - The constructor takes no arguments.<br />
			[constructor:SpotLight SpotLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number angle]?,  [param:number penumbra]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:SpotLight SpotLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number angle]?,  [param:number penumbra]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) - The constructor takes no arguments.<br />
			[constructor:SpotLight SpotLight](  [param:ColorRepresentation color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number angle]?,  [param:number penumbra]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number angle] - Maximum extent of the spotlight, in radians, from its direction.<br />
			[property:Color color] -  The color.<br />
			[property:number decay] -  The decay.<br />
			[property:number distance] - If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.<br />
			[property:number intensity] - Light's intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isSpotLight] -  The is spot light.<br />
			[property:number penumbra] -  The penumbra.<br />
			[property:Vector3 position] -  The position.<br />
			[property:number power] -  The power.<br />
			[property:SpotLightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] - deprecated - Use shadow.bias instead.<br />
			[property:any shadowCameraBottom] - deprecated - Use shadow.camera.bottom instead.<br />
			[property:any shadowCameraFar] - deprecated - Use shadow.camera.far instead.<br />
			[property:any shadowCameraFov] - deprecated - Use shadow.camera.fov instead.<br />
			[property:any shadowCameraLeft] - deprecated - Use shadow.camera.left instead.<br />
			[property:any shadowCameraNear] - deprecated - Use shadow.camera.near instead.<br />
			[property:any shadowCameraRight] - deprecated - Use shadow.camera.right instead.<br />
			[property:any shadowCameraTop] - deprecated - Use shadow.camera.top instead.<br />
			[property:any shadowMapHeight] - deprecated - Use shadow.mapSize.height instead.<br />
			[property:any shadowMapWidth] - deprecated - Use shadow.mapSize.width instead.<br />
			[property:Object3D target] - Spotlight focus points at target.position.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:SpotLight add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:SpotLight applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:SpotLight attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:SpotLight clear](  ) - Removes all child objects.<br />
			[method:SpotLight clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:SpotLight copy](  [param:SpotLight source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:SpotLight remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:SpotLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:SpotLight rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SpotLight rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:SpotLight rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:SpotLight rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:SpotLight rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:SpotLight translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SpotLight translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:SpotLight translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:SpotLight translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			A point light that can cast shadow in one direction.
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="SpotLightHelper">SpotLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SpotLightHelper SpotLightHelper](  [param:Light light],  [param:ColorRepresentation color]? ) - The constructor takes no arguments.<br />
			[constructor:SpotLightHelper SpotLightHelper](  [param:Light light],  [param:ColorRepresentation color]? ) - The constructor takes no arguments.<br />
			[constructor:SpotLightHelper SpotLightHelper](  [param:Light light],  [param:ColorRepresentation color]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:ColorRepresentation color] -  The color.<br />
			[property:LineSegments cone] -  The cone.<br />
			[property:Light light] -  The light.<br />
			[property:Matrix4 matrix] - The local transform matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.
		</p>
		<h4>Methods</h4>
		<p>
			[method:SpotLightHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:SpotLightHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:SpotLightHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:SpotLightHelper clear](  ) - Removes all child objects.<br />
			[method:SpotLightHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:SpotLightHelper copy](  [param:SpotLightHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:SpotLightHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:SpotLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:SpotLightHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SpotLightHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:SpotLightHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:SpotLightHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:SpotLightHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:SpotLightHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:SpotLightHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:SpotLightHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:SpotLightHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:LightShadow] &rarr;

		<h3 id="SpotLightShadow">SpotLightShadow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SpotLightShadow SpotLightShadow](  [param:Camera camera] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:number bias] -  The bias.<br />
			[property:number blurSamples] -  The blur samples.<br />
			[property:PerspectiveCamera camera] -  The camera.<br />
			[property:number focus] -  The focus.<br />
			[property:any isSpotLightShadow] -  The is spot light shadow.<br />
			[property:WebGLRenderTarget map] -  The map.<br />
			[property:WebGLRenderTarget mapPass] -  The map pass.<br />
			[property:Vector2 mapSize] -  The map size.<br />
			[property:Matrix4 matrix] -  The matrix.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number normalBias] -  The normal bias.<br />
			[property:number radius] -  The radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:SpotLightShadow clone](  [param:boolean recursive]? ) <br />
			[method:SpotLightShadow copy](  [param:LightShadow source] ) <br />
			[method:void dispose](  ) <br />
			[method:Vector2 getFrameExtents](  ) <br />
			[method:number getFrustum](  ) <br />
			[method:Vector4 getViewport](  [param:number viewportIndex] ) <br />
			[method:any toJSON](  ) <br />
			[method:void updateMatrices](  [param:Light light],  [param:number viewportIndex]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="Sprite">Sprite <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Sprite Sprite](  [param:SpriteMaterial material]? ) - The constructor takes no arguments.<br />
			[constructor:Sprite Sprite](  [param:SpriteMaterial material]? ) - The constructor takes no arguments.<br />
			[constructor:Sprite Sprite](  [param:SpriteMaterial material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Vector2 center] -  The center.<br />
			[property:BufferGeometry geometry] - The BufferGeometry<br />
			[property:any isSprite] -  The is sprite.<br />
			[property:SpriteMaterial material] - The Material<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Sprite add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Sprite applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Sprite attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Sprite clear](  ) - Removes all child objects.<br />
			[method:Sprite clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Sprite copy](  [param:Sprite source] ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:Sprite remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Sprite removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Sprite rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Sprite rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Sprite rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Sprite rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Sprite rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Sprite translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Sprite translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Sprite translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Sprite translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr;

		<h3 id="SpriteMaterial">SpriteMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SpriteMaterial SpriteMaterial](  [param:SpriteMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:SpriteMaterial SpriteMaterial](  [param:SpriteMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:SpriteMaterial SpriteMaterial](  [param:SpriteMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as THREE.Plane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:Color color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to THREE.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:any isSpriteMaterial] -  The is sprite material.<br />
			[property:Texture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number rotation] -  The rotation.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.<br />
			[property:boolean sizeAttenuation] -  The size attenuation.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] -  The transparent.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:SpriteMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:SpriteMaterial copy](  [param:SpriteMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:SpriteMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:MaterialParameters] &rarr;

		<h3 id="SpriteMaterialParameters">SpriteMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Texture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|SrcAlphaSaturateFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:Plane[] clippingPlanes]? -  The clipping planes.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:Texture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number rotation]? -  The rotation.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:boolean sizeAttenuation]? -  The size attenuation.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr;

		<h3 id="SpriteNode">SpriteNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SpriteNode SpriteNode](  ) <br />
			[constructor:SpriteNode SpriteNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:any spherical] -  The spherical.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder] ) <br />
			[method:SpriteNode copy](  [param:SpriteNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:SpriteNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:ShaderMaterial] &rarr; [page:NodeMaterial] &rarr;

		<h3 id="SpriteNodeMaterial">SpriteNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SpriteNodeMaterial SpriteNodeMaterial](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:SpriteNodeMaterial SpriteNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:SpriteNodeMaterial SpriteNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:SpriteNodeMaterial SpriteNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:SpriteNodeMaterial SpriteNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode alpha] -  The alpha.<br />
			[property:NodeNode color] -  The color.<br />
			[property:NodeNode|RawNode fragment] -  The fragment.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:NodeNode mask] -  The mask.<br />
			[property:NodeNode position] -  The position.<br />
			[property:object properties] -  The properties.<br />
			[property:NodeNode spherical] -  The spherical.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:NodeNode|RawNode vertex] -  The vertex.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:SpriteNodeMaterial build](  [param:NodeMaterialBuildParams params]? ) <br />
			[method:SpriteNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:SpriteNodeMaterial copy](  [param:NodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr;

		<h3 id="StandardNode">StandardNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:StandardNode StandardNode](  ) <br />
			[constructor:StandardNode StandardNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:NodeNode metalness] -  The metalness.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:NodeNode roughness] -  The roughness.<br />
			[property:NodeNode sheenColor] -  The sheen color.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder] ) <br />
			[method:StandardNode copy](  [param:StandardNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:StandardNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Material] &rarr; [page:ShaderMaterial] &rarr; [page:NodeMaterial] &rarr;

		<h3 id="StandardNodeMaterial">StandardNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:StandardNodeMaterial StandardNodeMaterial](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:StandardNodeMaterial StandardNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:StandardNodeMaterial StandardNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:StandardNodeMaterial StandardNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:StandardNodeMaterial StandardNodeMaterial](  [param:NodeNode vertex],  [param:NodeNode fragment],  [param:ShaderMaterialParameters parameters]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode alpha] -  The alpha.<br />
			[property:NodeNode ambient] -  The ambient.<br />
			[property:NodeNode ao] -  The ao.<br />
			[property:NodeNode clearcoat] -  The clearcoat.<br />
			[property:NodeNode clearcoatNormal] -  The clearcoat normal.<br />
			[property:NodeNode clearcoatRoughness] -  The clearcoat roughness.<br />
			[property:NodeNode color] -  The color.<br />
			[property:NodeNode emissive] -  The emissive.<br />
			[property:NodeNode environment] -  The environment.<br />
			[property:NodeNode|RawNode fragment] -  The fragment.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:NodeNode light] -  The light.<br />
			[property:NodeNode mask] -  The mask.<br />
			[property:NodeNode metalness] -  The metalness.<br />
			[property:NodeNode normal] -  The normal.<br />
			[property:NodeNode position] -  The position.<br />
			[property:object properties] -  The properties.<br />
			[property:NodeNode reflectivity] -  The reflectivity.<br />
			[property:NodeNode roughness] -  The roughness.<br />
			[property:NodeNode shadow] -  The shadow.<br />
			[property:NodeNode sheenColor] -  The sheen color.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:NodeNode|RawNode vertex] -  The vertex.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:StandardNodeMaterial build](  [param:NodeMaterialBuildParams params]? ) <br />
			[method:StandardNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:StandardNodeMaterial copy](  [param:NodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:Shader shader],  [param:WebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Stats">Stats <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number REVISION] -  The r e v i s i o n.<br />
			[property:HTMLDivElement dom] -  The dom.<br />
			[property:HTMLDivElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Panel addPanel](  [param:Panel panel] ) <br />
			[method:void begin](  ) <br />
			[method:void end](  ) <br />
			[method:void setMode](  [param:number id] ) <br />
			[method:void showPanel](  [param:number id] ) <br />
			[method:void update](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Camera] &rarr;

		<h3 id="StereoCamera">StereoCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:StereoCamera StereoCamera](  ) - This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.<br />
			[constructor:StereoCamera StereoCamera](  ) - This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.<br />
			[constructor:StereoCamera StereoCamera](  ) - The constructor takes no arguments.<br />
			[constructor:StereoCamera StereoCamera](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number aspect] -  The aspect.<br />
			[property:PerspectiveCamera cameraL] -  The camera l.<br />
			[property:PerspectiveCamera cameraR] -  The camera r.<br />
			[property:number eyeSep] -  The eye sep.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:any type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:StereoCamera add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:StereoCamera applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:StereoCamera attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:StereoCamera clear](  ) - Removes all child objects.<br />
			[method:StereoCamera clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:StereoCamera copy](  [param:StereoCamera source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) <br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:StereoCamera remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:StereoCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:StereoCamera rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:StereoCamera rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:StereoCamera rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:StereoCamera rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:StereoCamera rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:StereoCamera translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:StereoCamera translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:StereoCamera translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:StereoCamera translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  [param:PerspectiveCamera camera] ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="StereoEffect">StereoEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:StereoEffect StereoEffect](  [param:WebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:Scene scene],  [param:Camera camera] ) <br />
			[method:void setEyeSeparation](  [param:number eyeSep] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="StormParams">StormParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean isEternal]? -  The is eternal.<br />
			[property:Material lightningMaterial]? -  The lightning material.<br />
			[property:number lightningMaxDuration]? -  The lightning max duration.<br />
			[property:number lightningMaxPeriod]? -  The lightning max period.<br />
			[property:number lightningMinDuration]? -  The lightning min duration.<br />
			[property:number lightningMinPeriod]? -  The lightning min period.<br />
			[property:RayParameters lightningParameters]? -  The lightning parameters.<br />
			[property:number maxHeight]? -  The max height.<br />
			[property:number maxLightnings]? -  The max lightnings.<br />
			[property:number maxSlope]? -  The max slope.<br />
			[property:number minHeight]? -  The min height.<br />
			[property:number size]? -  The size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void onLightningDown](  [param:LightningStrike lightning] ) <br />
			[method:void onRayPosition](  [param:Vector3 source],  [param:Vector3 dest] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:KeyframeTrack] &rarr;

		<h3 id="StringKeyframeTrack">StringKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:StringKeyframeTrack StringKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) <br />
			[constructor:StringKeyframeTrack StringKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]?,  [param:string name],  [param:ArrayLike times],  [param:ArrayLike values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:LinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:CubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:StringKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:KeyframeTrack optimize](  ) <br />
			[method:KeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:KeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:KeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:any toJSON](  [param:KeyframeTrack track] ) <br />
			[method:KeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="StrokeStyle">StrokeStyle <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string strokeColor] -  The stroke color.<br />
			[property:string strokeLineCap] -  The stroke line cap.<br />
			[property:string strokeLineJoin] -  The stroke line join.<br />
			[property:number strokeMiterLimit] -  The stroke miter limit.<br />
			[property:number strokeWidth] -  The stroke width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="StructNode">StructNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:StructNode StructNode](  [param:string src]? ) <br />
			[constructor:StructNode StructNode](  [param:string src]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:StructNode StructNode](  [param:string src]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:StructNodeInput[] inputs] -  The inputs.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string src] -  The src.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:StructNode copy](  [param:NodeNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:StructNodeInput getInputByName](  [param:string name] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src] ) <br />
			[method:StructNode setLabel](  [param:string name] ) <br />
			[method:StructNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="StructNodeInput">StructNodeInput <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string name] -  The name.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="SubSlots">SubSlots <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SubSlots SubSlots](  [param:object slots]? ) <br />
			[constructor:SubSlots SubSlots](  [param:object slots]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:SubSlots SubSlots](  [param:object slots]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:boolean shared] -  The shared.<br />
			[property:NodeNode[] slots] -  The slots.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:SubSlots copy](  [param:SubSlots source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:SubSlots setLabel](  [param:string name] ) <br />
			[method:SubSlots setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="SubsurfaceScatteringShader">SubsurfaceScatteringShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr;

		<h3 id="SwitchNode">SwitchNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:SwitchNode SwitchNode](  [param:NodeNode node],  [param:string components]? ) <br />
			[constructor:SwitchNode SwitchNode](  [param:NodeNode node],  [param:string components]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string components] -  The components.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:NodeNode node] -  The node.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:SwitchNode copy](  [param:SwitchNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:SwitchNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr; [page:SSAARenderPass] &rarr;

		<h3 id="TAARenderPass">TAARenderPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TAARenderPass TAARenderPass](  [param:Scene scene],  [param:Camera camera],  [param:ColorRepresentation clearColor],  [param:number clearAlpha] ) <br />
			[constructor:TAARenderPass TAARenderPass](  [param:Scene scene],  [param:Camera camera],  [param:ColorRepresentation clearColor],  [param:number clearAlpha],  [param:Scene scene],  [param:Camera camera],  [param:ColorRepresentation clearColor],  [param:number clearAlpha] ) <br />
			[constructor:TAARenderPass TAARenderPass](  [param:Scene scene],  [param:Camera camera],  [param:ColorRepresentation clearColor],  [param:number clearAlpha],  [param:Scene scene],  [param:Camera camera],  [param:ColorRepresentation clearColor],  [param:number clearAlpha] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean accumulate] -  The accumulate.<br />
			[property:Camera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:number clearAlpha] -  The clear alpha.<br />
			[property:ColorRepresentation clearColor] -  The clear color.<br />
			[property:ShaderMaterial copyMaterial] -  The copy material.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:number sampleLevel] -  The sample level.<br />
			[property:WebGLRenderTarget sampleRenderTarget] -  The sample render target.<br />
			[property:Scene scene] -  The scene.<br />
			[property:boolean unbiased] -  The unbiased.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="TDSLoader">TDSLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TDSLoader TDSLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:TDSLoader TDSLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean debug] -  The debug.<br />
			[property:Group group] -  The group.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:Material[] materials] -  The materials.<br />
			[property:Mesh[] meshes] -  The meshes.<br />
			[property:number position] -  The position.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void debugMessage](  [param:object message] ) <br />
			[method:void endChunk](  [param:object chunk] ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void nextChunk](  [param:DataView data],  [param:object chunk] ) <br />
			[method:Group parse](  [param:ArrayBuffer arraybuffer],  [param:string path] ) <br />
			[method:number readByte](  [param:DataView data] ) <br />
			[method:object readChunk](  [param:DataView data] ) <br />
			[method:Color readColor](  [param:DataView data] ) <br />
			[method:number readDWord](  [param:DataView data] ) <br />
			[method:void readFaceArray](  [param:DataView data],  [param:Mesh mesh] ) <br />
			[method:void readFile](  [param:ArrayBuffer arraybuffer],  [param:string path] ) <br />
			[method:number readFloat](  [param:DataView data] ) <br />
			[method:number readInt](  [param:DataView data] ) <br />
			[method:Texture readMap](  [param:DataView data],  [param:string path] ) <br />
			[method:void readMaterialEntry](  [param:DataView data],  [param:string path] ) <br />
			[method:object readMaterialGroup](  [param:DataView data] ) <br />
			[method:Mesh readMesh](  [param:DataView data] ) <br />
			[method:void readMeshData](  [param:DataView data],  [param:string path] ) <br />
			[method:void readNamedObject](  [param:DataView data] ) <br />
			[method:number readShort](  [param:DataView data] ) <br />
			[method:string readString](  [param:DataView data],  [param:number maxLength] ) <br />
			[method:number readWord](  [param:DataView data] ) <br />
			[method:void resetPosition](  ) <br />
			[method:TDSLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:TDSLoader setPath](  [param:string path] ) <br />
			[method:TDSLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:TDSLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:TDSLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr; [page:DataTextureLoader] &rarr;

		<h3 id="TGALoader">TGALoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TGALoader TGALoader](  [param:LoadingManager manager]? ) <br />
			[constructor:TGALoader TGALoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) <br />
			[constructor:TGALoader TGALoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:DataTexture load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:DataTexture parse](  [param:ArrayBuffer data] ) <br />
			[method:TGALoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:TGALoader setPath](  [param:string path] ) <br />
			[method:TGALoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:TGALoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:TGALoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="TTFLoader">TTFLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TTFLoader TTFLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:TTFLoader TTFLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean reversed] -  The reversed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:object parse](  [param:ArrayBuffer arraybuffer] ) <br />
			[method:TTFLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:TTFLoader setPath](  [param:string path] ) <br />
			[method:TTFLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:TTFLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:TTFLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="TeapotGeometry">TeapotGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TeapotGeometry TeapotGeometry](  [param:number size]?,  [param:number segments]?,  [param:boolean bottom]?,  [param:boolean lid]?,  [param:boolean body]?,  [param:boolean fitLid]?,  [param:boolean blinn]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TeapotGeometry TeapotGeometry](  [param:number size]?,  [param:number segments]?,  [param:boolean bottom]?,  [param:boolean lid]?,  [param:boolean body]?,  [param:boolean fitLid]?,  [param:boolean blinn]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TeapotGeometry TeapotGeometry](  [param:number size]?,  [param:number segments]?,  [param:boolean bottom]?,  [param:boolean lid]?,  [param:boolean body]?,  [param:boolean fitLid]?,  [param:boolean blinn]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TeapotGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TechnicolorShader">TechnicolorShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr;

		<h3 id="TempNode">TempNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TempNode TempNode](  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:TempNode TempNode](  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:TempNode copy](  [param:NodeNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:TempNode setLabel](  [param:string name] ) <br />
			[method:TempNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TempNodeParams">TempNodeParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean shared]? -  The shared.<br />
			[property:boolean unique]? -  The unique.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TessellateModifier">TessellateModifier <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TessellateModifier TessellateModifier](  [param:number maxEdgeLength]?,  [param:number maxIterations]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number maxEdgeLength] -  The max edge length.<br />
			[property:number maxIterations] -  The max iterations.
		</p>
		<h4>Methods</h4>
		<p>
			[method:TGeometry modify](  [param:TGeometry geometry] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:PolyhedronGeometry] &rarr;

		<h3 id="TetrahedronBufferGeometry">TetrahedronBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TetrahedronGeometry TetrahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:TetrahedronGeometry TetrahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:TetrahedronGeometry TetrahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TetrahedronGeometry TetrahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TetrahedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:TetrahedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:PolyhedronGeometry] &rarr;

		<h3 id="TetrahedronGeometry">TetrahedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TetrahedronGeometry TetrahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:TetrahedronGeometry TetrahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:TetrahedronGeometry TetrahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TetrahedronGeometry TetrahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TetrahedronGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:TetrahedronGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TexParams">TexParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Vector2 offset] -  The offset.<br />
			[property:Vector2 scale] -  The scale.<br />
			[property:string url] -  The url.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:ExtrudeGeometry] &rarr;

		<h3 id="TextBufferGeometry">TextBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TextGeometry TextGeometry](  [param:string text],  [param:TextGeometryParameters parameters] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TextGeometry TextGeometry](  [param:string text],  [param:TextGeometryParameters parameters],  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TextGeometry TextGeometry](  [param:string text],  [param:TextGeometryParameters parameters],  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TextGeometry TextGeometry](  [param:string text],  [param:TextGeometryParameters parameters],  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:void addShape](  [param:Shape shape],  [param:any options]? ) <br />
			[method:void addShapeList](  [param:Shape[] shapes],  [param:any options]? ) <br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TextGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:ExtrudeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:ExtrudeGeometry] &rarr;

		<h3 id="TextGeometry">TextGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TextGeometry TextGeometry](  [param:string text],  [param:TextGeometryParameters parameters] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TextGeometry TextGeometry](  [param:string text],  [param:TextGeometryParameters parameters],  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TextGeometry TextGeometry](  [param:string text],  [param:TextGeometryParameters parameters],  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TextGeometry TextGeometry](  [param:string text],  [param:TextGeometryParameters parameters],  [param:Shape|Shape[] shapes]?,  [param:ExtrudeGeometryOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:void addShape](  [param:Shape shape],  [param:any options]? ) <br />
			[method:void addShapeList](  [param:Shape[] shapes],  [param:any options]? ) <br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TextGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:ExtrudeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TextGeometryParameters">TextGeometryParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean bevelEnabled]? -  The bevel enabled.<br />
			[property:number bevelOffset]? -  The bevel offset.<br />
			[property:number bevelSegments]? -  The bevel segments.<br />
			[property:number bevelSize]? -  The bevel size.<br />
			[property:number bevelThickness]? -  The bevel thickness.<br />
			[property:number curveSegments]? -  The curve segments.<br />
			[property:Font font] -  The font.<br />
			[property:number height]? -  The height.<br />
			[property:number size]? -  The size.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="Texture">Texture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Texture Texture](  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:Texture Texture](  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any DEFAULT_IMAGE] -  The d e f a u l t_ i m a g e.<br />
			[property:any DEFAULT_MAPPING] -  The d e f a u l t_ m a p p i n g.<br />
			[property:number anisotropy] -  The anisotropy.<br />
			[property:Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:Texture clone](  ) <br />
			[method:Texture copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="TextureCubeNode">TextureCubeNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TextureCubeNode TextureCubeNode](  [param:TextureNode value],  [param:FloatNode textureSize]? ) <br />
			[constructor:TextureCubeNode TextureCubeNode](  [param:TextureNode value],  [param:FloatNode textureSize]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:TextureCubeNode TextureCubeNode](  [param:TextureNode value],  [param:FloatNode textureSize]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any irradianceCache] -  The irradiance cache.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:any radianceCache] -  The radiance cache.<br />
			[property:boolean shared] -  The shared.<br />
			[property:FloatNode textureSize] -  The texture size.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:TextureNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:TextureCubeNode copy](  [param:NodeNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateTextureCubeUV](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:TextureCubeNode setLabel](  [param:string name] ) <br />
			[method:TextureCubeNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="TextureCubeUVNode">TextureCubeUVNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TextureCubeUVNode TextureCubeUVNode](  [param:NodeNode uv],  [param:FloatNode textureSize] ) <br />
			[constructor:TextureCubeUVNode TextureCubeUVNode](  [param:NodeNode uv],  [param:FloatNode textureSize],  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:TextureCubeUVNode TextureCubeUVNode](  [param:NodeNode uv],  [param:FloatNode textureSize],  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:FloatNode textureSize] -  The texture size.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:NodeNode uv] -  The uv.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:TextureCubeUVNode copy](  [param:NodeNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:TextureCubeUVNode setLabel](  [param:string name] ) <br />
			[method:TextureCubeUVNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="TextureLoader">TextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TextureLoader TextureLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:TextureLoader TextureLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:LoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Texture load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:TextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:TextureLoader setPath](  [param:string path] ) <br />
			[method:TextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:TextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:TextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			Class for loading a texture.<br />
			Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="TextureNode">TextureNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TextureNode TextureNode](  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]? ) <br />
			[constructor:TextureNode TextureNode](  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:TextureNode TextureNode](  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:TextureNode TextureNode](  [param:Texture value],  [param:UVNode|UVTransformNode uv]?,  [param:NodeNode bias]?,  [param:boolean project]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:NodeNode bias] -  The bias.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean project] -  The project.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:UVNode|UVTransformNode uv] -  The uv.<br />
			[property:Texture value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:TextureNode copy](  [param:TextureNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getTexture](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:TextureNode setLabel](  [param:string name] ) <br />
			[method:TextureNode setName](  [param:string name] ) <br />
			[method:TextureNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="TexturePass">TexturePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TexturePass TexturePass](  [param:Texture map],  [param:number opacity]? ) <br />
			[constructor:TexturePass TexturePass](  [param:Texture map],  [param:number opacity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:Texture map] -  The map.<br />
			[property:ShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number opacity] -  The opacity.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="ThreeMFLoader">ThreeMFLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ThreeMFLoader ThreeMFLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:ThreeMFLoader ThreeMFLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object[] availableExtensions] -  The available extensions.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addExtension](  [param:object extension] ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Group parse](  [param:ArrayBuffer data] ) <br />
			[method:ThreeMFLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ThreeMFLoader setPath](  [param:string path] ) <br />
			[method:ThreeMFLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ThreeMFLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ThreeMFLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="TiltLoader">TiltLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TiltLoader TiltLoader](  [param:LoadingManager manager]?,  [param:string assetUrl]? ) <br />
			[constructor:TiltLoader TiltLoader](  [param:LoadingManager manager]?,  [param:string assetUrl]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Group parse](  [param:ArrayBuffer data] ) <br />
			[method:TiltLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:TiltLoader setPath](  [param:string path] ) <br />
			[method:TiltLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:TiltLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:TiltLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr; [page:FloatNode] &rarr;

		<h3 id="TimerNode">TimerNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TimerNode TimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]? ) <br />
			[constructor:TimerNode TimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]?,  [param:number value]? ) <br />
			[constructor:TimerNode TimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]?,  [param:number value]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:TimerNode TimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]?,  [param:number value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:TimerNode TimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]?,  [param:number value]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string DELTA] -  The d e l t a.<br />
			[property:string GLOBAL] -  The g l o b a l.<br />
			[property:string LOCAL] -  The l o c a l.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:number scale] -  The scale.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:boolean timeScale] -  The time scale.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:TimerNode copy](  [param:TimerNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:TimerNode setLabel](  [param:string name] ) <br />
			[method:TimerNode setName](  [param:string name] ) <br />
			[method:TimerNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ToneMapShader">ToneMapShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ToonShader1">ToonShader1 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ToonShader2">ToonShader2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ToonShaderDotted">ToonShaderDotted <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ToonShaderHatching">ToonShaderHatching <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="TorusBufferGeometry">TorusBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TorusGeometry TorusGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number radialSegments]?,  [param:number tubularSegments]?,  [param:number arc]? ) <br />
			[constructor:TorusGeometry TorusGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number radialSegments]?,  [param:number tubularSegments]?,  [param:number arc]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TorusGeometry TorusGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number radialSegments]?,  [param:number tubularSegments]?,  [param:number arc]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TorusGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:TorusGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="TorusGeometry">TorusGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TorusGeometry TorusGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number radialSegments]?,  [param:number tubularSegments]?,  [param:number arc]? ) <br />
			[constructor:TorusGeometry TorusGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number radialSegments]?,  [param:number tubularSegments]?,  [param:number arc]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TorusGeometry TorusGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number radialSegments]?,  [param:number tubularSegments]?,  [param:number arc]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TorusGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:TorusGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="TorusKnotBufferGeometry">TorusKnotBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TorusKnotGeometry TorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number tubularSegments]?,  [param:number radialSegments]?,  [param:number p]?,  [param:number q]? ) <br />
			[constructor:TorusKnotGeometry TorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number tubularSegments]?,  [param:number radialSegments]?,  [param:number p]?,  [param:number q]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TorusKnotGeometry TorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number tubularSegments]?,  [param:number radialSegments]?,  [param:number p]?,  [param:number q]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TorusKnotGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:TorusKnotGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="TorusKnotGeometry">TorusKnotGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TorusKnotGeometry TorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number tubularSegments]?,  [param:number radialSegments]?,  [param:number p]?,  [param:number q]? ) <br />
			[constructor:TorusKnotGeometry TorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number tubularSegments]?,  [param:number radialSegments]?,  [param:number p]?,  [param:number q]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TorusKnotGeometry TorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number tubularSegments]?,  [param:number radialSegments]?,  [param:number p]?,  [param:number q]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TorusKnotGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:TorusKnotGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="TrackballControls">TrackballControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TrackballControls TrackballControls](  [param:Camera object],  [param:HTMLElement domElement]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:TrackballControls TrackballControls](  [param:Camera object],  [param:HTMLElement domElement]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:number dynamicDampingFactor] -  The dynamic damping factor.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:string[] keys] -  The keys.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:any mouseButtons] -  The mouse buttons.<br />
			[property:boolean noPan] -  The no pan.<br />
			[property:boolean noRoll] -  The no roll.<br />
			[property:boolean noRotate] -  The no rotate.<br />
			[property:boolean noZoom] -  The no zoom.<br />
			[property:Camera object] -  The object.<br />
			[property:number panSpeed] -  The pan speed.<br />
			[property:Vector3 position0] -  The position0.<br />
			[property:number rotateSpeed] -  The rotate speed.<br />
			[property:any screen] -  The screen.<br />
			[property:boolean staticMoving] -  The static moving.<br />
			[property:Vector3 target] -  The target.<br />
			[property:Vector3 target0] -  The target0.<br />
			[property:Vector3 up0] -  The up0.<br />
			[property:number zoomSpeed] -  The zoom speed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void checkDistances](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:void handleResize](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void panCamera](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void reset](  ) <br />
			[method:void rotateCamera](  ) <br />
			[method:void update](  ) <br />
			[method:void zoomCamera](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="TransformControls">TransformControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TransformControls TransformControls](  [param:Camera object],  [param:HTMLElement domElement]? ) - The constructor takes no arguments.<br />
			[constructor:TransformControls TransformControls](  [param:Camera object],  [param:HTMLElement domElement]? ) - The constructor takes no arguments.<br />
			[constructor:TransformControls TransformControls](  [param:Camera object],  [param:HTMLElement domElement]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:'X'|'Y'|'Z'|'E'|'XY'|'YZ'|'XZ'|'XYZ'|'XYZE' axis] -  The axis.<br />
			[property:Camera camera] -  The camera.<br />
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:boolean dragging] -  The dragging.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:any isTransformControls] -  The is transform controls.<br />
			[property:'translate'|'rotate'|'scale' mode] -  The mode.<br />
			[property:any mouseButtons] -  The mouse buttons.<br />
			[property:Object3D object] -  The object.<br />
			[property:number rotationSnap] -  The rotation snap.<br />
			[property:boolean showX] -  The show x.<br />
			[property:boolean showY] -  The show y.<br />
			[property:boolean showZ] -  The show z.<br />
			[property:number size] -  The size.<br />
			[property:'local'|'world' space] -  The space.<br />
			[property:number translationSnap] -  The translation snap.
		</p>
		<h4>Methods</h4>
		<p>
			[method:TransformControls add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:TransformControls applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:TransformControls attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:TransformControls clear](  ) - Removes all child objects.<br />
			[method:TransformControls clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:TransformControls copy](  [param:TransformControls source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:TransformControls detach](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:void getMode](  ) <br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Raycaster getRaycaster](  ) <br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:TransformControls remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:TransformControls removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:TransformControls rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:TransformControls rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:TransformControls rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:TransformControls rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:TransformControls rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setMode](  [param:'translate'|'rotate'|'scale' mode] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:void setRotationSnap](  [param:number rotationSnap] ) <br />
			[method:void setScaleSnap](  [param:number scaleSnap] ) <br />
			[method:void setSize](  [param:number size] ) <br />
			[method:void setSpace](  [param:'local'|'world' space] ) <br />
			[method:void setTranslationSnap](  [param:number translationSnap] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:TransformControls translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:TransformControls translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:TransformControls translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:TransformControls translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Triangle">Triangle <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Triangle Triangle](  [param:Vector3 a]?,  [param:Vector3 b]?,  [param:Vector3 c]? ) - Creates a new Triangle.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Vector3 a] - The first corner of the triangle. Default is a [page:Vector3 Vector3] at (0, 0, 0).<br />
			[property:Vector3 b] - The second corner of the triangle. Default is a [page:Vector3 Vector3] at (0, 0, 0).<br />
			[property:Vector3 c] - the final corner of the triangle. Default is a [page:Vector3 Vector3] at (0, 0, 0)
		</p>
		<h4>Methods</h4>
		<p>
			[method:Triangle clone](  ) - Returns : Returns a new triangle with the same *.a*, *.b* and  *.c* properties as this one.<br />
			[method:Vector3 closestPointToPoint](  [param:Vector3 point],  [param:Vector3 target] ) - Returns : Returns the closest point on the triangle to [page:Vector3 point].<br />
			[method:boolean containsPoint](  [param:Vector3 point] ) - Returns : true if point<br />
			[method:boolean containsPoint](  [param:Vector3 point],  [param:Vector3 point],  [param:Vector3 a],  [param:Vector3 b],  [param:Vector3 c] ) - Returns : Returns true if the passed point, when projected onto the plane of the triangle, lies within the triangle.<br />
			[method:Triangle copy](  [param:Triangle triangle] ) - Copies the values of the passed triangles's *.a*, *.b* and *.c* properties to this triangle.<br />
			[method:boolean equals](  [param:Triangle triangle] ) - Returns : Returns true if the two triangles have identical *.a*, *.b* and *.c* properties.<br />
			[method:number getArea](  ) - Returns : Return the area of the triangle.<br />
			[method:Vector3 getBarycoord](  [param:Vector3 point],  [param:Vector3 target] ) - [Picture of barycentric coordinates](http://commons.wikimedia.org/wiki/File:Barycentric_coordinates_1.png)<br />
			<br />
			Returns : Return a [link:https://en.wikipedia.org/wiki/Barycentric_coordinate_system barycentric coordinate] from the given vector.<br />
			[method:Vector3 getBarycoord](  [param:Vector3 point],  [param:Vector3 target],  [param:Vector3 point],  [param:Vector3 a],  [param:Vector3 b],  [param:Vector3 c],  [param:Vector3 target] ) - Returns : barycoord<br />
			[method:Vector3 getMidpoint](  [param:Vector3 target] ) - Calculate the midpoint of the triangle.<br />
			[method:Vector3 getNormal](  [param:Vector3 target] ) - Calculate the [link:https://en.wikipedia.org/wiki/Normal_(geometry normal vector]) of the triangle.<br />
			[method:Vector3 getNormal](  [param:Vector3 target],  [param:Vector3 a],  [param:Vector3 b],  [param:Vector3 c],  [param:Vector3 target] ) - Returns : normal<br />
			[method:Plane getPlane](  [param:Plane target] ) - Calculate a [page:Plane plane] based on the triangle. .<br />
			[method:Vector2 getUV](  [param:Vector3 point],  [param:Vector2 uv1],  [param:Vector2 uv2],  [param:Vector2 uv3],  [param:Vector2 target] ) - Returns : uv<br />
			[method:Vector2 getUV](  [param:Vector3 point],  [param:Vector2 uv1],  [param:Vector2 uv2],  [param:Vector2 uv3],  [param:Vector2 target],  [param:Vector3 point],  [param:Vector3 p1],  [param:Vector3 p2],  [param:Vector3 p3],  [param:Vector2 uv1],  [param:Vector2 uv2],  [param:Vector2 uv3],  [param:Vector2 target] ) - Returns : uv<br />
			[method:boolean intersectsBox](  [param:Box3 box] ) - Determines whether or not this triangle intersects [page:Box3 box].<br />
			[method:boolean isFrontFacing](  [param:Vector3 direction] ) - Returns : true if front facing<br />
			[method:boolean isFrontFacing](  [param:Vector3 direction],  [param:Vector3 a],  [param:Vector3 b],  [param:Vector3 c],  [param:Vector3 direction] ) - Returns : true if front facing<br />
			[method:Triangle set](  [param:Vector3 a],  [param:Vector3 b],  [param:Vector3 c] ) - Sets the triangle's *.a*, *.b* and *.c* properties to the passed [page:Vector3 vector3s].<br />
			Please note that this method only copies the values from the given objects.<br />
			[method:Triangle setFromAttributeAndIndices](  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:number i0],  [param:number i1],  [param:number i2] ) - attribute - [page:BufferAttribute BufferAttribute] of vertex data<br />
			i0 - [page:Integer Integer] index<br />
			i1 - [page:Integer Integer] index<br />
			i2 - [page:Integer Integer] index Sets the triangle's vertices from the buffer attribute vertex data.<br />
			[method:Triangle setFromPointsAndIndices](  [param:Vector3[] points],  [param:number i0],  [param:number i1],  [param:number i2] ) - points - [page:Array Array] of [page:Vector3 Vector3]s<br />
			i0 - [page:Integer Integer] index<br />
			i1 - [page:Integer Integer] index<br />
			i2 - [page:Integer Integer] index Sets the triangle's vectors to the vectors in the array.
		</p>

		<p class="desc">
			A geometric triangle as defined by three [page:Vector3 Vector3s] representing its three corners.
		</p>

		<hr class="interface-line"/>
		<h3 id="TriangleBlurShader">TriangleBlurShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="TubeBufferGeometry">TubeBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TubeGeometry TubeGeometry](  [param:Curve path]?,  [param:number tubularSegments]?,  [param:number radius]?,  [param:number radiusSegments]?,  [param:boolean closed]? ) <br />
			[constructor:TubeGeometry TubeGeometry](  [param:Curve path]?,  [param:number tubularSegments]?,  [param:number radius]?,  [param:number radiusSegments]?,  [param:boolean closed]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TubeGeometry TubeGeometry](  [param:Curve path]?,  [param:number tubularSegments]?,  [param:number radius]?,  [param:number radiusSegments]?,  [param:boolean closed]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Vector3[] binormals] -  The binormals.<br />
			[property:Vector3[] normals] -  The normals.<br />
			[property:any parameters] -  The parameters.<br />
			[property:Vector3[] tangents] -  The tangents.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TubeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:TubeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="TubeGeometry">TubeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TubeGeometry TubeGeometry](  [param:Curve path]?,  [param:number tubularSegments]?,  [param:number radius]?,  [param:number radiusSegments]?,  [param:boolean closed]? ) <br />
			[constructor:TubeGeometry TubeGeometry](  [param:Curve path]?,  [param:number tubularSegments]?,  [param:number radius]?,  [param:number radiusSegments]?,  [param:boolean closed]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:TubeGeometry TubeGeometry](  [param:Curve path]?,  [param:number tubularSegments]?,  [param:number radius]?,  [param:number radiusSegments]?,  [param:boolean closed]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Vector3[] binormals] -  The binormals.<br />
			[property:Vector3[] normals] -  The normals.<br />
			[property:any parameters] -  The parameters.<br />
			[property:Vector3[] tangents] -  The tangents.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:TubeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:TubeGeometry fromJSON](  [param:any data] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TubePainter">TubePainter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:TubePainter TubePainter](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Mesh mesh] -  The mesh.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void stroke](  [param:Vector3 position1],  [param:Vector3 position2],  [param:Matrix4 matrix1],  [param:Matrix4 matrix2] ) <br />
			[method:void updateGeometry](  [param:number start],  [param:number end] ) 
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="USDZExporter">USDZExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:USDZExporter USDZExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:Promise parse](  [param:Object3D scene] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="UVBoxes">UVBoxes <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number h] -  The h.<br />
			[property:number index] -  The index.<br />
			[property:number w] -  The w.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="UVGenerator">UVGenerator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:Vector2[] generateSideWallUV](  [param:ExtrudeGeometry geometry],  [param:number[] vertices],  [param:number indexA],  [param:number indexB],  [param:number indexC],  [param:number indexD] ) <br />
			[method:Vector2[] generateTopUV](  [param:ExtrudeGeometry geometry],  [param:number[] vertices],  [param:number indexA],  [param:number indexB],  [param:number indexC] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr;

		<h3 id="UVNode">UVNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:UVNode UVNode](  [param:number index]? ) <br />
			[constructor:UVNode UVNode](  [param:number index]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:UVNode UVNode](  [param:number index]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:number index] -  The index.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:UVNode copy](  [param:UVNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:UVNode setLabel](  [param:string name] ) <br />
			[method:UVNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:FunctionNode] &rarr; [page:ExpressionNode] &rarr;

		<h3 id="UVTransformNode">UVTransformNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:UVTransformNode UVTransformNode](  [param:UVNode uv]?,  [param:Matrix3Node position]? ) <br />
			[constructor:UVTransformNode UVTransformNode](  [param:UVNode uv]?,  [param:Matrix3Node position]?,  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]? ) <br />
			[constructor:UVTransformNode UVTransformNode](  [param:UVNode uv]?,  [param:Matrix3Node position]?,  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]? ) <br />
			[constructor:UVTransformNode UVTransformNode](  [param:UVNode uv]?,  [param:Matrix3Node position]?,  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:UVTransformNode UVTransformNode](  [param:UVNode uv]?,  [param:Matrix3Node position]?,  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object extensions] -  The extensions.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:object[] includes] -  The includes.<br />
			[property:FunctionNodeInput[] inputs] -  The inputs.<br />
			[property:boolean isMethod] -  The is method.<br />
			[property:any isNode] -  The is node.<br />
			[property:object keywords] -  The keywords.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:Matrix3Node position] -  The position.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean useKeywords] -  The use keywords.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:UVNode uv] -  The uv.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:UVTransformNode copy](  [param:UVTransformNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getIncludeByName](  [param:string name] ) <br />
			[method:FunctionNodeInput getInputByName](  [param:string name] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]? ) <br />
			[method:UVTransformNode setLabel](  [param:string name] ) <br />
			[method:UVTransformNode setName](  [param:string name] ) <br />
			[method:void setUvTransform](  [param:number tx],  [param:number ty],  [param:number sx],  [param:number sy],  [param:number rotation],  [param:number cx]?,  [param:number cy]? ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Uint16Attribute">Uint16Attribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Uint16Attribute Uint16Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Uint16Attribute Uint16Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint16Attribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint16Attribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint16Attribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint16Attribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Uint16Attribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Uint16Attribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Uint16Attribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Uint16Attribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Uint16Attribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Uint16Attribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Uint16Attribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Uint16Attribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Uint16Attribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Uint16Attribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Uint16Attribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Uint16Attribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Uint16Attribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Uint16Attribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Uint16Attribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Uint16Attribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Uint16Attribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Uint16Attribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			deprecated - THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Uint16BufferAttribute">Uint16BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Uint16BufferAttribute Uint16BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Uint16BufferAttribute Uint16BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint16BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint16BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint16BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint16BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Uint16BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Uint16BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Uint16BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Uint16BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Uint16BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Uint16BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Uint16BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Uint16BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Uint16BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Uint16BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Uint16BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Uint16BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Uint16BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Uint16BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Uint16BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Uint16BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Uint16BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Uint16BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Uint16 buffer attribute
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Uint32Attribute">Uint32Attribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Uint32Attribute Uint32Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Uint32Attribute Uint32Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint32Attribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint32Attribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint32Attribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint32Attribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Uint32Attribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Uint32Attribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Uint32Attribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Uint32Attribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Uint32Attribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Uint32Attribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Uint32Attribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Uint32Attribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Uint32Attribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Uint32Attribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Uint32Attribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Uint32Attribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Uint32Attribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Uint32Attribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Uint32Attribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Uint32Attribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Uint32Attribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Uint32Attribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			deprecated - THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Uint32BufferAttribute">Uint32BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Uint32BufferAttribute Uint32BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Uint32BufferAttribute Uint32BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint32BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint32BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint32BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint32BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Uint32BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Uint32BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Uint32BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Uint32BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Uint32BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Uint32BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Uint32BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Uint32BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Uint32BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Uint32BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Uint32BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Uint32BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Uint32BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Uint32BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Uint32BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Uint32BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Uint32BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Uint32BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Uint32 buffer attribute
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Uint8Attribute">Uint8Attribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Uint8Attribute Uint8Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Uint8Attribute Uint8Attribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint8Attribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8Attribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8Attribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8Attribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Uint8Attribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Uint8Attribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Uint8Attribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Uint8Attribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Uint8Attribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Uint8Attribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Uint8Attribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Uint8Attribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Uint8Attribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Uint8Attribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Uint8Attribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Uint8Attribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Uint8Attribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Uint8Attribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Uint8Attribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Uint8Attribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Uint8Attribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Uint8Attribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			deprecated - THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Uint8BufferAttribute">Uint8BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Uint8BufferAttribute Uint8BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Uint8BufferAttribute Uint8BufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint8BufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8BufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8BufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8BufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Uint8BufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Uint8BufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Uint8BufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Uint8BufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Uint8BufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Uint8BufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Uint8BufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Uint8BufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Uint8BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Uint8BufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Uint8BufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Uint8BufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Uint8BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Uint8BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Uint8BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Uint8BufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Uint8BufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Uint8BufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Uint8 buffer attribute
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Uint8ClampedAttribute">Uint8ClampedAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Uint8ClampedAttribute Uint8ClampedAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Uint8ClampedAttribute Uint8ClampedAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint8ClampedAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8ClampedAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8ClampedAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8ClampedAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Uint8ClampedAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Uint8ClampedAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Uint8ClampedAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Uint8ClampedAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Uint8ClampedAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Uint8ClampedAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Uint8ClampedAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Uint8ClampedAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Uint8ClampedAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Uint8ClampedAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Uint8ClampedAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Uint8ClampedAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Uint8ClampedAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Uint8ClampedAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Uint8ClampedAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Uint8ClampedAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Uint8ClampedAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Uint8ClampedAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			deprecated - THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.
		</p>

		<hr class="interface-line"/>
		[page:BufferAttribute] &rarr;

		<h3 id="Uint8ClampedBufferAttribute">Uint8ClampedBufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Uint8ClampedBufferAttribute Uint8ClampedBufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:Uint8ClampedBufferAttribute Uint8ClampedBufferAttribute](  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:number|ArrayLike|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] - The [page:TypedArray array] holding data stored in the buffer.<br />
			[property:number count] - Stores the [page:BufferAttribute.array array]'s length divided by the [page:BufferAttribute.itemSize itemSize].<br />
			If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] - The length of vectors that are being stored in the [page:BufferAttribute.array array].<br />
			[property:string name] - Optional name for this attribute instance. Default is an empty string.<br />
			[property:boolean normalized] - Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.<br />
			See the constructor above for details.<br />
			[property:any updateRange] - Object containing:<br />
			[page:Integer offset]: Default is *0*. Position at which to start update.<br />
			[page:Integer count]: Default is *-1*, which means don't use update ranges.<br />
			This can be used to only update some components of stored vectors (for example, just the component related to color).<br />
			[property:Usage usage] - Defines the intended usage pattern of the data store for optimization purposes. Corresponds to the *usage* parameter of [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData WebGLRenderingContext.bufferData]().<br />
			Default is [page:BufferAttributeUsage StaticDrawUsage]. See usage [page:BufferAttributeUsage constants] for all possible values.<br />
			[property:number version] - A version number, incremented every time the [page:BufferAttribute.needsUpdate needsUpdate] property is set to true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint8ClampedBufferAttribute applyMatrix3](  [param:Matrix3 m] ) - Applies matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8ClampedBufferAttribute applyMatrix4](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8ClampedBufferAttribute applyNormalMatrix](  [param:Matrix3 m] ) - Applies normal matrix [page:Matrix3 m] to every Vector3 element of this BufferAttribute.<br />
			[method:Uint8ClampedBufferAttribute clone](  ) - Returns : Return a copy of this bufferAttribute.<br />
			[method:Uint8ClampedBufferAttribute copy](  [param:BufferAttribute source] ) - Copies another BufferAttribute to this BufferAttribute.<br />
			[method:Uint8ClampedBufferAttribute copyArray](  [param:ArrayLike array] ) - Copy the array given here (which can be a normal array or TypedArray) into [page:BufferAttribute.array array].<br />
			See [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]<br />
			for notes on requirements if copying a TypedArray.<br />
			[method:Uint8ClampedBufferAttribute copyAt](  [param:number index1],  [param:BufferAttribute attribute],  [param:number index2] ) - Copy a vector from bufferAttribute[index2] to [page:BufferAttribute.array array][index1].<br />
			[method:Uint8ClampedBufferAttribute copyColorsArray](  [param:any colors] ) - Copy an array representing RGB color values into [page:BufferAttribute.array array].<br />
			[method:Uint8ClampedBufferAttribute copyVector2sArray](  [param:any vectors] ) - Copy an array representing [page:Vector2 Vector2]s into [page:BufferAttribute.array array].<br />
			[method:Uint8ClampedBufferAttribute copyVector3sArray](  [param:any vectors] ) - Copy an array representing [page:Vector3 Vector3]s into [page:BufferAttribute.array array].<br />
			[method:Uint8ClampedBufferAttribute copyVector4sArray](  [param:any vectors] ) - Copy an array representing [page:Vector4 Vector4]s into [page:BufferAttribute.array array].<br />
			[method:number getW](  [param:number index] ) - Returns : Returns the w component of the vector at the given index.<br />
			[method:number getX](  [param:number index] ) - Returns : Returns the x component of the vector at the given index.<br />
			[method:number getY](  [param:number index] ) - Returns : Returns the y component of the vector at the given index.<br />
			[method:number getZ](  [param:number index] ) - Returns : Returns the z component of the vector at the given index.<br />
			[method:Uint8ClampedBufferAttribute onUpload](  [param:any callback] ) - Sets the value of the onUploadCallback property.<br />
			In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory after the buffer has been	transferred to the GPU.<br />
			[method:void onUploadCallback](  ) - A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.<br />
			[method:Uint8ClampedBufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) - Calls [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set TypedArray.set]( [page:Array value], [page:Integer offset] )<br />
			on the [page:BufferAttribute.array array].<br />
			In particular, see that page for requirements on [page:Array value]<br />
			being a [page:TypedArray TypedArray].<br />
			[method:Uint8ClampedBufferAttribute setUsage](  [param:Usage usage] ) - Set [page:BufferAttribute.usage usage] to value. See usage [page:BufferAttributeUsage constants] for all possible input values.<br />
			[method:Uint8ClampedBufferAttribute setW](  [param:number index],  [param:number z] ) - Sets the w component of the vector at the given index.<br />
			[method:Uint8ClampedBufferAttribute setX](  [param:number index],  [param:number x] ) - Sets the x component of the vector at the given index.<br />
			[method:Uint8ClampedBufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) - Sets the x and y components of the vector at the given index.<br />
			[method:Uint8ClampedBufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) - Sets the x, y and z components of the vector at the given index.<br />
			[method:Uint8ClampedBufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the x, y, z and w components of the vector at the given index.<br />
			[method:Uint8ClampedBufferAttribute setY](  [param:number index],  [param:number y] ) - Sets the y component of the vector at the given index.<br />
			[method:Uint8ClampedBufferAttribute setZ](  [param:number index],  [param:number z] ) - Sets the z component of the vector at the given index.<br />
			[method:void toJSON](  ) <br />
			[method:Uint8ClampedBufferAttribute transformDirection](  [param:Matrix4 m] ) - Applies matrix [page:Matrix4 m] to every Vector3 element of this BufferAttribute, interpreting the elements as a direction vectors.
		</p>

		<p class="desc">
			Uint8 clamped buffer attribute
		</p>

		<hr class="interface-line"/>
		<h3 id="Uniform">Uniform <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Uniform Uniform](  [param:any value] ) <br />
			[constructor:Uniform Uniform](  [param:any value],  [param:string type],  [param:any value] ) - deprecated -
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean dynamic] - deprecated - Use {@link Object3D#onBeforeRender object.onBeforeRender()} instead.<br />
			[property:string type] - deprecated -<br />
			[property:any value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uniform onUpdate](  [param:any callback] ) - deprecated - Use {@link Object3D#onBeforeRender object.onBeforeRender()} instead.<br />
			[method:void onUpdateCallback](  ) 
		</p>

		<p class="desc">
			Uniforms are global GLSL variables. They are passed to shader programs.<br />
			<code data-type="javascript"><br />
			uniforms: {<br />
			 time: { value: 1.0 }, resolution: new Uniform( new Vector2() )<br />
			};<br />
			</code><br />
			Each uniform must have a *value* property. The type of the value must correspond to the type of the uniform variable in the GLSL code as specified for the primitive GLSL types in the table below. Uniform structures and arrays are also supported. GLSL arrays of primitive type must either be specified as an array of the corresponding THREE objects or as a flat array containing the data of all the objects. In other words; GLSL primitives in arrays must not be represented by arrays. This rule does not apply transitively.<br />
			An array of *vec2* arrays, each with a length of five vectors, must be an array of arrays, of either five [page:Vector2 Vector2] objects or ten *number*s.<br />
			<br />
			|    GLSL type   |      JavaScript type      |<br />
			|:--------------:|--------------------------:|<br />
			| int            | [page:Number Number] |<br />
			| uint (WebGL 2) | [page:Number Number]|<br />
			| float          | [page:Number Number] |<br />
			| bool           | [page:Boolean Boolean] |<br />
			| bool           | [page:Number Number] |<br />
			| vec2           | [page:Vector2 THREE.Vector2] |<br />
			| vec2           | [page:Float32Array Float32Array] (*) |<br />
			| vec2           | [page:Array Array] (*) |<br />
			| vec3           | [page:Vector3 THREE.Vector3] |<br />
			| vec3           | [page:Color THREE.Color] |<br />
			| vec3           | [page:Float32Array Float32Array] (*) |<br />
			| vec3           | [page:Array Array] (*) |<br />
			| vec4           | [page:Vector4 THREE.Vector4] |<br />
			| vec4           | [page:Quaternion THREE.Quaternion] |<br />
			| vec4           | [page:Float32Array Float32Array] (*) |<br />
			| vec4           | [page:Array Array] (*) |<br />
			| mat2           | [page:Float32Array Float32Array] (*) |<br />
			| mat2           | [page:Array Array] (*) |<br />
			| mat3           | [page:Matrix3 THREE.Matrix3] |<br />
			| mat3           | [page:Float32Array Float32Array] (*) |<br />
			| mat3           | [page:Array Array] (*) |<br />
			| mat4           | [page:Matrix4 THREE.Matrix4] |<br />
			| mat4           | [page:Float32Array Float32Array] (*) |<br />
			| mat4           | [page:Array Array] (*) |
		</p>

		<hr class="interface-line"/>
		<h3 id="UniformsLib">UniformsLib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any aomap] -  The aomap.<br />
			[property:any bumpmap] -  The bumpmap.<br />
			[property:any common] -  The common.<br />
			[property:any displacementmap] -  The displacementmap.<br />
			[property:any emissivemap] -  The emissivemap.<br />
			[property:any envmap] -  The envmap.<br />
			[property:any fog] -  The fog.<br />
			[property:any gradientmap] -  The gradientmap.<br />
			[property:any lightmap] -  The lightmap.<br />
			[property:any lights] -  The lights.<br />
			[property:any metalnessmap] -  The metalnessmap.<br />
			[property:any normalmap] -  The normalmap.<br />
			[property:any points] -  The points.<br />
			[property:any roughnessmap] -  The roughnessmap.<br />
			[property:any specularmap] -  The specularmap.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="UniformsUtils">UniformsUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:any clone](  [param:any uniforms_src] ) <br />
			[method:any merge](  [param:any[] uniforms] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="UnpackDepthRGBAShader">UnpackDepthRGBAShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Pass] &rarr;

		<h3 id="UnrealBloomPass">UnrealBloomPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:UnrealBloomPass UnrealBloomPass](  [param:Vector2 resolution],  [param:number strength],  [param:number radius],  [param:number threshold] ) <br />
			[constructor:UnrealBloomPass UnrealBloomPass](  [param:Vector2 resolution],  [param:number strength],  [param:number radius],  [param:number threshold] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:MeshBasicMaterial basic] -  The basic.<br />
			[property:Vector3[] bloomTintColors] -  The bloom tint colors.<br />
			[property:boolean clear] -  The clear.<br />
			[property:Color clearColor] -  The clear color.<br />
			[property:ShaderMaterial compositeMaterial] -  The composite material.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:object highPassUniforms] -  The high pass uniforms.<br />
			[property:ShaderMaterial materialCopy] -  The material copy.<br />
			[property:ShaderMaterial materialHighPassFilter] -  The material high pass filter.<br />
			[property:number nMips] -  The n mips.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number oldClearAlpha] -  The old clear alpha.<br />
			[property:Color oldClearColor] -  The old clear color.<br />
			[property:number radius] -  The radius.<br />
			[property:WebGLRenderTarget renderTargetBright] -  The render target bright.<br />
			[property:WebGLRenderTarget[] renderTargetsHorizontal] -  The render targets horizontal.<br />
			[property:WebGLRenderTarget[] renderTargetsVertical] -  The render targets vertical.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:Vector2 resolution] -  The resolution.<br />
			[property:ShaderMaterial[] separableBlurMaterials] -  The separable blur materials.<br />
			[property:number strength] -  The strength.<br />
			[property:number threshold] -  The threshold.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:ShaderMaterial getCompositeMaterial](  ) <br />
			[method:ShaderMaterial getSeperableBlurMaterial](  ) <br />
			[method:void render](  [param:WebGLRenderer renderer],  [param:WebGLRenderTarget writeBuffer],  [param:WebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Unzip">Unzip <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Unzip Unzip](  [param:UnzipFileHandler cb]? ) - Creates a ZIP decompression stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:UnzipFileHandler onfile] - The handler to call whenever a file is discovered
		</p>
		<h4>Methods</h4>
		<p>
			[method:any push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be unzipped<br />
			[method:void register](  [param:UnzipDecoderConstructor decoder] ) - Registers a decoder with the stream, allowing for files compressed with<br />
			the compression type provided to be expanded correctly
		</p>

		<p class="desc">
			A ZIP archive decompression stream that emits files as they are discovered
		</p>

		<hr class="interface-line"/>
		<h3 id="UnzipDecoder">UnzipDecoder <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:AsyncFlateStreamHandler ondata] - The handler to call whenever data is available<br />
			[property:AsyncTerminable terminate]? - A method to terminate any internal workers used by the stream. Subsequent<br />
			calls to push() should silently fail.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array data],  [param:boolean final] ) - Pushes a chunk to be decompressed
		</p>

		<p class="desc">
			A decoder for files in ZIP streams
		</p>

		<hr class="interface-line"/>
		<h3 id="UnzipDecoderConstructor">UnzipDecoderConstructor <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:UnzipDecoder UnzipDecoder](  [param:string filename],  [param:number size]?,  [param:number originalSize]? ) - Creates an instance of the decoder
		</p>
		<h4>Properties</h4>
		<p>
			[property:number compression] - The compression format for the data stream. This number is determined by<br />
			the spec in PKZIP's APPNOTE.txt, section 4.4.5. For example, 0 = no<br />
			compression, 8 = deflate, 14 = LZMA
		</p>

		<p class="desc">
			A constructor for a decoder for unzip streams
		</p>

		<hr class="interface-line"/>
		<h3 id="UnzipFile">UnzipFile <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number compression] - The compression format for the data stream. This number is determined by<br />
			the spec in PKZIP's APPNOTE.txt, section 4.4.5. For example, 0 = no<br />
			compression, 8 = deflate, 14 = LZMA. If start() is called but there is no<br />
			decompression stream available for this method, start() will throw.<br />
			[property:string name] - The name of the file<br />
			[property:AsyncFlateStreamHandler ondata] - The handler to call whenever data is available<br />
			[property:number originalSize]? - The original size of the file<br />
			[property:number size]? - The compressed size of the file<br />
			[property:AsyncTerminable terminate] - A method to terminate any internal workers used by the stream. ondata<br />
			will not be called any further.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void start](  ) - Starts reading from the stream. Calling this function will always enable<br />
			this stream, but ocassionally the stream will be enabled even without<br />
			this being called.
		</p>

		<p class="desc">
			Streaming file extraction from ZIP archives
		</p>

		<hr class="interface-line"/>
		<h3 id="UnzipInflate">UnzipInflate <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:UnzipInflate UnzipInflate](  ) - Creates a DEFLATE decompression that can be used in ZIP archives
		</p>
		<h4>Properties</h4>
		<p>
			[property:number compression] -  The compression.<br />
			[property:AsyncFlateStreamHandler ondata] -  The ondata.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array data],  [param:boolean final] ) 
		</p>

		<p class="desc">
			Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for<br />
			better performance.
		</p>

		<hr class="interface-line"/>
		<h3 id="UnzipPassThrough">UnzipPassThrough <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number compression] -  The compression.<br />
			[property:AsyncFlateStreamHandler ondata] -  The ondata.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array data],  [param:boolean final] ) 
		</p>

		<p class="desc">
			Streaming pass-through decompression for ZIP archives
		</p>


		<p class="desc">
			An unzipped archive. The full path of each file is used as the key,<br />
			and the file is the value
		</p>

		<hr class="interface-line"/>
		<h3 id="Unzlib">Unzlib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Unzlib Unzlib](  [param:FlateStreamHandler cb]? ) - Creates a Zlib decompression stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:FlateStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be unzlibbed
		</p>

		<p class="desc">
			Streaming Zlib decompression
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Texture] &rarr; [page:DataTexture3D] &rarr;

		<h3 id="VOXDataTexture3D">VOXDataTexture3D <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VOXDataTexture3D VOXDataTexture3D](  [param:Chunk chunk] ) <br />
			[constructor:VOXDataTexture3D VOXDataTexture3D](  [param:Chunk chunk],  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth] ) <br />
			[constructor:VOXDataTexture3D VOXDataTexture3D](  [param:Chunk chunk],  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth],  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:VOXDataTexture3D VOXDataTexture3D](  [param:Chunk chunk],  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth],  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:VOXDataTexture3D clone](  ) <br />
			[method:VOXDataTexture3D copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="VOXLoader">VOXLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VOXLoader VOXLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:VOXLoader VOXLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:object[] parse](  [param:ArrayBuffer data] ) <br />
			[method:VOXLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:VOXLoader setPath](  [param:string path] ) <br />
			[method:VOXLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:VOXLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:VOXLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="VOXMesh">VOXMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VOXMesh VOXMesh](  [param:Chunk chunk] ) <br />
			[constructor:VOXMesh VOXMesh](  [param:Chunk chunk],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:VOXMesh VOXMesh](  [param:Chunk chunk],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:VOXMesh VOXMesh](  [param:Chunk chunk],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Methods</h4>
		<p>
			[method:VOXMesh add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:VOXMesh applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:VOXMesh attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:VOXMesh clear](  ) - Removes all child objects.<br />
			[method:VOXMesh clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:VOXMesh copy](  [param:VOXMesh source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:VOXMesh remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:VOXMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:VOXMesh rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:VOXMesh rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:VOXMesh rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:VOXMesh rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:VOXMesh rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:VOXMesh translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:VOXMesh translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:VOXMesh translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:VOXMesh translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VRButton">VRButton <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:HTMLElement createButton](  [param:WebGLRenderer renderer] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="VRMLLoader">VRMLLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VRMLLoader VRMLLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:VRMLLoader VRMLLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Scene parse](  [param:string data],  [param:string path] ) <br />
			[method:VRMLLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:VRMLLoader setPath](  [param:string path] ) <br />
			[method:VRMLLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:VRMLLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:VRMLLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="VRMLoader">VRMLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VRMLoader VRMLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:VRMLoader VRMLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:GLTFLoader gltfLoader] -  The gltf loader.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void parse](  [param:GLTF gltf],  [param:any onLoad] ) <br />
			[method:VRMLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:VRMLoader setDRACOLoader](  [param:DRACOLoader dracoLoader] ) <br />
			[method:VRMLoader setPath](  [param:string path] ) <br />
			[method:VRMLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:VRMLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:VRMLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="VTKLoader">VTKLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VTKLoader VTKLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:VTKLoader VTKLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:BufferGeometry parse](  [param:string|ArrayBuffer data],  [param:string path] ) <br />
			[method:VTKLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:VTKLoader setPath](  [param:string path] ) <br />
			[method:VTKLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:VTKLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:VTKLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr;

		<h3 id="VarNode">VarNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VarNode VarNode](  [param:string type],  [param:any value]? ) <br />
			[constructor:VarNode VarNode](  [param:string type],  [param:any value]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:any value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:VarNode copy](  [param:VarNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:string getType](  [param:NodeBuilder builder] ) <br />
			[method:VarNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Variable">Variable <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Variable[] dependencies] -  The dependencies.<br />
			[property:Texture initialValueTexture] -  The initial value texture.<br />
			[property:number magFilter] -  The mag filter.<br />
			[property:ShaderMaterial material] -  The material.<br />
			[property:number minFilter] -  The min filter.<br />
			[property:string name] -  The name.<br />
			[property:WebGLRenderTarget[] renderTargets] -  The render targets.<br />
			[property:number wrapS] -  The wrap s.<br />
			[property:number wrapT] -  The wrap t.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Vec2">Vec2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number x] -  The x.<br />
			[property:number y] -  The y.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Vector">Vector <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Vector Vector](  ) - Returns : aaa
		</p>
		<h4>Methods</h4>
		<p>
			[method:Vector add](  [param:Vector v] ) - Adds [page:Vector v] to this vector.<br />
			[method:Vector addScalar](  [param:number scalar] ) - Adds the scalar value s to this vector's values.<br />
			[method:Vector addScaledVector](  [param:Vector vector],  [param:number scale] ) - Adds the multiple of [page:Vector v] and [page:Float s] to this vector.<br />
			[method:Vector addVectors](  [param:Vector a],  [param:Vector b] ) - Sets this vector to [page:Vector a] + [page:Vector b].<br />
			[method:Vector clone](  ) - Returns : Returns a new Vector with the same *.x* and *.y* values as this one.<br />
			[method:Vector copy](  [param:Vector v] ) - Copies the values of the passed Vector2's *.x* and *.y* properties to this Vector2.<br />
			[method:number distanceTo](  [param:Vector v] ) - Computes the distance from this vector to [page:Vector v].<br />
			[method:number distanceToSquared](  [param:Vector v] ) - Computes the squared distance from this vector to [page:Vector v]. If you are just comparing the distance with another distance, you should compare the distance squared instead as it is slightly more efficient to calculate.<br />
			[method:Vector divideScalar](  [param:number s] ) - Divides this vector by scalar [page:Float s].<br />
			Sets vector to *( 0, 0 )* if [page:Float s] = 0.<br />
			[method:number dot](  [param:Vector v] ) - Calculates the [link:https://en.wikipedia.org/wiki/Dot_product dot product] of this   vector and [page:Vector v].<br />
			[method:boolean equals](  [param:Vector v] ) - equals(v:T):boolean;<br />
			[method:number getComponent](  [param:number index] ) <br />
			[method:number length](  ) - Computes the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]<br />
			(straight-line length) from (0, 0) to (x, y).<br />
			[method:number lengthSq](  ) - Computes the square of the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]<br />
			(straight-line length) from (0, 0) to (x, y). If you are 	comparing the lengths of vectors, you should compare the length squared instead as it is slightly more efficient to calculate.<br />
			[method:Vector lerp](  [param:Vector v],  [param:number alpha] ) - Linearly interpolates between this vector and [page:Vector v], where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be [page:Vector v].<br />
			[method:Vector multiplyScalar](  [param:number s] ) - Multiplies this vector by scalar [page:Float s].<br />
			[method:Vector negate](  ) - Inverts this vector - i.e. sets x = -x and y = -y.<br />
			[method:Vector normalize](  ) - Converts this vector to a [link:https://en.wikipedia.org/wiki/Unit_vector unit vector] - that is, sets it equal to a vector with the same direction as this one, but *.length* 1.<br />
			[method:Vector set](  [param:number[] args] ) - Sets the *.x* and *.y* components of this vector.<br />
			[method:Vector setComponent](  [param:number index],  [param:number value] ) <br />
			[method:Vector setLength](  [param:number l] ) - Sets this vector to a vector with the same direction as this one, but *.length*<br />
			[page:Float l].<br />
			[method:Vector setScalar](  [param:number scalar] ) - Sets the *.x* and *.y* values of this vector both equal to [page:Float scalar].<br />
			[method:Vector sub](  [param:Vector v] ) - Subtracts [page:Vector v] from this vector.<br />
			[method:Vector subVectors](  [param:Vector a],  [param:Vector b] ) - Sets this vector to [page:Vector a] - [page:Vector b].
		</p>

		<p class="desc">
			( interface Vector&lt;T&gt; )<br />
			Abstract interface of {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector2.js|Vector2},<br />
			{@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js|Vector3}<br />
			and {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector4.js|Vector4}.<br />
			<br />
			Currently the members of Vector is NOT type safe because it accepts different typed vectors.<br />
			<br />
			Those definitions will be changed when TypeScript innovates Generics to be type safe.
		</p>

		<hr class="interface-line"/>
		[page:Vector] &rarr;

		<h3 id="Vector2">Vector2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Vector2 Vector2](  [param:number x]?,  [param:number y]? ) - Creates a new Vector2.<br />
			[constructor:Vector2 Vector2](  [param:number x]?,  [param:number y]? ) - Returns : aaa
		</p>
		<h4>Properties</h4>
		<p>
			[property:number height] - Alias for y<br />
			[property:any isVector2] -  The is vector2.<br />
			[property:number width] - Alias for x<br />
			[property:number x] - the x value of this vector. Default is *0*<br />
			[property:number y] - the y value of this vector. Default is *0*.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Vector2 add](  [param:Vector2 v],  [param:Vector2 w]? ) - Adds v to this vector.<br />
			[method:Vector2 addScalar](  [param:number s] ) - Adds the scalar value [page:Float s] to this vector's *.x* and *.y* values.<br />
			[method:Vector2 addScaledVector](  [param:Vector2 v],  [param:number s] ) - Adds the multiple of [page:Vector2 v] and [page:Float s] to this vector.<br />
			[method:Vector2 addVectors](  [param:Vector2 a],  [param:Vector2 b] ) - Sets this vector to [page:Vector2 a] + [page:Vector2 b].<br />
			[method:number angle](  ) - Computes the angle in radians of this vector with respect to the positive x-axis.<br />
			[method:Vector2 applyMatrix3](  [param:Matrix3 m] ) - Multiplies this vector (with an implicit 1 as the 3rd component) by m.<br />
			[method:Vector2 ceil](  ) - The *.x* and *.y* components of this vector are rounded up to the nearest integer value.<br />
			[method:Vector2 clamp](  [param:Vector2 min],  [param:Vector2 max] ) - If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value.<br />
			[method:Vector2 clampLength](  [param:number min],  [param:number max] ) - If this vector's length is less than the min value, it is replaced by the min value.<br />
			[method:Vector2 clampScalar](  [param:number min],  [param:number max] ) - If this vector's x or y values are less than the min value, they are replaced by the min value.<br />
			[method:Vector2 clone](  ) - Returns : Returns a new Vector2 with the same *.x* and *.y* values as this one.<br />
			[method:Vector2 copy](  [param:Vector2 v] ) - Copies the values of the passed Vector2's *.x* and *.y* properties to this Vector2.<br />
			[method:number cross](  [param:Vector2 v] ) - Calculates the [cross product](https://en.wikipedia.org/wiki/Cross_product) of this   vector and [v](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Vector2). Note that a 'cross-product' in 2D is not well-defined. This function computes a geometric cross-product often used in 2D graphics &lt;h3&gt;[method:Boolean equals]( [param:Vector2 v] )&lt;/h3&gt;<br />
			<br />
			Returns : Returns *true* if the components of this vector and [page:Vector2 v] are strictly equal; *false* otherwise.<br />
			[method:number distanceTo](  [param:Vector2 v] ) - Computes the distance from this vector to [page:Vector2 v].<br />
			[method:number distanceToManhattan](  [param:Vector2 v] ) - deprecated - Use {@link Vector2#manhattanDistanceTo .manhattanDistanceTo()} instead.<br />
			[method:number distanceToSquared](  [param:Vector2 v] ) - Computes the squared distance from this vector to [page:Vector2 v]. If you are just comparing the distance with another distance, you should compare the distance squared instead as it is slightly more efficient to calculate.<br />
			[method:Vector2 divide](  [param:Vector2 v] ) - Divides this vector by [page:Vector2 v].<br />
			[method:Vector2 divideScalar](  [param:number s] ) - Divides this vector by scalar [page:Float s].<br />
			Sets vector to *( 0, 0 )* if [page:Float s] = 0.<br />
			[method:number dot](  [param:Vector2 v] ) - Calculates the [link:https://en.wikipedia.org/wiki/Dot_product dot product] of this   vector and [page:Vector2 v].<br />
			[method:boolean equals](  [param:Vector2 v] ) - Checks for strict equality of this vector and v.<br />
			[method:Vector2 floor](  ) - The components of this vector are rounded down to the nearest integer value.<br />
			[method:Vector2 fromArray](  [param:ArrayLike|number[] array],  [param:number offset]? ) - Returns : Returns an array [x, y], or copies x and y into the provided [page:Array array].<br />
			[method:Vector2 fromBufferAttribute](  [param:BufferAttribute attribute],  [param:number index] ) - Sets this vector's *.x* and *.y* values from the [page:BufferAttribute attribute].<br />
			[method:number getComponent](  [param:number index] ) - If index equals 0 returns the *.x* value.<br />
			If index equals 1 returns the *.y* value.<br />
			[method:number length](  ) - Computes the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length] (straight-line length) from (0, 0) to (x, y).<br />
			[method:number lengthManhattan](  ) - deprecated - Use {@link Vector2#manhattanLength .manhattanLength()} instead.<br />
			[method:number lengthSq](  ) - Computes the square of the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]<br />
			(straight-line length) from (0, 0) to (x, y). If you are comparing the lengths of vectors, you should compare the length squared instead as it is slightly more efficient to calculate.<br />
			[method:Vector2 lerp](  [param:Vector2 v],  [param:number alpha] ) - Linearly interpolates between this vector and [page:Vector2 v], where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be [page:Vector2 v].<br />
			[method:Vector2 lerpVectors](  [param:Vector2 v1],  [param:Vector2 v2],  [param:number alpha] ) - Sets this vector to be the vector linearly interpolated between [page:Vector2 v1] and [page:Vector2 v2] where alpha is the percent distance along the line connecting the two vectors - alpha = 0 will be [page:Vector2 v1], and alpha = 1 will be [page:Vector2 v2].<br />
			[method:number manhattanDistanceTo](  [param:Vector2 v] ) - Computes the [link:https://en.wikipedia.org/wiki/Taxicab_geometry Manhattan distance] from this vector to [page:Vector2 v].<br />
			[method:number manhattanLength](  ) - Computes the [link:http://en.wikipedia.org/wiki/Taxicab_geometry Manhattan length] of this vector.<br />
			[method:Vector2 max](  [param:Vector2 v] ) - If this vector's x or y value is less than [page:Vector2 v]'s x or y value, replace that value with the corresponding max value.<br />
			[method:Vector2 min](  [param:Vector2 v] ) - If this vector's x or y value is greater than [page:Vector2 v]'s x or y value, replace that value with the corresponding min value.<br />
			[method:Vector2 multiply](  [param:Vector2 v] ) - Multiplies this vector by [page:Vector2 v].<br />
			[method:Vector2 multiplyScalar](  [param:number scalar] ) - Multiplies this vector by scalar [page:Float s].<br />
			[method:Vector2 negate](  ) - Inverts this vector - i.e. sets x = -x and y = -y.<br />
			[method:Vector2 normalize](  ) - Converts this vector to a [link:https://en.wikipedia.org/wiki/Unit_vector unit vector] - that is, sets it equal to a vector with the same direction as this one, but *.length* 1.<br />
			[method:Vector2 random](  ) - Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1.<br />
			[method:Vector2 rotateAround](  [param:Vector2 center],  [param:number angle] ) - Rotates this vector around [page:Vector2 center] by [page:Float angle] radians.<br />
			[method:Vector2 round](  ) - The components of this vector are rounded to the nearest integer value.<br />
			[method:Vector2 roundToZero](  ) - The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value.<br />
			[method:Vector2 set](  [param:number x],  [param:number y] ) - Sets the *.x* and *.y* components of this vector.<br />
			[method:Vector2 setComponent](  [param:number index],  [param:number value] ) - If index equals 0 set *.x* to [page:Float value].<br />
			If index equals 1 set *.y* to [page:Float value]<br />
			[method:Vector2 setLength](  [param:number length] ) - Sets this vector to a vector with the same direction as this one, but *.length*<br />
			[method:Vector2 setScalar](  [param:number scalar] ) - Sets the *.x* and *.y* values of this vector both equal to [page:Float scalar].<br />
			[method:Vector2 setX](  [param:number x] ) - Replaces this vector's *.x* value with [page:Float x].<br />
			[method:Vector2 setY](  [param:number y] ) - Replaces this vector's *.y* value with [page:Float y].<br />
			[method:Vector2 sub](  [param:Vector2 v] ) - Subtracts [page:Vector2 v] from this vector.<br />
			[method:Vector2 subScalar](  [param:number s] ) - Subtracts [page:Float s]  from this vector's *.x* and *.y* components.<br />
			[method:Vector2 subVectors](  [param:Vector2 a],  [param:Vector2 b] ) - Sets this vector to [page:Vector2 a] - [page:Vector2 b].
		</p>

		<p class="desc">
			Class representing a 2D [link:https://en.wikipedia.org/wiki/Vector_space vector].<br />
			A 2D vector is an ordered pair of numbers (labeled x and y), which can be used to represent a number of things, such as:<br />
			A point in 2D space (i.e. a position on a plane).<br />
			A direction and length across a plane. In three.js the length will always be the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean distance]e (straight-line distance) from (0, 0) to (x, y) and the direction is also measured from (0, 0) towards (x, y).<br />
			Any arbitrary ordered pair of numbers.<br />
			There are other things a 2D vector can be used to represent, such as momentum vectors, complex numbers and so on,	however these are the most common uses in three.js.<br />
			Iterating through a Vector2 instance will yield its components (x, y) in the corresponding order.<br />
			<code data-type="javascript"><br />
			const a = new THREE.Vector2( 0, 1 );<br />
			// no arguments; will be initialised to (0, 0)<br />
			const b = new THREE.Vector2( );<br />
			const d = a.distanceTo( b );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="Vector2Node">Vector2Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Vector2Node Vector2Node](  [param:number|Vector2 x],  [param:number y]? ) <br />
			[constructor:Vector2Node Vector2Node](  [param:number|Vector2 x],  [param:number y]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Vector2Node Vector2Node](  [param:number|Vector2 x],  [param:number y]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Vector2Node Vector2Node](  [param:number|Vector2 x],  [param:number y]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Vector2 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:Vector2Node copy](  [param:Vector2Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:Vector2Node setLabel](  [param:string name] ) <br />
			[method:Vector2Node setName](  [param:string name] ) <br />
			[method:Vector2Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Vector] &rarr;

		<h3 id="Vector3">Vector3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Vector3 Vector3](  [param:number x]?,  [param:number y]?,  [param:number z]? ) <br />
			[constructor:Vector3 Vector3](  [param:number x]?,  [param:number y]?,  [param:number z]? ) - Returns : aaa
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isVector3] -  The is vector3.<br />
			[property:number x] - the x value of this vector. Default is *0*.<br />
			[property:number y] - the y value of this vector. Default is *0*.<br />
			[property:number z] - the z value of this vector. Default is *0*.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Vector3 add](  [param:Vector3 v] ) - Adds [page:Vector3 v] to this vector.<br />
			[method:Vector3 addScalar](  [param:number s] ) - Adds the scalar value s to this vector's *.x*, *.y* and *.z* values.<br />
			[method:Vector3 addScaledVector](  [param:Vector3 v],  [param:number s] ) - Adds the multiple of [page:Vector3 v] and [page:Float s] to this vector.<br />
			[method:Vector3 addVectors](  [param:Vector3 a],  [param:Vector3 b] ) - Sets this vector to [page:Vector3 a] + [page:Vector3 b].<br />
			[method:number angleTo](  [param:Vector3 v] ) - Returns : Returns the angle between this vector and vector [page:Vector3 v] in radians.<br />
			[method:Vector3 applyAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Applies a rotation specified by an axis and an angle to this vector.<br />
			[method:Vector3 applyEuler](  [param:Euler euler] ) - Applies euler transform to this vector by converting the [page:Euler Euler] object to a [page:Quaternion Quaternion] and applying.<br />
			[method:Vector3 applyMatrix3](  [param:Matrix3 m] ) - Multiplies this vector by [page:Matrix3 m]<br />
			[method:Vector3 applyMatrix4](  [param:Matrix4 m] ) - Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective.<br />
			[method:Vector3 applyNormalMatrix](  [param:Matrix3 m] ) - Multiplies this vector by normal matrix [page:Matrix3 m] and normalizes the result.<br />
			[method:Vector3 applyQuaternion](  [param:Quaternion q] ) - Applies a [page:Quaternion Quaternion] transform to this vector.<br />
			[method:Vector3 ceil](  ) - The *.x*, *.y* and *.z* components of this vector are rounded up to the nearest integer value.<br />
			[method:Vector3 clamp](  [param:Vector3 min],  [param:Vector3 max] ) - If this vector's x, y or z value is less than the min vector's x, y or z value, it is replaced by the corresponding value.<br />
			[method:Vector3 clampLength](  [param:number min],  [param:number max] ) - If this vector's length is less than the min value, the vector will be scaled up so its length is the min value.<br />
			[method:Vector3 clampScalar](  [param:number min],  [param:number max] ) - If this vector's x, y or z values are less than the min value, they are replaced by the min value.<br />
			[method:Vector3 clone](  ) - Returns : Returns a new vector3 with the same *.x*, *.y* and *.z* values as this one.<br />
			[method:Vector3 copy](  [param:Vector3 v] ) - Copies the values of the passed vector3's *.x*, *.y* and *.z* properties to this vector3.<br />
			[method:Vector3 cross](  [param:Vector3 a] ) - Sets this vector to [link:https://en.wikipedia.org/wiki/Cross_product cross product] of itself and [page:Vector3 v].<br />
			[method:Vector3 crossVectors](  [param:Vector3 a],  [param:Vector3 b] ) - Sets this vector to [link:https://en.wikipedia.org/wiki/Cross_product cross product] of [page:Vector3 a] and [page:Vector3 b].<br />
			[method:number distanceTo](  [param:Vector3 v] ) - Computes the distance from this vector to [page:Vector3 v].<br />
			[method:number distanceToManhattan](  [param:Vector3 v] ) - deprecated - Use {@link Vector3#manhattanDistanceTo .manhattanDistanceTo()} instead.<br />
			[method:number distanceToSquared](  [param:Vector3 v] ) - Computes the squared distance from this vector to [page:Vector3 v]. If you are just comparing the distance with another distance, you should compare the distance squared instead as it is slightly more efficient to calculate.<br />
			[method:Vector3 divide](  [param:Vector3 v] ) - Divides this vector by [page:Vector3 v].<br />
			[method:Vector3 divideScalar](  [param:number s] ) - Divides this vector by scalar [page:Float s].<br />
			Sets vector to *( 0, 0, 0 )* if *[page:Float s] = 0*.<br />
			[method:number dot](  [param:Vector3 v] ) - Calculate the [link:https://en.wikipedia.org/wiki/Dot_product dot product] of this vector and [page:Vector3 v].<br />
			[method:boolean equals](  [param:Vector3 v] ) - Returns : Returns *true* if the components of this vector and [page:Vector3 v] are strictly equal; *false* otherwise.<br />
			[method:Vector3 floor](  ) - The components of this vector are rounded down to the nearest integer value.<br />
			[method:Vector3 fromArray](  [param:ArrayLike|number[] array],  [param:number offset]? ) - Sets this vector's *.x* value to be array[ offset + 0 ], *.y* value to be array[ offset + 1 ] and *.z* value to be array[ offset + 2 ].<br />
			[method:Vector3 fromBufferAttribute](  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:number index] ) - Sets this vector's *.x*, *.y* and *.z* values from the [page:BufferAttribute attribute].<br />
			[method:number getComponent](  [param:number index] ) - If index equals 0 returns the *.x* value.<br />
			If index equals 1 returns the *.y* value.<br />
			If index equals 2 returns the *.z* value.<br />
			[method:number length](  ) - Computes the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length] (straight-line length) from (0, 0, 0) to (x, y, z).<br />
			[method:number lengthManhattan](  ) - Computes Manhattan length of this vector.<br />
			http://en.wikipedia.org/wiki/Taxicab_geometry<br />
			<br />
			deprecated - Use {@link Vector3#manhattanLength .manhattanLength()} instead.<br />
			[method:number lengthSq](  ) - Computes the square of the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]<br />
			(straight-line length) from (0, 0, 0) to (x, y, z). If you are 	comparing the lengths of vectors, you should compare the length squared instead as it is slightly more efficient to calculate.<br />
			[method:Vector3 lerp](  [param:Vector3 v],  [param:number alpha] ) - Linearly interpolate between this vector and [page:Vector3 v], where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be [page:Vector3 v].<br />
			[method:Vector3 lerpVectors](  [param:Vector3 v1],  [param:Vector3 v2],  [param:number alpha] ) - Sets this vector to be the vector linearly interpolated between [page:Vector3 v1] and [page:Vector3 v2] where alpha is the percent distance along the line connecting the two vectors - alpha = 0 will be [page:Vector3 v1], and alpha = 1 will be [page:Vector3 v2].<br />
			[method:number manhattanDistanceTo](  [param:Vector3 v] ) - Computes the [link:https://en.wikipedia.org/wiki/Taxicab_geometry Manhattan distance] from this vector to [page:Vector3 v].<br />
			[method:number manhattanLength](  ) - Computes the [link:http://en.wikipedia.org/wiki/Taxicab_geometry Manhattan length] of this vector.<br />
			[method:Vector3 max](  [param:Vector3 v] ) - If this vector's x, y or z value is less than [page:Vector3 v]'s x, y or z value, replace that value with the corresponding max value.<br />
			[method:Vector3 min](  [param:Vector3 v] ) - If this vector's x, y or z value is greater than [page:Vector3 v]'s x, y or z value, replace that value with the corresponding min value.<br />
			[method:Vector3 multiply](  [param:Vector3 v] ) - Multiplies this vector by [page:Vector3 v].<br />
			[method:Vector3 multiplyScalar](  [param:number s] ) - Multiplies this vector by scalar [page:Float s].<br />
			[method:Vector3 multiplyVectors](  [param:Vector3 a],  [param:Vector3 b] ) - Sets this vector equal to [page:Vector3 a] * [page:Vector3 b], component-wise.<br />
			[method:Vector3 negate](  ) - Inverts this vector - i.e. sets x = -x, y = -y and z = -z.<br />
			[method:Vector3 normalize](  ) - Convert this vector to a [link:https://en.wikipedia.org/wiki/Unit_vector unit vector] - that is, sets it equal to a vector with the same direction as this one, but *.length* 1.<br />
			[method:Vector3 project](  [param:Camera camera] ) - Projects this vector from world space into the camera's normalized device coordinate (NDC) space.<br />
			[method:Vector3 projectOnPlane](  [param:Vector3 planeNormal] ) - [link:https://en.wikipedia.org/wiki/Vector_projection Projects] this vector onto a plane by subtracting this vector projected onto the plane's normal from this vector.<br />
			[method:Vector3 projectOnVector](  [param:Vector3 v] ) - [link:https://en.wikipedia.org/wiki/Vector_projection Projects] this vector onto [page:Vector3 v].<br />
			[method:Vector3 random](  ) - Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1.<br />
			[method:Vector3 randomDirection](  ) - Sets this vector to a uniformly random point on a unit sphere.<br />
			[method:Vector3 reflect](  [param:Vector3 vector] ) <br />
			[method:Vector3 round](  ) - The components of this vector are rounded to the nearest integer value.<br />
			[method:Vector3 roundToZero](  ) - The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value.<br />
			[method:Vector3 set](  [param:number x],  [param:number y],  [param:number z] ) - Sets the *.x*, *.y* and *.z* components of this vector.<br />
			[method:Vector3 setComponent](  [param:number index],  [param:number value] ) - If index equals 0 set *.x* to [page:Float value].<br />
			If index equals 1 set *.y* to [page:Float value].<br />
			If index equals 2 set *.z* to [page:Float value]<br />
			[method:Vector3 setFromCylindrical](  [param:Cylindrical s] ) - Sets this vector from the cylindrical coordinates [page:Cylindrical c].<br />
			[method:Vector3 setFromCylindricalCoords](  [param:number radius],  [param:number theta],  [param:number y] ) - Sets this vector from the cylindrical coordinates [page:Cylindrical radius], [page:Cylindrical theta] and [page:Cylindrical y].<br />
			[method:Vector3 setFromMatrix3Column](  [param:Matrix3 matrix],  [param:number index] ) - Sets this vector's *.x*, *.y* and *.z* components from [page:Integer index] column of [page:Matrix3 matrix].<br />
			[method:Vector3 setFromMatrixColumn](  [param:Matrix4 matrix],  [param:number index] ) - Sets this vector's *.x*, *.y* and *.z* components from [page:Integer index] column of [page:Matrix4 matrix].<br />
			[method:Vector3 setFromMatrixPosition](  [param:Matrix4 m] ) - Sets this vector to the position elements of the [link:https://en.wikipedia.org/wiki/Transformation_matrix transformation matrix] [page:Matrix4 m].<br />
			[method:Vector3 setFromMatrixScale](  [param:Matrix4 m] ) - Sets this vector to the scale elements of the [link:https://en.wikipedia.org/wiki/Transformation_matrix transformation matrix] [page:Matrix4 m].<br />
			[method:Vector3 setFromSpherical](  [param:Spherical s] ) - Sets this vector from the spherical coordinates [page:Spherical s].<br />
			[method:Vector3 setFromSphericalCoords](  [param:number r],  [param:number phi],  [param:number theta] ) - Sets this vector from the spherical coordinates [page:Spherical radius], [page:Spherical phi] and [page:Spherical theta].<br />
			[method:Vector3 setLength](  [param:number l] ) - Set this vector to a vector with the same direction as this one, but *.length*<br />
			[page:Float l].<br />
			[method:Vector3 setScalar](  [param:number scalar] ) - Set the *.x*, *.y* and *.z* values of this vector both equal to [page:Float scalar].<br />
			[method:Vector3 setX](  [param:number x] ) - Replace this vector's *.y* value with [page:Float y].<br />
			[method:Vector3 setY](  [param:number y] ) - Replace this vector's *.y* value with [page:Float y].<br />
			[method:Vector3 setZ](  [param:number z] ) - Replace this vector's *.z* value with [page:Float z].<br />
			[method:Vector3 sub](  [param:Vector3 a] ) - Subtracts [page:Vector3 v] from this vector.<br />
			[method:Vector3 subScalar](  [param:number s] ) - Subtracts [page:Float s]  from this vector's *.x*, *.y* and *.z* compnents.<br />
			[method:Vector3 subVectors](  [param:Vector3 a],  [param:Vector3 b] ) - Sets this vector to [page:Vector3 a] - [page:Vector3 b].<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns : Returns an array [x, y, z], or copies x, y and z into the provided [page:Array array].<br />
			[method:Vector3 transformDirection](  [param:Matrix4 m] ) - Transforms the direction of this vector by a matrix (the upper left 3 x 3 subset of a [page:Matrix4 m]) and then *.normalize* the result.<br />
			[method:Vector3 unproject](  [param:Camera camera] ) - Projects this vector from the camera's normalized device coordinate (NDC) space into world space.
		</p>

		<p class="desc">
			Class representing a 3D [vector](https://en.wikipedia.org/wiki/Vector_space).<br />
			A 3D vector is an ordered triplet of numbers (labeled x, y, and z), which can be used to represent a number of things, such as:<br />
			A point in 3D space.<br />
			A direction and length in 3D space. In three.js the length will always be the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance)e (straight-line distance) from (0, 0, 0) to (x, y, z) and the direction is also measured from (0, 0, 0) towards (x, y, z).<br />
			Any arbitrary ordered triplet of numbers.<br />
			There are other things a 3D vector can be used to represent, such as momentum vectors and so on, however these are the most common uses in three.js.<br />
			Iterating through a Vector3 instance will yield its components (x, y, z) in the corresponding order.<br />
			<code data-type="javascript"><br />
			const a = new THREE.Vector3( 0, 1, 0 );<br />
			// no arguments; will be initialised to (0, 0, 0)<br />
			const b = new THREE.Vector3( );<br />
			const d = a.distanceTo( b );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="Vector3Node">Vector3Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Vector3Node Vector3Node](  [param:number|Vector3 x],  [param:number y]?,  [param:number z]? ) <br />
			[constructor:Vector3Node Vector3Node](  [param:number|Vector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Vector3Node Vector3Node](  [param:number|Vector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Vector3Node Vector3Node](  [param:number|Vector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Vector3 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:Vector3Node copy](  [param:Vector3Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:Vector3Node setLabel](  [param:string name] ) <br />
			[method:Vector3Node setName](  [param:string name] ) <br />
			[method:Vector3Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Vector] &rarr;

		<h3 id="Vector4">Vector4 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Vector4 Vector4](  [param:number x]?,  [param:number y]?,  [param:number z]?,  [param:number w]? ) - Creates a new Vector4.<br />
			[constructor:Vector4 Vector4](  [param:number x]?,  [param:number y]?,  [param:number z]?,  [param:number w]? ) - Returns : aaa
		</p>
		<h4>Properties</h4>
		<p>
			[property:number height] - Alias for *.w*.<br />
			[property:any isVector4] -  The is vector4.<br />
			[property:number w] - the w value of this vector. Default is *0*.<br />
			[property:number width] - Alias for *.z*.<br />
			[property:number x] - the x value of this vector. Default is *0*.<br />
			[property:number y] - the y value of this vector. Default is *0*.<br />
			[property:number z] - the z value of this vector. Default is *0*.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Vector4 add](  [param:Vector4 v] ) - Adds the scalar value s to this vector's *.x*, *.y*, *.z* and *.w* values.<br />
			[method:Vector4 addScalar](  [param:number scalar] ) - Adds the scalar value s to this vector's *.x*, *.y*, *.z* and *.w* values.<br />
			[method:Vector4 addScaledVector](  [param:Vector4 v],  [param:number s] ) - Adds the multiple of [page:Vector4 v] and [page:Float s] to this vector.<br />
			[method:Vector4 addVectors](  [param:Vector4 a],  [param:Vector4 b] ) - Sets this vector to [page:Vector4 a] + [page:Vector4 b].<br />
			[method:Vector4 applyMatrix4](  [param:Matrix4 m] ) - Multiplies this vector by 4 x 4 [page:Matrix4 m].<br />
			[method:Vector4 ceil](  ) - The *.x*, *.y*, *.z* and *.w* components of this vector are rounded up to the nearest integer value.<br />
			[method:Vector4 clamp](  [param:Vector4 min],  [param:Vector4 max] ) - If this vector's x, y, z or w value is less than the min vector's x, y, z or w value, it is replaced by the corresponding value.<br />
			[method:Vector4 clampLength](  [param:number min],  [param:number max] ) - If this vector's length is less than the min value, it is replaced by the min value.<br />
			[method:Vector4 clampScalar](  [param:number min],  [param:number max] ) - If this vector's x, y, z or w values are less than the min value, they are replaced by the min value.<br />
			[method:Vector4 clone](  ) - Returns : Returns a new Vector4 with the same *.x*, *.y*, *.z* and *.w* values as this one.<br />
			[method:Vector4 copy](  [param:Vector4 v] ) - Copies the values of the passed Vector4's *.x*, *.y*, *.z* and *.w* properties to this Vector4.<br />
			[method:number distanceTo](  [param:Vector v] ) - Computes the distance from this vector to [page:Vector v].<br />
			[method:number distanceToSquared](  [param:Vector v] ) - Computes the squared distance from this vector to [page:Vector v]. If you are just comparing the distance with another distance, you should compare the distance squared instead as it is slightly more efficient to calculate.<br />
			[method:Vector4 divideScalar](  [param:number s] ) - Divides this vector by scalar [page:Float s].<br />
			Sets vector to *( 0, 0, 0, 0 )* if *[page:Float s] = 0*.<br />
			[method:number dot](  [param:Vector4 v] ) - Calculates the [link:https://en.wikipedia.org/wiki/Dot_product dot product] of this vector and [page:Vector4 v].<br />
			[method:boolean equals](  [param:Vector4 v] ) - Returns : Returns *true* if the components of this vector and [page:Vector4 v] are strictly equal; *false* otherwise.<br />
			[method:Vector4 floor](  ) - The components of this vector are rounded down to the nearest integer value.<br />
			[method:Vector4 fromArray](  [param:number[] array],  [param:number offset]? ) - Sets this vector's *.x* value to be array[ offset + 0 ], *.y* value to be array[ offset + 1 ] *.z* value to be array[ offset + 2 ] and *.w* value to be array[ offset + 3 ].<br />
			[method:Vector4 fromBufferAttribute](  [param:BufferAttribute attribute],  [param:number index] ) - Sets this vector's *.x*, *.y*, *.z* and *.w* values from the [page:BufferAttribute attribute].<br />
			[method:number getComponent](  [param:number index] ) - If index equals 0 returns the *.x* value.<br />
			If index equals 1 returns the *.y* value.<br />
			If index equals 2 returns the *.z* value.<br />
			If index equals 3 returns the *.w* value.<br />
			[method:number length](  ) - Computes the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length] (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).<br />
			[method:number lengthSq](  ) - Computes the square of the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]<br />
			(straight-line length) from (0, 0, 0, 0) to (x, y, z, w). If you are 	comparing the lengths of vectors, you should compare the length squared instead as it is slightly more efficient to calculate.<br />
			[method:Vector4 lerp](  [param:Vector4 v],  [param:number alpha] ) - Linearly interpolates between this vector and [page:Vector4 v], where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be [page:Vector4 v].<br />
			[method:Vector4 lerpVectors](  [param:Vector4 v1],  [param:Vector4 v2],  [param:number alpha] ) - Sets this vector to be the vector linearly interpolated between [page:Vector4 v1] and [page:Vector4 v2] where alpha is the percent distance along the line connecting the two vectors - alpha = 0 will be [page:Vector4 v1], and alpha = 1 will be [page:Vector4 v2].<br />
			[method:number manhattanLength](  ) - Computes the [link:http://en.wikipedia.org/wiki/Taxicab_geometry Manhattan length] of this vector.<br />
			[method:Vector4 max](  [param:Vector4 v] ) - If this vector's x, y, z or w value is less than [page:Vector4 v]'s x, y, z or w value, replace that value with the corresponding max value.<br />
			[method:Vector4 min](  [param:Vector4 v] ) - If this vector's x, y, z or w value is greater than [page:Vector4 v]'s x, y, z or w value, replace that value with the corresponding min value.<br />
			[method:Vector4 multiply](  [param:Vector4 v] ) - Multiplies this vector by [page:Vector4 v].<br />
			[method:Vector4 multiplyScalar](  [param:number s] ) - Multiplies this vector by scalar [page:Float s].<br />
			[method:Vector4 negate](  ) - Inverts this vector - i.e. sets x = -x, y = -y, z = -z and w = -w.<br />
			[method:Vector4 normalize](  ) - Converts this vector to a [link:https://en.wikipedia.org/wiki/Unit_vector unit vector] - that is, sets it equal to a vector with the same direction as this one, but *.length* 1.<br />
			[method:Vector4 random](  ) - Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1.<br />
			[method:Vector4 round](  ) - The components of this vector are rounded to the nearest integer value.<br />
			[method:Vector4 roundToZero](  ) - The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value.<br />
			[method:Vector4 set](  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets the *.x*, *.y*, *.z* and *.w* components of this vector.<br />
			[method:Vector4 setAxisAngleFromQuaternion](  [param:Quaternion q] ) - Sets the *.x*, *.y* and *.z* components of this vector to the quaternion's axis and *.w* to the angle.<br />
			[method:Vector4 setAxisAngleFromRotationMatrix](  [param:Matrix4 m] ) - Sets the *.x*, *.y* and *.z* to the axis of rotation and *.w* to the angle.<br />
			[method:Vector4 setComponent](  [param:number index],  [param:number value] ) - If index equals 0 set *.x* to [page:Float value].<br />
			If index equals 1 set *.y* to [page:Float value].<br />
			If index equals 2 set *.z* to [page:Float value].<br />
			If index equals 3 set *.w* to [page:Float value].<br />
			[method:Vector4 setLength](  [param:number length] ) - Sets this vector to a vector with the same direction as this one, but *.length*<br />
			[method:Vector4 setScalar](  [param:number scalar] ) - Sets the *.x*, *.y*, *.z* and *.w* values of this vector both equal to [page:Float scalar].<br />
			[method:Vector4 setW](  [param:number w] ) - Replaces this vector's *.w* value with [page:Float w].<br />
			[method:Vector4 setX](  [param:number x] ) - Replaces this vector's *.x* value with [page:Float x].<br />
			[method:Vector4 setY](  [param:number y] ) - Replaces this vector's *.y* value with [page:Float y].<br />
			[method:Vector4 setZ](  [param:number z] ) - Replaces this vector's *.z* value with [page:Float z].<br />
			[method:Vector4 sub](  [param:Vector4 v] ) - Subtracts [page:Vector4 v] from this vector.<br />
			[method:Vector4 subScalar](  [param:number s] ) - Subtracts [page:Float s]  from this vector's *.x*, *.y*, *.z* and *.w* compnents.<br />
			[method:Vector4 subVectors](  [param:Vector4 a],  [param:Vector4 b] ) - Sets this vector to [page:Vector4 a] - [page:Vector4 b].<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns : Returns an array [x, y, z, w], or copies x, y, z and w into the provided [page:Array array].
		</p>

		<p class="desc">
			Class representing a 4D [vector](https://en.wikipedia.org/wiki/Vector_space).<br />
			A 4D vector is an ordered quadruplet of numbers (labeled x, y, z, and w), which can be used to represent a number of things, such as:<br />
			A point in 4D space.<br />
			A direction and length in 4D space. In three.js the length will always be the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance)e (straight-line distance) from (0, 0, 0, 0) to (x, y, z, w) and the direction is also measured from (0, 0, 0, 0) towards (x, y, z, w).<br />
			Any arbitrary ordered quadruplet of numbers.<br />
			There are other things a 4D vector can be used to represent, however these are the most common uses in three.js.<br />
			Iterating through a Vector4 instance will yield its components (x, y, z, w) in the corresponding order.<br />
			<code data-type="javascript"><br />
			const a = new THREE.Vector4( 0, 1, 0, 0 );<br />
			// no arguments; will be initialised to (0, 0, 0, 1)<br />
			const b = new THREE.Vector4( );<br />
			const d = a.dot( b );<br />
			</code>
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr;

		<h3 id="Vector4Node">Vector4Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Vector4Node Vector4Node](  [param:number|Vector4 x],  [param:number y]?,  [param:number z]?,  [param:number w]? ) <br />
			[constructor:Vector4Node Vector4Node](  [param:number|Vector4 x],  [param:number y]?,  [param:number z]?,  [param:number w]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Vector4Node Vector4Node](  [param:number|Vector4 x],  [param:number y]?,  [param:number z]?,  [param:number w]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:Vector4Node Vector4Node](  [param:number|Vector4 x],  [param:number y]?,  [param:number z]?,  [param:number w]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Vector4 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:Vector4Node copy](  [param:Vector4Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:Vector4Node setLabel](  [param:string name] ) <br />
			[method:Vector4Node setName](  [param:string name] ) <br />
			[method:Vector4Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VectorEx">VectorEx <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:T get](  [param:number index] ) <br />
			[method:number size](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:KeyframeTrack] &rarr;

		<h3 id="VectorKeyframeTrack">VectorKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VectorKeyframeTrack VectorKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) <br />
			[constructor:VectorKeyframeTrack VectorKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]?,  [param:string name],  [param:ArrayLike times],  [param:ArrayLike values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:DiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:LinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:CubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:VectorKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:KeyframeTrack optimize](  ) <br />
			[method:KeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:KeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:KeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:any toJSON](  [param:KeyframeTrack track] ) <br />
			[method:KeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:NodeNode] &rarr; [page:TempNode] &rarr; [page:InputNode] &rarr; [page:Vector3Node] &rarr;

		<h3 id="VelocityNode">VelocityNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VelocityNode VelocityNode](  [param:Object3D target],  [param:VelocityNodeParams params]? ) <br />
			[constructor:VelocityNode VelocityNode](  [param:Object3D target],  [param:VelocityNodeParams params]?,  [param:number|Vector3 x],  [param:number y]?,  [param:number z]? ) <br />
			[constructor:VelocityNode VelocityNode](  [param:Object3D target],  [param:VelocityNodeParams params]?,  [param:number|Vector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:VelocityNode VelocityNode](  [param:Object3D target],  [param:VelocityNodeParams params]?,  [param:number|Vector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]? ) <br />
			[constructor:VelocityNode VelocityNode](  [param:Object3D target],  [param:VelocityNodeParams params]?,  [param:number|Vector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type],  [param:TempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:Vector3 lastVelocity] -  The last velocity.<br />
			[property:Vector3 moment] -  The moment.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:Vector3 speed] -  The speed.<br />
			[property:Vector3 springVelocity] -  The spring velocity.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Vector3 value] -  The value.<br />
			[property:Vector3 velocity] -  The velocity.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:NodeBuilder builder],  [param:object settings]? ) <br />
			[method:NodeFlow analyzeAndFlow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:NodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:VelocityNode copy](  [param:VelocityNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:NodeFlow flow](  [param:NodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:NodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:NodeBuilder builder] ) <br />
			[method:string getName](  [param:NodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:NodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:NodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:NodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:NodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:VelocityNode setLabel](  [param:string name] ) <br />
			[method:VelocityNode setName](  [param:string name] ) <br />
			[method:void setParams](  [param:VelocityNodeParams params] ) <br />
			[method:VelocityNode setReadonly](  [param:boolean value] ) <br />
			[method:void setTarget](  [param:Object3D target] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:NodeFrame frame] ) <br />
			[method:void updateFrameVelocity](  [param:NodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VelocityNodeParams">VelocityNodeParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number damping] -  The damping.<br />
			[property:number spring] -  The spring.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VertexList">VertexList <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VertexList VertexList](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:VertexNode head] -  The head.<br />
			[property:VertexNode tail] -  The tail.
		</p>
		<h4>Methods</h4>
		<p>
			[method:VertexList append](  [param:VertexNode vertex] ) <br />
			[method:VertexList appendChain](  [param:VertexNode vertex] ) <br />
			[method:VertexList clear](  ) <br />
			[method:VertexNode first](  ) <br />
			[method:VertexList insertAfter](  [param:VertexNode target],  [param:VertexNode vertex] ) <br />
			[method:VertexList insertBefore](  [param:VertexNode target],  [param:VertexNode vertex] ) <br />
			[method:boolean isEmpty](  ) <br />
			[method:VertexNode last](  ) <br />
			[method:VertexList remove](  [param:VertexNode vertex] ) <br />
			[method:VertexList removeSubList](  [param:VertexNode a],  [param:VertexNode b] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VertexNode">VertexNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VertexNode VertexNode](  [param:Vector3 point] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:FaceEx face] -  The face.<br />
			[property:VertexNode next] -  The next.<br />
			[property:Vector3 point] -  The point.<br />
			[property:VertexNode prev] -  The prev.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="VertexNormalsHelper">VertexNormalsHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VertexNormalsHelper VertexNormalsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]? ) <br />
			[constructor:VertexNormalsHelper VertexNormalsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:VertexNormalsHelper VertexNormalsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:VertexNormalsHelper VertexNormalsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:VertexNormalsHelper VertexNormalsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Object3D object] -  The object.<br />
			[property:number size] -  The size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:VertexNormalsHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:VertexNormalsHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:VertexNormalsHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:VertexNormalsHelper clear](  ) - Removes all child objects.<br />
			[method:VertexNormalsHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:VertexNormalsHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:VertexNormalsHelper copy](  [param:VertexNormalsHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:VertexNormalsHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:VertexNormalsHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:VertexNormalsHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:VertexNormalsHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:VertexNormalsHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:VertexNormalsHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:VertexNormalsHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:VertexNormalsHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:VertexNormalsHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:VertexNormalsHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:VertexNormalsHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Line] &rarr; [page:LineSegments] &rarr;

		<h3 id="VertexTangentsHelper">VertexTangentsHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VertexTangentsHelper VertexTangentsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]? ) <br />
			[constructor:VertexTangentsHelper VertexTangentsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:VertexTangentsHelper VertexTangentsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:VertexTangentsHelper VertexTangentsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:VertexTangentsHelper VertexTangentsHelper](  [param:Object3D object],  [param:number size]?,  [param:number hex]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:Object3D object] -  The object.<br />
			[property:number size] -  The size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:VertexTangentsHelper add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:VertexTangentsHelper applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:VertexTangentsHelper attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:VertexTangentsHelper clear](  ) - Removes all child objects.<br />
			[method:VertexTangentsHelper clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:VertexTangentsHelper computeLineDistances](  ) - Computes an array of distance values which are necessary for [page:LineDashedMaterial LineDashedMaterial]. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.<br />
			[method:VertexTangentsHelper copy](  [param:VertexTangentsHelper source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted [page:Ray Ray] and this Line.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method.<br />
			[method:VertexTangentsHelper remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:VertexTangentsHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:VertexTangentsHelper rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:VertexTangentsHelper rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:VertexTangentsHelper rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:VertexTangentsHelper rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:VertexTangentsHelper rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:VertexTangentsHelper translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:VertexTangentsHelper translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:VertexTangentsHelper translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:VertexTangentsHelper translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the *.morphTargetInfluences* and *.morphTargetDictionary* properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VerticalBlurShader">VerticalBlurShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VerticalTiltShiftShader">VerticalTiltShiftShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Texture] &rarr;

		<h3 id="VideoTexture">VideoTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VideoTexture VideoTexture](  [param:HTMLVideoElement video],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]? ) <br />
			[constructor:VideoTexture VideoTexture](  [param:HTMLVideoElement video],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:VideoTexture VideoTexture](  [param:HTMLVideoElement video],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any DEFAULT_IMAGE] -  The d e f a u l t_ i m a g e.<br />
			[property:any DEFAULT_MAPPING] -  The d e f a u l t_ m a p p i n g.<br />
			[property:number anisotropy] -  The anisotropy.<br />
			[property:Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:any isVideoTexture] -  The is video texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:VideoTexture clone](  ) <br />
			[method:VideoTexture copy](  [param:Texture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:Vector2 transformUv](  [param:Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VignetteShader">VignetteShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Volume">Volume <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Volume Volume](  [param:number xLength]?,  [param:number yLength]?,  [param:number zLength]?,  [param:string type]?,  [param:ArrayLike arrayBuffer]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any axisOrder] -  The axis order.<br />
			[property:ArrayLike data] -  The data.<br />
			[property:number lowerThreshold] -  The lower threshold.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:number[] offset] -  The offset.<br />
			[property:VolumeSlice[] sliceList] -  The slice list.<br />
			[property:number[] spacing] -  The spacing.<br />
			[property:number upperThreshold] -  The upper threshold.<br />
			[property:number xLength] -  The x length.<br />
			[property:number yLength] -  The y length.<br />
			[property:number zLength] -  The z length.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number access](  [param:number i],  [param:number j],  [param:number k] ) <br />
			[method:number[] computeMinMax](  ) <br />
			[method:object extractPerpendicularPlane](  [param:string axis],  [param:number RASIndex] ) <br />
			[method:VolumeSlice extractSlice](  [param:string axis],  [param:number index] ) <br />
			[method:number getData](  [param:number i],  [param:number j],  [param:number k] ) <br />
			[method:Volume map](  [param:any functionToMap],  [param:Volume context] ) <br />
			[method:Volume repaintAllSlices](  ) <br />
			[method:number[] reverseAccess](  [param:number index] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VolumeRenderShader1">VolumeRenderShader1 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="VolumeSlice">VolumeSlice <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:VolumeSlice VolumeSlice](  [param:Volume volume],  [param:number index]?,  [param:string axis]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string axis] -  The axis.<br />
			[property:HTMLCanvasElement canvas] -  The canvas.<br />
			[property:HTMLCanvasElement canvasBuffer] -  The canvas buffer.<br />
			[property:CanvasRenderingContext2D ctx] -  The ctx.<br />
			[property:CanvasRenderingContext2D ctxBuffer] -  The ctx buffer.<br />
			[property:boolean geometryNeedsUpdate] -  The geometry needs update.<br />
			[property:number iLength] -  The i length.<br />
			[property:number index] -  The index.<br />
			[property:number jLength] -  The j length.<br />
			[property:Matrix3 matrix] -  The matrix.<br />
			[property:Mesh mesh] -  The mesh.<br />
			[property:number sliceAccess] -  The slice access.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void repaint](  ) <br />
			[method:void updateGeometry](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WEBGL">WEBGL <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:HTMLElement getErrorMessage](  [param:number version] ) <br />
			[method:HTMLElement getWebGL2ErrorMessage](  ) <br />
			[method:HTMLElement getWebGLErrorMessage](  ) <br />
			[method:boolean isWebGL2Available](  ) <br />
			[method:boolean isWebGLAvailable](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="Water">Water <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Water Water](  [param:BufferGeometry geometry],  [param:WaterOptions options] ) <br />
			[constructor:Water Water](  [param:BufferGeometry geometry],  [param:WaterOptions options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:Water Water](  [param:BufferGeometry geometry],  [param:WaterOptions options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:Water Water](  [param:BufferGeometry geometry],  [param:WaterOptions options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:ShaderMaterial material] - An instance of material derived from the [page:Material Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial MeshBasicMaterial].
		</p>
		<h4>Methods</h4>
		<p>
			[method:Water add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Water applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Water attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Water clear](  ) - Removes all child objects.<br />
			[method:Water clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Water copy](  [param:Water source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:Water remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Water removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Water rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Water rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Water rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Water rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Water rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Water translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Water translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Water translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Water translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="Water2">Water2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Water2 Water2](  [param:BufferGeometry geometry],  [param:Water2Options options] ) <br />
			[constructor:Water2 Water2](  [param:BufferGeometry geometry],  [param:Water2Options options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:Water2 Water2](  [param:BufferGeometry geometry],  [param:Water2Options options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:Water2 Water2](  [param:BufferGeometry geometry],  [param:Water2Options options],  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:ShaderMaterial material] - An instance of material derived from the [page:Material Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial MeshBasicMaterial].
		</p>
		<h4>Methods</h4>
		<p>
			[method:Water2 add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Water2 applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Water2 attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Water2 clear](  ) - Removes all child objects.<br />
			[method:Water2 clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Water2 copy](  [param:Water2 source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:Water2 remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Water2 removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Water2 rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Water2 rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Water2 rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Water2 rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Water2 rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Water2 translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Water2 translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Water2 translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Water2 translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Water2Options">Water2Options <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number clipBias]? -  The clip bias.<br />
			[property:ColorRepresentation color]? -  The color.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:Vector2 flowDirection]? -  The flow direction.<br />
			[property:Texture flowMap]? -  The flow map.<br />
			[property:number flowSpeed]? -  The flow speed.<br />
			[property:Texture normalMap0]? -  The normal map0.<br />
			[property:Texture normalMap1]? -  The normal map1.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number scale]? -  The scale.<br />
			[property:object shader]? -  The shader.<br />
			[property:number textureHeight]? -  The texture height.<br />
			[property:number textureWidth]? -  The texture width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WaterOptions">WaterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alpha]? -  The alpha.<br />
			[property:number clipBias]? -  The clip bias.<br />
			[property:number distortionScale]? -  The distortion scale.<br />
			[property:Vector3 eye]? -  The eye.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:Side side]? -  The side.<br />
			[property:ColorRepresentation sunColor]? -  The sun color.<br />
			[property:Vector3 sunDirection]? -  The sun direction.<br />
			[property:number textureHeight]? -  The texture height.<br />
			[property:number textureWidth]? -  The texture width.<br />
			[property:number time]? -  The time.<br />
			[property:ColorRepresentation waterColor]? -  The water color.<br />
			[property:Texture waterNormals]? -  The water normals.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WaterRefractionShader">WaterRefractionShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Renderer] &rarr; [page:WebGLRenderer] &rarr;

		<h3 id="WebGL1Renderer">WebGL1Renderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGL1Renderer WebGL1Renderer](  [param:WebGLRendererParameters parameters]? ) - parameters is an optional object with properties defining the renderer's behaviour.<br />
			The constructor also accepts no parameters at all.<br />
			In all cases, it will assume sane defaults when parameters are missing.<br />
			[constructor:WebGL1Renderer WebGL1Renderer](  [param:WebGLRendererParameters parameters]?,  [param:WebGLRendererParameters parameters]? ) - parameters is an optional object with properties defining the renderer's behaviour.<br />
			The constructor also accepts no parameters at all.<br />
			In all cases, it will assume sane defaults when parameters are missing.<br />
			[constructor:WebGL1Renderer WebGL1Renderer](  [param:WebGLRendererParameters parameters]?,  [param:WebGLRendererParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoClear] - Defines whether the renderer should automatically clear its output before rendering.<br />
			[property:boolean autoClearColor] - If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.<br />
			[property:boolean autoClearDepth] - If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.<br />
			[property:boolean autoClearStencil] - If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.<br />
			[property:WebGLCapabilities capabilities] -  The capabilities.<br />
			[property:any[] clippingPlanes] -  The clipping planes.<br />
			[property:WebGLRenderingContext context] - The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw.<br />
			[property:WebGLDebug debug] - Debug configurations.<br />
			[property:HTMLCanvasElement domElement] - A Canvas where the renderer draws its output.<br />
			This is automatically created by the renderer in the constructor (if not provided already) : this; you just need to add it to your page.<br />
			[property:WebGLExtensions extensions] -  The extensions.<br />
			[property:number gammaFactor] - deprecated -<br />
			[property:WebGLInfo info] -  The info.<br />
			[property:any isWebGL1Renderer] -  The is web g l1 renderer.<br />
			[property:boolean localClippingEnabled] -  The local clipping enabled.<br />
			[property:TextureEncoding outputEncoding] - Default is LinearEncoding.<br />
			[property:boolean physicallyCorrectLights] -  The physically correct lights.<br />
			[property:number pixelRatio] -  The pixel ratio.<br />
			[property:WebGLProperties properties] -  The properties.<br />
			[property:WebGLRenderLists renderLists] -  The render lists.<br />
			[property:WebGLShadowMap shadowMap] -  The shadow map.<br />
			[property:CullFace shadowMapCullFace] - deprecated - Use {@link WebGLShadowMap#cullFace .shadowMap.cullFace} instead.<br />
			[property:boolean shadowMapEnabled] - deprecated - Use {@link WebGLShadowMap#enabled .shadowMap.enabled} instead.<br />
			[property:ShadowMapType shadowMapType] - deprecated - Use {@link WebGLShadowMap#type .shadowMap.type} instead.<br />
			[property:boolean sortObjects] - Defines whether the renderer should sort objects. Default is true.<br />
			[property:WebGLState state] -  The state.<br />
			[property:ToneMapping toneMapping] -  The tone mapping.<br />
			[property:number toneMappingExposure] -  The tone mapping exposure.<br />
			[property:boolean vr] - deprecated - Use {@link WebGLRenderer#xr .xr} instead.<br />
			[property:WebXRManager xr] -  The xr.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void animate](  [param:any callback] ) - deprecated - Use {@link WebGLRenderer#setAnimationLoop .setAnimationLoop()} instead.<br />
			[method:void clear](  [param:boolean color]?,  [param:boolean depth]?,  [param:boolean stencil]? ) - Tells the renderer to clear its color, depth or stencil drawing buffer(s).<br />
			Arguments default to true<br />
			[method:void clearColor](  ) <br />
			[method:void clearDepth](  ) <br />
			[method:void clearStencil](  ) <br />
			[method:void clearTarget](  [param:WebGLRenderTarget renderTarget],  [param:boolean color],  [param:boolean depth],  [param:boolean stencil] ) <br />
			[method:void compile](  [param:Object3D scene],  [param:Camera camera] ) - Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering.<br />
			[method:void copyFramebufferToTexture](  [param:Vector2 position],  [param:Texture texture],  [param:number level]? ) - Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.<br />
			This region is defined by the size of the destination texture's mip level, offset by the input position.<br />
			[method:void copyTextureToTexture](  [param:Vector2 position],  [param:Texture srcTexture],  [param:Texture dstTexture],  [param:number level]? ) - Copies srcTexture to the specified level of dstTexture, offset by the input position.<br />
			[method:void copyTextureToTexture3D](  [param:Box3 sourceBox],  [param:Vector3 position],  [param:Texture srcTexture],  [param:DataTexture2DArray|DataTexture3D dstTexture],  [param:number level]? ) - Copies the pixels of a texture in the bounds sourceBox in the desination texture starting from the given position.<br />
			[method:void dispose](  ) <br />
			[method:any enableScissorTest](  [param:any boolean] ) - deprecated - Use {@link WebGLRenderer#setScissorTest .setScissorTest()} instead.<br />
			[method:void forceContextLoss](  ) <br />
			[method:void forceContextRestore](  ) <br />
			[method:number getActiveCubeFace](  ) - Returns the current active cube face.<br />
			[method:number getActiveMipmapLevel](  ) - Returns the current active mipmap level.<br />
			[method:number getClearAlpha](  ) - Returns a float with the current clear alpha. Ranges from 0 to 1.<br />
			[method:Color getClearColor](  [param:Color target] ) - Returns a THREE.Color instance with the current clear color.<br />
			[method:WebGLRenderingContext getContext](  ) - Return the WebGL context.<br />
			[method:any getContextAttributes](  ) <br />
			[method:WebGLRenderTarget getCurrentRenderTarget](  ) - deprecated - Use {@link WebGLRenderer#getRenderTarget .getRenderTarget()} instead.<br />
			[method:Vector4 getCurrentViewport](  [param:Vector4 target] ) <br />
			[method:Vector2 getDrawingBufferSize](  [param:Vector2 target] ) <br />
			[method:number getMaxAnisotropy](  ) - deprecated - Use {@link WebGLCapabilities#getMaxAnisotropy .capabilities.getMaxAnisotropy()} instead.<br />
			[method:number getPixelRatio](  ) <br />
			[method:string getPrecision](  ) - deprecated - Use {@link WebGLCapabilities#precision .capabilities.precision} instead.<br />
			[method:WebGLRenderTarget getRenderTarget](  ) - Returns the current render target. If no render target is set, null is returned.<br />
			[method:Vector4 getScissor](  [param:Vector4 target] ) - Copies the scissor area into target.<br />
			[method:boolean getScissorTest](  ) - Returns true if scissor test is enabled; returns false otherwise.<br />
			[method:Vector2 getSize](  [param:Vector2 target] ) <br />
			[method:Vector4 getViewport](  [param:Vector4 target] ) - Copies the viewport into target.<br />
			[method:void initTexture](  [param:Texture texture] ) - Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).<br />
			[method:void readRenderTargetPixels](  [param:WebGLRenderTarget|WebGLMultipleRenderTargets renderTarget],  [param:number x],  [param:number y],  [param:number width],  [param:number height],  [param:any buffer],  [param:number activeCubeFaceIndex]? ) <br />
			[method:void render](  [param:Object3D scene],  [param:Camera camera] ) - Render a scene or an object using a camera.<br />
			The render is done to a previously specified {@link WebGLRenderTarget#renderTarget .renderTarget} set by calling<br />
			{@link WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.<br />
			By default render buffers are cleared before rendering but you can prevent this by setting the property<br />
			{@link WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared<br />
			you can set either the {@link WebGLRenderer#autoClearColor autoClearColor},<br />
			{@link WebGLRenderer#autoClearStencil autoClearStencil} or {@link WebGLRenderer#autoClearDepth autoClearDepth}<br />
			properties to false. To forcibly clear one ore more buffers call {@link WebGLRenderer#clear .clear}.<br />
			[method:void renderBufferDirect](  [param:Camera camera],  [param:Scene scene],  [param:BufferGeometry geometry],  [param:Material material],  [param:Object3D object],  [param:any geometryGroup] ) <br />
			[method:void resetGLState](  ) - deprecated - Use {@link WebGLState#reset .state.reset()} instead.<br />
			[method:void resetState](  ) - Can be used to reset the internal WebGL state.<br />
			[method:void setAnimationLoop](  [param:XRAnimationLoopCallback callback] ) - A build in that can be used instead of requestAnimationFrame. For WebXR projects this must be used.<br />
			[method:void setClearAlpha](  [param:number alpha] ) <br />
			[method:void setClearColor](  [param:ColorRepresentation color],  [param:number alpha]? ) - Sets the clear color, using color for the color and alpha for the opacity.<br />
			[method:void setDrawingBufferSize](  [param:number width],  [param:number height],  [param:number pixelRatio] ) <br />
			[method:void setOpaqueSort](  [param:any method] ) - Sets the custom opaque sort for the WebGLRenderLists. Pass null to use the default painterSortStable function.<br />
			[method:void setPixelRatio](  [param:number value] ) <br />
			[method:void setRenderTarget](  [param:WebGLRenderTarget|WebGLMultipleRenderTargets renderTarget],  [param:number activeCubeFace]?,  [param:number activeMipmapLevel]? ) - Sets the active render target.<br />
			[method:void setScissor](  [param:number|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) - Sets the scissor area from (x, y) to (x + width, y + height).<br />
			[method:void setScissorTest](  [param:boolean enable] ) - Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:boolean updateStyle]? ) - Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).<br />
			[method:void setTransparentSort](  [param:any method] ) - Sets the custom transparent sort for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.<br />
			[method:void setViewport](  [param:number|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) - Sets the viewport to render from (x, y) to (x + width, y + height).<br />
			(x, y) is the lower-left corner of the region.<br />
			[method:any supportsBlendMinMax](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'EXT_blend_minmax' )} instead.<br />
			[method:any supportsCompressedTexturePVRTC](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_pvrtc' )} instead.<br />
			[method:any supportsCompressedTextureS3TC](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_s3tc' )} instead.<br />
			[method:any supportsFloatTextures](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_float' )} instead.<br />
			[method:any supportsHalfFloatTextures](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_half_float' )} instead.<br />
			[method:any supportsInstancedArrays](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'ANGLE_instanced_arrays' )} instead.<br />
			[method:any supportsStandardDerivatives](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'OES_standard_derivatives' )} instead.<br />
			[method:any supportsVertexTextures](  ) - deprecated - Use {@link WebGLCapabilities#vertexTextures .capabilities.vertexTextures} instead.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLAttributes">WebGLAttributes <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLAttributes WebGLAttributes](  [param:WebGLRenderingContext|WebGL2RenderingContext gl],  [param:WebGLCapabilities capabilities] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void get](  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) <br />
			[method:void remove](  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) <br />
			[method:void update](  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:number bufferType] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLBindingStates">WebGLBindingStates <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLBindingStates WebGLBindingStates](  [param:WebGLRenderingContext gl],  [param:WebGLExtensions extensions],  [param:WebGLAttributes attributes],  [param:WebGLCapabilities capabilities] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void disableUnusedAttributes](  ) <br />
			[method:void dispose](  ) <br />
			[method:void enableAttribute](  [param:number attribute] ) <br />
			[method:void initAttributes](  ) <br />
			[method:void releaseStatesOfGeometry](  ) <br />
			[method:void releaseStatesOfProgram](  ) <br />
			[method:void reset](  ) <br />
			[method:void resetDefaultState](  ) <br />
			[method:void setup](  [param:Object3D object],  [param:Material material],  [param:WebGLProgram program],  [param:BufferGeometry geometry],  [param:BufferAttribute index] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLBufferRenderer">WebGLBufferRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLBufferRenderer WebGLBufferRenderer](  [param:WebGLRenderingContext gl],  [param:WebGLExtensions extensions],  [param:WebGLInfo info],  [param:WebGLCapabilities capabilities] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:any start],  [param:number count] ) <br />
			[method:void renderInstances](  [param:any start],  [param:number count],  [param:number primcount] ) <br />
			[method:void setMode](  [param:any value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLCapabilities">WebGLCapabilities <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLCapabilities WebGLCapabilities](  [param:WebGLRenderingContext gl],  [param:any extensions],  [param:WebGLCapabilitiesParameters parameters] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean floatFragmentTextures] -  The float fragment textures.<br />
			[property:boolean floatVertexTextures] -  The float vertex textures.<br />
			[property:boolean isWebGL2] -  The is web g l2.<br />
			[property:boolean logarithmicDepthBuffer] -  The logarithmic depth buffer.<br />
			[property:number maxAttributes] -  The max attributes.<br />
			[property:number maxCubemapSize] -  The max cubemap size.<br />
			[property:number maxFragmentUniforms] -  The max fragment uniforms.<br />
			[property:number maxTextureSize] -  The max texture size.<br />
			[property:number maxTextures] -  The max textures.<br />
			[property:number maxVaryings] -  The max varyings.<br />
			[property:number maxVertexTextures] -  The max vertex textures.<br />
			[property:number maxVertexUniforms] -  The max vertex uniforms.<br />
			[property:string precision] -  The precision.<br />
			[property:boolean vertexTextures] -  The vertex textures.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number getMaxAnisotropy](  ) <br />
			[method:string getMaxPrecision](  [param:string precision] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLCapabilitiesParameters">WebGLCapabilitiesParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean logarithmicDepthBuffer]? -  The logarithmic depth buffer.<br />
			[property:string precision]? -  The precision.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLClipping">WebGLClipping <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLClipping WebGLClipping](  [param:WebGLProperties properties] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number numIntersection] -  The num intersection.<br />
			[property:number numPlanes] -  The num planes.<br />
			[property:any uniform] -  The uniform.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void beginShadows](  ) <br />
			[method:void endShadows](  ) <br />
			[method:boolean init](  [param:any[] planes],  [param:boolean enableLocalClipping],  [param:Camera camera] ) <br />
			[method:void setState](  [param:Material material],  [param:Camera camera],  [param:boolean useCache] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLColorBuffer">WebGLColorBuffer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLColorBuffer WebGLColorBuffer](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void reset](  ) <br />
			[method:void setClear](  [param:number r],  [param:number g],  [param:number b],  [param:number a],  [param:boolean premultipliedAlpha] ) <br />
			[method:void setLocked](  [param:boolean lock] ) <br />
			[method:void setMask](  [param:boolean colorMask] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLCubeMaps">WebGLCubeMaps <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLCubeMaps WebGLCubeMaps](  [param:WebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:any get](  [param:any texture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:WebGLRenderTarget] &rarr;

		<h3 id="WebGLCubeRenderTarget">WebGLCubeRenderTarget <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLCubeRenderTarget WebGLCubeRenderTarget](  [param:number size],  [param:WebGLRenderTargetOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:WebGLCubeRenderTarget WebGLCubeRenderTarget](  [param:number size],  [param:WebGLRenderTargetOptions options]?,  [param:number width],  [param:number height],  [param:WebGLRenderTargetOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:WebGLCubeRenderTarget WebGLCubeRenderTarget](  [param:number size],  [param:WebGLRenderTargetOptions options]?,  [param:number width],  [param:number height],  [param:WebGLRenderTargetOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any anisotropy] - deprecated - Use {@link Texture#anisotropy texture.anisotropy} instead.<br />
			[property:number depth] -  The depth.<br />
			[property:boolean depthBuffer] -  The depth buffer.<br />
			[property:DepthTexture depthTexture] -  The depth texture.<br />
			[property:any format] - deprecated - Use {@link Texture#format texture.format} instead.<br />
			[property:any generateMipmaps] - deprecated - Use {@link Texture#generateMipmaps texture.generateMipmaps} instead.<br />
			[property:number height] -  The height.<br />
			[property:any isWebGLRenderTarget] -  The is web g l render target.<br />
			[property:any magFilter] - deprecated - Use {@link Texture#magFilter texture.magFilter} instead.<br />
			[property:any minFilter] - deprecated - Use {@link Texture#minFilter texture.minFilter} instead.<br />
			[property:any offset] - deprecated - Use {@link Texture#offset texture.offset} instead.<br />
			[property:any repeat] - deprecated - Use {@link Texture#repeat texture.repeat} instead.<br />
			[property:Vector4 scissor] -  The scissor.<br />
			[property:boolean scissorTest] -  The scissor test.<br />
			[property:boolean stencilBuffer] -  The stencil buffer.<br />
			[property:CubeTexture texture] -  The texture.<br />
			[property:any type] - deprecated - Use {@link Texture#type texture.type} instead.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Vector4 viewport] -  The viewport.<br />
			[property:number width] -  The width.<br />
			[property:any wrapS] - deprecated - Use {@link Texture#wrapS texture.wrapS} instead.<br />
			[property:any wrapT] - deprecated - Use {@link Texture#wrapT texture.wrapT} instead.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void clear](  [param:WebGLRenderer renderer],  [param:boolean color],  [param:boolean depth],  [param:boolean stencil] ) <br />
			[method:WebGLCubeRenderTarget clone](  ) <br />
			[method:WebGLCubeRenderTarget copy](  [param:WebGLRenderTarget source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:WebGLCubeRenderTarget fromEquirectangularTexture](  [param:WebGLRenderer renderer],  [param:Texture texture] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:number depth]? ) <br />
			[method:void setTexture](  [param:Texture texture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLCubeUVMaps">WebGLCubeUVMaps <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLCubeUVMaps WebGLCubeUVMaps](  [param:WebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void get](  [param:T texture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLDebug">WebGLDebug <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean checkShaderErrors] - Enables error checking and reporting when shader programs are being compiled.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLDepthBuffer">WebGLDepthBuffer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLDepthBuffer WebGLDepthBuffer](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void reset](  ) <br />
			[method:void setClear](  [param:number depth] ) <br />
			[method:void setFunc](  [param:DepthModes depthFunc] ) <br />
			[method:void setLocked](  [param:boolean lock] ) <br />
			[method:void setMask](  [param:boolean depthMask] ) <br />
			[method:void setTest](  [param:boolean depthTest] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLExtensions">WebGLExtensions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLExtensions WebGLExtensions](  [param:WebGLRenderingContext gl] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:any get](  [param:string name] ) <br />
			[method:boolean has](  [param:string name] ) <br />
			[method:void init](  [param:WebGLCapabilities capabilities] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLGeometries">WebGLGeometries <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLGeometries WebGLGeometries](  [param:WebGLRenderingContext gl],  [param:WebGLAttributes attributes],  [param:WebGLInfo info] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry get](  [param:Object3D object],  [param:BufferGeometry geometry] ) <br />
			[method:BufferAttribute getWireframeAttribute](  [param:BufferGeometry geometry] ) <br />
			[method:void update](  [param:BufferGeometry geometry] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLIndexedBufferRenderer">WebGLIndexedBufferRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLIndexedBufferRenderer WebGLIndexedBufferRenderer](  [param:WebGLRenderingContext gl],  [param:any extensions],  [param:any info],  [param:any capabilities] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:any start],  [param:number count] ) <br />
			[method:void renderInstances](  [param:any start],  [param:number count],  [param:number primcount] ) <br />
			[method:void setIndex](  [param:any index] ) <br />
			[method:void setMode](  [param:any value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLInfo">WebGLInfo <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLInfo WebGLInfo](  [param:WebGLRenderingContext gl] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoReset] -  The auto reset.<br />
			[property:any memory] -  The memory.<br />
			[property:WebGLProgram[] programs] -  The programs.<br />
			[property:any render] -  The render.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void reset](  ) <br />
			[method:void update](  [param:number count],  [param:number mode],  [param:number instanceCount] ) 
		</p>

		<p class="desc">
			An object with a series of statistical information about the graphics board memory and the rendering process.
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLLights">WebGLLights <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLLights WebGLLights](  [param:WebGLExtensions extensions],  [param:WebGLCapabilities capabilities] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any state] -  The state.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any get](  [param:any light] ) <br />
			[method:void setup](  [param:any lights] ) <br />
			[method:void setupView](  [param:any lights],  [param:any camera] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="WebGLMultipleRenderTargets">WebGLMultipleRenderTargets <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLMultipleRenderTargets WebGLMultipleRenderTargets](  [param:number width],  [param:number height],  [param:number count] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:WebGLMultipleRenderTargets WebGLMultipleRenderTargets](  [param:number width],  [param:number height],  [param:number count] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isWebGLMultipleRenderTargets] -  The is web g l multiple render targets.<br />
			[property:Texture[] texture] -  The texture.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:WebGLMultipleRenderTargets clone](  ) <br />
			[method:WebGLMultipleRenderTargets copy](  [param:WebGLMultipleRenderTargets source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:WebGLMultipleRenderTargets setSize](  [param:number width],  [param:number height],  [param:number depth]? ) <br />
			[method:void setTexture](  [param:Texture texture] ) 
		</p>

		<p class="desc">
			This class originall extended WebGLMultipleRenderTarget<br />
			However, there are some issues with this method as documented below
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:WebGLRenderTarget] &rarr;

		<h3 id="WebGLMultisampleRenderTarget">WebGLMultisampleRenderTarget <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLMultisampleRenderTarget WebGLMultisampleRenderTarget](  [param:number width],  [param:number height],  [param:WebGLRenderTargetOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:WebGLMultisampleRenderTarget WebGLMultisampleRenderTarget](  [param:number width],  [param:number height],  [param:WebGLRenderTargetOptions options]?,  [param:number width],  [param:number height],  [param:WebGLRenderTargetOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:WebGLMultisampleRenderTarget WebGLMultisampleRenderTarget](  [param:number width],  [param:number height],  [param:WebGLRenderTargetOptions options]?,  [param:number width],  [param:number height],  [param:WebGLRenderTargetOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any anisotropy] - deprecated - Use {@link Texture#anisotropy texture.anisotropy} instead.<br />
			[property:number depth] -  The depth.<br />
			[property:boolean depthBuffer] -  The depth buffer.<br />
			[property:DepthTexture depthTexture] -  The depth texture.<br />
			[property:any format] - deprecated - Use {@link Texture#format texture.format} instead.<br />
			[property:any generateMipmaps] - deprecated - Use {@link Texture#generateMipmaps texture.generateMipmaps} instead.<br />
			[property:number height] -  The height.<br />
			[property:any isWebGLMultisampleRenderTarget] -  The is web g l multisample render target.<br />
			[property:any isWebGLRenderTarget] -  The is web g l render target.<br />
			[property:any magFilter] - deprecated - Use {@link Texture#magFilter texture.magFilter} instead.<br />
			[property:any minFilter] - deprecated - Use {@link Texture#minFilter texture.minFilter} instead.<br />
			[property:any offset] - deprecated - Use {@link Texture#offset texture.offset} instead.<br />
			[property:any repeat] - deprecated - Use {@link Texture#repeat texture.repeat} instead.<br />
			[property:number samples] - Specifies the number of samples to be used for the renderbuffer storage.However, the maximum supported size for multisampling is platform dependent and defined via gl.MAX_SAMPLES.<br />
			[property:Vector4 scissor] -  The scissor.<br />
			[property:boolean scissorTest] -  The scissor test.<br />
			[property:boolean stencilBuffer] -  The stencil buffer.<br />
			[property:CubeTexture|Texture texture] -  The texture.<br />
			[property:any type] - deprecated - Use {@link Texture#type texture.type} instead.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Vector4 viewport] -  The viewport.<br />
			[property:number width] -  The width.<br />
			[property:any wrapS] - deprecated - Use {@link Texture#wrapS texture.wrapS} instead.<br />
			[property:any wrapT] - deprecated - Use {@link Texture#wrapT texture.wrapT} instead.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:WebGLMultisampleRenderTarget clone](  ) <br />
			[method:WebGLMultisampleRenderTarget copy](  [param:WebGLRenderTarget source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:number depth]? ) <br />
			[method:void setTexture](  [param:Texture texture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLObjects">WebGLObjects <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLObjects WebGLObjects](  [param:WebGLRenderingContext gl],  [param:any geometries],  [param:any attributes],  [param:any info] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:any update](  [param:any object] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLProgram">WebGLProgram <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLProgram WebGLProgram](  [param:WebGLRenderer renderer],  [param:string cacheKey],  [param:object parameters] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] - deprecated - Use {@link WebGLProgram#getAttributes getAttributes()} instead.<br />
			[property:string cacheKey] -  The cache key.<br />
			[property:WebGLShader fragmentShader] -  The fragment shader.<br />
			[property:number id] -  The id.<br />
			[property:string name] -  The name.<br />
			[property:any program] -  The program.<br />
			[property:any uniforms] - deprecated - Use {@link WebGLProgram#getUniforms getUniforms()} instead.<br />
			[property:number usedTimes] -  The used times.<br />
			[property:WebGLShader vertexShader] -  The vertex shader.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void destroy](  ) <br />
			[method:any getAttributes](  ) <br />
			[method:WebGLUniforms getUniforms](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLPrograms">WebGLPrograms <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLPrograms WebGLPrograms](  [param:WebGLRenderer renderer],  [param:WebGLCubeMaps cubemaps],  [param:WebGLExtensions extensions],  [param:WebGLCapabilities capabilities],  [param:WebGLBindingStates bindingStates],  [param:WebGLClipping clipping] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:WebGLProgram[] programs] -  The programs.
		</p>
		<h4>Methods</h4>
		<p>
			[method:WebGLProgram acquireProgram](  [param:any parameters],  [param:string cacheKey] ) <br />
			[method:any getParameters](  [param:Material material],  [param:any lights],  [param:object[] shadows],  [param:Scene scene],  [param:any object] ) <br />
			[method:string getProgramCacheKey](  [param:any parameters] ) <br />
			[method:object getUniforms](  [param:Material material] ) <br />
			[method:void releaseProgram](  [param:WebGLProgram program] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLProperties">WebGLProperties <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLProperties WebGLProperties](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:any get](  [param:any object] ) <br />
			[method:void remove](  [param:any object] ) <br />
			[method:any update](  [param:any object],  [param:any key],  [param:any value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLRenderList">WebGLRenderList <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLRenderList WebGLRenderList](  [param:WebGLProperties properties] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:RenderItem[] opaque] -  The opaque.<br />
			[property:RenderItem[] transmissive] -  The transmissive.<br />
			[property:RenderItem[] transparent] -  The transparent.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void finish](  ) <br />
			[method:void init](  ) <br />
			[method:void push](  [param:Object3D object],  [param:BufferGeometry geometry],  [param:Material material],  [param:number groupOrder],  [param:number z],  [param:Group group] ) <br />
			[method:void sort](  [param:any opaqueSort],  [param:any transparentSort] ) <br />
			[method:void unshift](  [param:Object3D object],  [param:BufferGeometry geometry],  [param:Material material],  [param:number groupOrder],  [param:number z],  [param:Group group] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLRenderLists">WebGLRenderLists <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLRenderLists WebGLRenderLists](  [param:WebGLProperties properties] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:WebGLRenderList get](  [param:Scene scene],  [param:number renderCallDepth] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="WebGLRenderTarget">WebGLRenderTarget <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLRenderTarget WebGLRenderTarget](  [param:number width],  [param:number height],  [param:WebGLRenderTargetOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:WebGLRenderTarget WebGLRenderTarget](  [param:number width],  [param:number height],  [param:WebGLRenderTargetOptions options]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any anisotropy] - deprecated - Use {@link Texture#anisotropy texture.anisotropy} instead.<br />
			[property:number depth] -  The depth.<br />
			[property:boolean depthBuffer] -  The depth buffer.<br />
			[property:DepthTexture depthTexture] -  The depth texture.<br />
			[property:any format] - deprecated - Use {@link Texture#format texture.format} instead.<br />
			[property:any generateMipmaps] - deprecated - Use {@link Texture#generateMipmaps texture.generateMipmaps} instead.<br />
			[property:number height] -  The height.<br />
			[property:any isWebGLRenderTarget] -  The is web g l render target.<br />
			[property:any magFilter] - deprecated - Use {@link Texture#magFilter texture.magFilter} instead.<br />
			[property:any minFilter] - deprecated - Use {@link Texture#minFilter texture.minFilter} instead.<br />
			[property:any offset] - deprecated - Use {@link Texture#offset texture.offset} instead.<br />
			[property:any repeat] - deprecated - Use {@link Texture#repeat texture.repeat} instead.<br />
			[property:Vector4 scissor] -  The scissor.<br />
			[property:boolean scissorTest] -  The scissor test.<br />
			[property:boolean stencilBuffer] -  The stencil buffer.<br />
			[property:CubeTexture|Texture texture] -  The texture.<br />
			[property:any type] - deprecated - Use {@link Texture#type texture.type} instead.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Vector4 viewport] -  The viewport.<br />
			[property:number width] -  The width.<br />
			[property:any wrapS] - deprecated - Use {@link Texture#wrapS texture.wrapS} instead.<br />
			[property:any wrapT] - deprecated - Use {@link Texture#wrapT texture.wrapT} instead.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:WebGLRenderTarget clone](  ) <br />
			[method:WebGLRenderTarget copy](  [param:WebGLRenderTarget source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:number depth]? ) <br />
			[method:void setTexture](  [param:Texture texture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLRenderTargetOptions">WebGLRenderTargetOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy]? -  The anisotropy.<br />
			[property:boolean depthBuffer]? -  The depth buffer.<br />
			[property:DepthTexture depthTexture]? -  The depth texture.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:number format]? -  The format.<br />
			[property:boolean generateMipmaps]? -  The generate mipmaps.<br />
			[property:TextureFilter magFilter]? -  The mag filter.<br />
			[property:TextureFilter minFilter]? -  The min filter.<br />
			[property:boolean stencilBuffer]? -  The stencil buffer.<br />
			[property:TextureDataType type]? -  The type.<br />
			[property:Wrapping wrapS]? -  The wrap s.<br />
			[property:Wrapping wrapT]? -  The wrap t.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Renderer] &rarr;

		<h3 id="WebGLRenderer">WebGLRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLRenderer WebGLRenderer](  [param:WebGLRendererParameters parameters]? ) - parameters is an optional object with properties defining the renderer's behaviour.<br />
			The constructor also accepts no parameters at all.<br />
			In all cases, it will assume sane defaults when parameters are missing.<br />
			[constructor:WebGLRenderer WebGLRenderer](  [param:WebGLRendererParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoClear] - Defines whether the renderer should automatically clear its output before rendering.<br />
			[property:boolean autoClearColor] - If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.<br />
			[property:boolean autoClearDepth] - If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.<br />
			[property:boolean autoClearStencil] - If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.<br />
			[property:WebGLCapabilities capabilities] -  The capabilities.<br />
			[property:any[] clippingPlanes] -  The clipping planes.<br />
			[property:WebGLRenderingContext context] - The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw.<br />
			[property:WebGLDebug debug] - Debug configurations.<br />
			[property:HTMLCanvasElement domElement] - A Canvas where the renderer draws its output.<br />
			This is automatically created by the renderer in the constructor (if not provided already) : this; you just need to add it to your page.<br />
			[property:WebGLExtensions extensions] -  The extensions.<br />
			[property:number gammaFactor] - deprecated -<br />
			[property:WebGLInfo info] -  The info.<br />
			[property:boolean localClippingEnabled] -  The local clipping enabled.<br />
			[property:TextureEncoding outputEncoding] - Default is LinearEncoding.<br />
			[property:boolean physicallyCorrectLights] -  The physically correct lights.<br />
			[property:number pixelRatio] -  The pixel ratio.<br />
			[property:WebGLProperties properties] -  The properties.<br />
			[property:WebGLRenderLists renderLists] -  The render lists.<br />
			[property:WebGLShadowMap shadowMap] -  The shadow map.<br />
			[property:CullFace shadowMapCullFace] - deprecated - Use {@link WebGLShadowMap#cullFace .shadowMap.cullFace} instead.<br />
			[property:boolean shadowMapEnabled] - deprecated - Use {@link WebGLShadowMap#enabled .shadowMap.enabled} instead.<br />
			[property:ShadowMapType shadowMapType] - deprecated - Use {@link WebGLShadowMap#type .shadowMap.type} instead.<br />
			[property:boolean sortObjects] - Defines whether the renderer should sort objects. Default is true.<br />
			[property:WebGLState state] -  The state.<br />
			[property:ToneMapping toneMapping] -  The tone mapping.<br />
			[property:number toneMappingExposure] -  The tone mapping exposure.<br />
			[property:boolean vr] - deprecated - Use {@link WebGLRenderer#xr .xr} instead.<br />
			[property:WebXRManager xr] -  The xr.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void animate](  [param:any callback] ) - deprecated - Use {@link WebGLRenderer#setAnimationLoop .setAnimationLoop()} instead.<br />
			[method:void clear](  [param:boolean color]?,  [param:boolean depth]?,  [param:boolean stencil]? ) - Tells the renderer to clear its color, depth or stencil drawing buffer(s).<br />
			Arguments default to true<br />
			[method:void clearColor](  ) <br />
			[method:void clearDepth](  ) <br />
			[method:void clearStencil](  ) <br />
			[method:void clearTarget](  [param:WebGLRenderTarget renderTarget],  [param:boolean color],  [param:boolean depth],  [param:boolean stencil] ) <br />
			[method:void compile](  [param:Object3D scene],  [param:Camera camera] ) - Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering.<br />
			[method:void copyFramebufferToTexture](  [param:Vector2 position],  [param:Texture texture],  [param:number level]? ) - Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.<br />
			This region is defined by the size of the destination texture's mip level, offset by the input position.<br />
			[method:void copyTextureToTexture](  [param:Vector2 position],  [param:Texture srcTexture],  [param:Texture dstTexture],  [param:number level]? ) - Copies srcTexture to the specified level of dstTexture, offset by the input position.<br />
			[method:void copyTextureToTexture3D](  [param:Box3 sourceBox],  [param:Vector3 position],  [param:Texture srcTexture],  [param:DataTexture2DArray|DataTexture3D dstTexture],  [param:number level]? ) - Copies the pixels of a texture in the bounds sourceBox in the desination texture starting from the given position.<br />
			[method:void dispose](  ) <br />
			[method:any enableScissorTest](  [param:any boolean] ) - deprecated - Use {@link WebGLRenderer#setScissorTest .setScissorTest()} instead.<br />
			[method:void forceContextLoss](  ) <br />
			[method:void forceContextRestore](  ) <br />
			[method:number getActiveCubeFace](  ) - Returns the current active cube face.<br />
			[method:number getActiveMipmapLevel](  ) - Returns the current active mipmap level.<br />
			[method:number getClearAlpha](  ) - Returns a float with the current clear alpha. Ranges from 0 to 1.<br />
			[method:Color getClearColor](  [param:Color target] ) - Returns a THREE.Color instance with the current clear color.<br />
			[method:WebGLRenderingContext getContext](  ) - Return the WebGL context.<br />
			[method:any getContextAttributes](  ) <br />
			[method:WebGLRenderTarget getCurrentRenderTarget](  ) - deprecated - Use {@link WebGLRenderer#getRenderTarget .getRenderTarget()} instead.<br />
			[method:Vector4 getCurrentViewport](  [param:Vector4 target] ) <br />
			[method:Vector2 getDrawingBufferSize](  [param:Vector2 target] ) <br />
			[method:number getMaxAnisotropy](  ) - deprecated - Use {@link WebGLCapabilities#getMaxAnisotropy .capabilities.getMaxAnisotropy()} instead.<br />
			[method:number getPixelRatio](  ) <br />
			[method:string getPrecision](  ) - deprecated - Use {@link WebGLCapabilities#precision .capabilities.precision} instead.<br />
			[method:WebGLRenderTarget getRenderTarget](  ) - Returns the current render target. If no render target is set, null is returned.<br />
			[method:Vector4 getScissor](  [param:Vector4 target] ) - Copies the scissor area into target.<br />
			[method:boolean getScissorTest](  ) - Returns true if scissor test is enabled; returns false otherwise.<br />
			[method:Vector2 getSize](  [param:Vector2 target] ) <br />
			[method:Vector4 getViewport](  [param:Vector4 target] ) - Copies the viewport into target.<br />
			[method:void initTexture](  [param:Texture texture] ) - Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).<br />
			[method:void readRenderTargetPixels](  [param:WebGLRenderTarget|WebGLMultipleRenderTargets renderTarget],  [param:number x],  [param:number y],  [param:number width],  [param:number height],  [param:any buffer],  [param:number activeCubeFaceIndex]? ) <br />
			[method:void render](  [param:Object3D scene],  [param:Camera camera] ) - Render a scene or an object using a camera.<br />
			The render is done to a previously specified {@link WebGLRenderTarget#renderTarget .renderTarget} set by calling<br />
			{@link WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.<br />
			By default render buffers are cleared before rendering but you can prevent this by setting the property<br />
			{@link WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared<br />
			you can set either the {@link WebGLRenderer#autoClearColor autoClearColor},<br />
			{@link WebGLRenderer#autoClearStencil autoClearStencil} or {@link WebGLRenderer#autoClearDepth autoClearDepth}<br />
			properties to false. To forcibly clear one ore more buffers call {@link WebGLRenderer#clear .clear}.<br />
			[method:void renderBufferDirect](  [param:Camera camera],  [param:Scene scene],  [param:BufferGeometry geometry],  [param:Material material],  [param:Object3D object],  [param:any geometryGroup] ) <br />
			[method:void resetGLState](  ) - deprecated - Use {@link WebGLState#reset .state.reset()} instead.<br />
			[method:void resetState](  ) - Can be used to reset the internal WebGL state.<br />
			[method:void setAnimationLoop](  [param:XRAnimationLoopCallback callback] ) - A build in that can be used instead of requestAnimationFrame. For WebXR projects this must be used.<br />
			[method:void setClearAlpha](  [param:number alpha] ) <br />
			[method:void setClearColor](  [param:ColorRepresentation color],  [param:number alpha]? ) - Sets the clear color, using color for the color and alpha for the opacity.<br />
			[method:void setDrawingBufferSize](  [param:number width],  [param:number height],  [param:number pixelRatio] ) <br />
			[method:void setOpaqueSort](  [param:any method] ) - Sets the custom opaque sort for the WebGLRenderLists. Pass null to use the default painterSortStable function.<br />
			[method:void setPixelRatio](  [param:number value] ) <br />
			[method:void setRenderTarget](  [param:WebGLRenderTarget|WebGLMultipleRenderTargets renderTarget],  [param:number activeCubeFace]?,  [param:number activeMipmapLevel]? ) - Sets the active render target.<br />
			[method:void setScissor](  [param:number|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) - Sets the scissor area from (x, y) to (x + width, y + height).<br />
			[method:void setScissorTest](  [param:boolean enable] ) - Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:boolean updateStyle]? ) - Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).<br />
			[method:void setTransparentSort](  [param:any method] ) - Sets the custom transparent sort for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.<br />
			[method:void setViewport](  [param:number|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) - Sets the viewport to render from (x, y) to (x + width, y + height).<br />
			(x, y) is the lower-left corner of the region.<br />
			[method:any supportsBlendMinMax](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'EXT_blend_minmax' )} instead.<br />
			[method:any supportsCompressedTexturePVRTC](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_pvrtc' )} instead.<br />
			[method:any supportsCompressedTextureS3TC](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_s3tc' )} instead.<br />
			[method:any supportsFloatTextures](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_float' )} instead.<br />
			[method:any supportsHalfFloatTextures](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_half_float' )} instead.<br />
			[method:any supportsInstancedArrays](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'ANGLE_instanced_arrays' )} instead.<br />
			[method:any supportsStandardDerivatives](  ) - deprecated - Use {@link WebGLExtensions#get .extensions.get( 'OES_standard_derivatives' )} instead.<br />
			[method:any supportsVertexTextures](  ) - deprecated - Use {@link WebGLCapabilities#vertexTextures .capabilities.vertexTextures} instead.
		</p>

		<p class="desc">
			The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.<br />
			This renderer has way better performance than CanvasRenderer.<br />
			see {@link https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js|src/renderers/WebGLRenderer.js}
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLRendererParameters">WebGLRendererParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean alpha]? - default is false.<br />
			[property:boolean antialias]? - default is false.<br />
			[property:HTMLCanvasElement|OffscreenCanvas canvas]? - A Canvas where the renderer draws its output.<br />
			[property:WebGLRenderingContext context]? - A WebGL Rendering Context.<br />
			(https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)<br />
			Default is null<br />
			[property:boolean depth]? - default is true.<br />
			[property:boolean failIfMajorPerformanceCaveat]? - default is false.<br />
			[property:boolean logarithmicDepthBuffer]? - default is false.<br />
			[property:string powerPreference]? - Can be "high-performance", "low-power" or "default"<br />
			[property:string precision]? - shader precision. Can be "highp", "mediump" or "lowp".<br />
			[property:boolean premultipliedAlpha]? - default is true.<br />
			[property:boolean preserveDrawingBuffer]? - default is false.<br />
			[property:boolean stencil]? - default is true.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLRenderingContext">WebGLRenderingContext <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:Promise makeXRCompatible](  ) 
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLShadowMap">WebGLShadowMap <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLShadowMap WebGLShadowMap](  [param:WebGLRenderer _renderer],  [param:WebGLObjects _objects],  [param:WebGLCapabilities _capabilities] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:any cullFace] - deprecated - Use {@link Material#shadowSide} instead.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:ShadowMapType type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:Light[] shadowsArray],  [param:Scene scene],  [param:Camera camera] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLState">WebGLState <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLState WebGLState](  [param:WebGLRenderingContext gl],  [param:WebGLExtensions extensions],  [param:WebGLCapabilities capabilities] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any buffers] -  The buffers.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void activeTexture](  [param:number webglSlot] ) <br />
			[method:void bindFramebuffer](  [param:number target],  [param:WebGLFramebuffer framebuffer] ) <br />
			[method:void bindTexture](  [param:number webglType],  [param:any webglTexture] ) <br />
			[method:void bindXRFramebuffer](  [param:WebGLFramebuffer framebuffer] ) <br />
			[method:void compressedTexImage2D](  [param:number target],  [param:number level],  [param:number internalformat],  [param:number width],  [param:number height],  [param:number border],  [param:ArrayBufferView data] ) <br />
			[method:void disable](  [param:number id] ) <br />
			[method:void disableUnusedAttributes](  ) <br />
			[method:void enable](  [param:number id] ) <br />
			[method:void enableAttribute](  [param:number attribute] ) <br />
			[method:void enableAttributeAndDivisor](  [param:number attribute],  [param:number meshPerAttribute] ) <br />
			[method:void initAttributes](  ) <br />
			[method:void reset](  ) <br />
			[method:void scissor](  [param:Vector4 scissor] ) <br />
			[method:void setBlending](  [param:Blending blending],  [param:BlendingEquation blendEquation]?,  [param:SrcAlphaSaturateFactor blendSrc]?,  [param:BlendingDstFactor blendDst]?,  [param:BlendingEquation blendEquationAlpha]?,  [param:SrcAlphaSaturateFactor blendSrcAlpha]?,  [param:BlendingDstFactor blendDstAlpha]?,  [param:boolean premultiplyAlpha]? ) <br />
			[method:void setCullFace](  [param:CullFace cullFace] ) <br />
			[method:void setFlipSided](  [param:boolean flipSided] ) <br />
			[method:void setLineWidth](  [param:number width] ) <br />
			[method:void setMaterial](  [param:Material material],  [param:boolean frontFaceCW] ) <br />
			[method:void setPolygonOffset](  [param:boolean polygonoffset],  [param:number factor]?,  [param:number units]? ) <br />
			[method:void setScissorTest](  [param:boolean scissorTest] ) <br />
			[method:void texImage2D](  [param:number target],  [param:number level],  [param:number internalformat],  [param:number width],  [param:number height],  [param:number border],  [param:number format],  [param:number type],  [param:ArrayBufferView pixels] ) <br />
			[method:void texImage2D](  [param:number target],  [param:number level],  [param:number internalformat],  [param:number width],  [param:number height],  [param:number border],  [param:number format],  [param:number type],  [param:ArrayBufferView pixels],  [param:number target],  [param:number level],  [param:number internalformat],  [param:number format],  [param:number type],  [param:any source] ) <br />
			[method:void texImage3D](  [param:number target],  [param:number level],  [param:number internalformat],  [param:number width],  [param:number height],  [param:number depth],  [param:number border],  [param:number format],  [param:number type],  [param:any pixels] ) <br />
			[method:void unbindTexture](  ) <br />
			[method:boolean useProgram](  [param:any program] ) <br />
			[method:void vertexAttribPointer](  [param:number index],  [param:number size],  [param:number type],  [param:boolean normalized],  [param:number stride],  [param:number offset] ) <br />
			[method:void viewport](  [param:Vector4 viewport] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLStencilBuffer">WebGLStencilBuffer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLStencilBuffer WebGLStencilBuffer](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void reset](  ) <br />
			[method:void setClear](  [param:number stencil] ) <br />
			[method:void setFunc](  [param:number stencilFunc],  [param:number stencilRef],  [param:number stencilMask] ) <br />
			[method:void setLocked](  [param:boolean lock] ) <br />
			[method:void setMask](  [param:number stencilMask] ) <br />
			[method:void setOp](  [param:number stencilFail],  [param:number stencilZFail],  [param:number stencilZPass] ) <br />
			[method:void setTest](  [param:boolean stencilTest] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLTextures">WebGLTextures <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLTextures WebGLTextures](  [param:WebGLRenderingContext gl],  [param:WebGLExtensions extensions],  [param:WebGLState state],  [param:WebGLProperties properties],  [param:WebGLCapabilities capabilities],  [param:WebGLUtils utils],  [param:WebGLInfo info] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void allocateTextureUnit](  ) <br />
			[method:void resetTextureUnits](  ) <br />
			[method:void safeSetTexture2D](  [param:any texture],  [param:number slot] ) <br />
			[method:void safeSetTextureCube](  [param:any texture],  [param:number slot] ) <br />
			[method:void setTexture2D](  [param:any texture],  [param:number slot] ) <br />
			[method:void setTexture2DArray](  [param:any texture],  [param:number slot] ) <br />
			[method:void setTexture3D](  [param:any texture],  [param:number slot] ) <br />
			[method:void setTextureCube](  [param:any texture],  [param:number slot] ) <br />
			[method:void setupRenderTarget](  [param:any renderTarget] ) <br />
			[method:void updateMultisampleRenderTarget](  [param:any renderTarget] ) <br />
			[method:void updateRenderTargetMipmap](  [param:any renderTarget] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLUniforms">WebGLUniforms <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLUniforms WebGLUniforms](  [param:WebGLRenderingContext gl],  [param:WebGLProgram program] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:any[] seqWithValue](  [param:any seq],  [param:any[] values] ) <br />
			[method:void setOptional](  [param:WebGLRenderingContext gl],  [param:any object],  [param:string name] ) <br />
			[method:void setValue](  [param:WebGLRenderingContext gl],  [param:string name],  [param:any value],  [param:WebGLTextures textures] ) <br />
			[method:void upload](  [param:WebGLRenderingContext gl],  [param:any seq],  [param:any[] values],  [param:WebGLTextures textures] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebGLUtils">WebGLUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebGLUtils WebGLUtils](  [param:WebGLRenderingContext|WebGL2RenderingContext gl],  [param:any extensions],  [param:any capabilities] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void convert](  [param:any p] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="WebXRController">WebXRController <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebXRController WebXRController](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:WebXRController disconnect](  [param:XRInputSource inputSource] ) <br />
			[method:WebXRController dispatchEvent](  [param:any event] ) <br />
			[method:Group getGripSpace](  ) <br />
			[method:Group getTargetRaySpace](  ) <br />
			[method:WebXRController update](  [param:XRInputSource inputSource],  [param:XRFrame frame],  [param:XRReferenceSpace referenceSpace] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr;

		<h3 id="WebXRManager">WebXRManager <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WebXRManager WebXRManager](  [param:any renderer],  [param:WebGLRenderingContext gl] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.<br />
			[constructor:WebXRManager WebXRManager](  [param:any renderer],  [param:WebGLRenderingContext gl] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean isPresenting] -  The is presenting.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:Camera getCamera](  [param:Camera camera] ) <br />
			[method:Group getController](  [param:number index] ) <br />
			[method:Group getControllerGrip](  [param:number index] ) <br />
			[method:number getFoveation](  ) <br />
			[method:Group getHand](  [param:number index] ) <br />
			[method:XRReferenceSpace getReferenceSpace](  ) <br />
			[method:XRSession getSession](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setAnimationLoop](  [param:XRFrameRequestCallback callback] ) <br />
			[method:void setFoveation](  [param:number foveation] ) <br />
			[method:void setFramebufferScaleFactor](  [param:number value] ) <br />
			[method:void setReferenceSpaceType](  [param:XRReferenceSpaceType value] ) <br />
			[method:Promise setSession](  [param:XRSession value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="Window">Window <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Constructor XR]? -  The x r.<br />
			[property:Constructor XRSession]? -  The x r session.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Mesh] &rarr;

		<h3 id="Wireframe">Wireframe <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Wireframe Wireframe](  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]? ) <br />
			[constructor:Wireframe Wireframe](  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) <br />
			[constructor:Wireframe Wireframe](  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - The constructor takes no arguments.<br />
			[constructor:Wireframe Wireframe](  [param:LineSegmentsGeometry geometry]?,  [param:LineMaterial material]?,  [param:BufferGeometry geometry]?,  [param:Material|Material[] material]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isWireframe] -  The is wireframe.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Wireframe add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:Wireframe applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:Wireframe attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:Wireframe clear](  ) - Removes all child objects.<br />
			[method:Wireframe clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:Wireframe computeLineDistances](  ) <br />
			[method:Wireframe copy](  [param:Wireframe source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Get intersections between a casted ray and this mesh.<br />
			[page:Raycaster.intersectObject Raycaster.intersectObject] will call this method, but the results are not ordered.<br />
			[method:Wireframe remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:Wireframe removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:Wireframe rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Wireframe rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:Wireframe rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:Wireframe rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:Wireframe rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:Wireframe translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:Wireframe translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:Wireframe translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:Wireframe translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateMorphTargets](  ) - Updates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr;

		<h3 id="WireframeGeometry">WireframeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WireframeGeometry WireframeGeometry](  [param:TBufferGeometry geometry]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:WireframeGeometry WireframeGeometry](  [param:TBufferGeometry geometry]? ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:WireframeGeometry WireframeGeometry](  [param:TBufferGeometry geometry]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:BufferGeometry applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:WireframeGeometry copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:InstancedBufferGeometry] &rarr; [page:LineSegmentsGeometry] &rarr;

		<h3 id="WireframeGeometry2">WireframeGeometry2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:WireframeGeometry2 WireframeGeometry2](  [param:BufferGeometry geometry] ) <br />
			[constructor:WireframeGeometry2 WireframeGeometry2](  [param:BufferGeometry geometry] ) <br />
			[constructor:WireframeGeometry2 WireframeGeometry2](  [param:BufferGeometry geometry] ) <br />
			[constructor:WireframeGeometry2 WireframeGeometry2](  [param:BufferGeometry geometry] ) - This creates a new BufferGeometry. It also sets several properties to an default value.<br />
			[constructor:WireframeGeometry2 WireframeGeometry2](  [param:BufferGeometry geometry] ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isLineSegmentsGeometry] -  The is line segments geometry.<br />
			[property:boolean sWireframeGeometry2] -  The s wireframe geometry2.
		</p>
		<h4>Methods</h4>
		<p>
			[method:BufferGeometry addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - deprecated - Use {@link BufferGeometry#setAttribute .setAttribute()} instead.<br />
			[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) - Returns : attribute<br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) - deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number instances] ) - Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.<br />
			[method:void addIndex](  [param:any index] ) - deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.<br />
			[method:WireframeGeometry2 applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the geometry.<br />
			[method:BufferGeometry applyQuaternion](  [param:Quaternion q] ) - Applies the rotation represented by the quaternion to the geometry.<br />
			[method:BufferGeometry center](  ) - Center the geometry based on the bounding box.<br />
			[method:void clearDrawCalls](  ) - deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.<br />
			[method:void clearGroups](  ) - Clears all groups.<br />
			[method:BufferGeometry clone](  ) - Creates a clone of this BufferGeometry.<br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.<br />
			[method:void computeTangents](  ) - Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:WireframeGeometry2 copy](  [param:BufferGeometry source] ) - Copies another BufferGeometry to this BufferGeometry.<br />
			[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) - Deletes the [page:BufferAttribute attribute] with the specified name.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.<br />
			[method:WireframeGeometry2 fromEdgesGeometry](  [param:EdgesGeometry geometry] ) <br />
			[method:WireframeGeometry2 fromLineSegments](  [param:LineSegments lineSegments] ) <br />
			[method:WireframeGeometry2 fromMesh](  [param:Mesh mesh] ) <br />
			[method:WireframeGeometry2 fromWireframeGeometry](  [param:WireframeGeometry geometry] ) <br />
			[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns the [page:BufferAttribute attribute] with the specified name.<br />
			[method:BufferAttribute getIndex](  ) - Returns : Return the *.index* buffer.<br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) - Returns : Returns *true* if the attribute with the specified name exists.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:Vector3 v] ) - vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.<br />
			[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? ) - Merge in another BufferGeometry with an optional offset of where to start merging in.<br />
			[method:void normalizeNormals](  ) - Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.<br />
			[method:BufferGeometry removeAttribute](  [param:string name] ) - deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:BufferGeometry rotateX](  [param:number angle] ) - Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateY](  [param:number angle] ) - Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry rotateZ](  [param:number angle] ) - Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.<br />
			[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) - Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.<br />
			[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] ) - Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.<br />
			[method:WireframeGeometry2 setColors](  [param:Float32Array|number[] array] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) - Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.<br />
			[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] ) - Sets the attributes for this BufferGeometry from an array of points.<br />
			[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] ) - Set the *.index* buffer.<br />
			[method:WireframeGeometry2 setPositions](  [param:Float32Array|number[] array] ) <br />
			[method:any toJSON](  ) - Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].<br />
			[method:BufferGeometry toNonIndexed](  ) - Returns : Return a non-index version of an indexed BufferGeometry.<br />
			[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) - Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRAnchor">XRAnchor <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:EventTarget anchorSpace] -  The anchor space.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void delete](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="XRControllerModel">XRControllerModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XRControllerModel XRControllerModel](  ) - The constructor takes no arguments.<br />
			[constructor:XRControllerModel XRControllerModel](  ) - The constructor takes no arguments.<br />
			[constructor:XRControllerModel XRControllerModel](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:any motionController] -  The motion controller.
		</p>
		<h4>Methods</h4>
		<p>
			[method:XRControllerModel add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:XRControllerModel applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:XRControllerModel attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:XRControllerModel clear](  ) - Removes all child objects.<br />
			[method:XRControllerModel clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:XRControllerModel copy](  [param:XRControllerModel source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:XRControllerModel remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:XRControllerModel removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:XRControllerModel rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:XRControllerModel rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:XRControllerModel rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:XRControllerModel rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:XRControllerModel rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:XRControllerModel setEnvironmentMap](  [param:Texture envMap] ) <br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:XRControllerModel translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:XRControllerModel translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:XRControllerModel translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:XRControllerModel translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRControllerModelFactory">XRControllerModelFactory <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XRControllerModelFactory XRControllerModelFactory](  [param:GLTFLoader gltfLoader]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:GLTFLoader gltfLoader] -  The gltf loader.<br />
			[property:string path] -  The path.
		</p>
		<h4>Methods</h4>
		<p>
			[method:XRControllerModel createControllerModel](  [param:Group controller] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr; [page:Group] &rarr;

		<h3 id="XREstimatedLight">XREstimatedLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XREstimatedLight XREstimatedLight](  [param:WebGLRenderer renderer],  [param:boolean environmentEstimation]? ) - The constructor takes no arguments.<br />
			[constructor:XREstimatedLight XREstimatedLight](  [param:WebGLRenderer renderer],  [param:boolean environmentEstimation]? ) - The constructor takes no arguments.<br />
			[constructor:XREstimatedLight XREstimatedLight](  [param:WebGLRenderer renderer],  [param:boolean environmentEstimation]? ) - The constructor takes no arguments.<br />
			[constructor:XREstimatedLight XREstimatedLight](  [param:WebGLRenderer renderer],  [param:boolean environmentEstimation]? ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:DirectionalLight directionalLight] -  The directional light.<br />
			[property:Texture environment] -  The environment.<br />
			[property:LightProbe lightProbe] -  The light probe.
		</p>
		<h4>Methods</h4>
		<p>
			[method:XREstimatedLight add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:XREstimatedLight applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:XREstimatedLight attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:XREstimatedLight clear](  ) - Removes all child objects.<br />
			[method:XREstimatedLight clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:XREstimatedLight copy](  [param:XREstimatedLight source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:XREstimatedLight remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:XREstimatedLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:XREstimatedLight rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:XREstimatedLight rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:XREstimatedLight rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:XREstimatedLight rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:XREstimatedLight rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:XREstimatedLight translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:XREstimatedLight translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:XREstimatedLight translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:XREstimatedLight translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRFrame">XRFrame <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRSession session] -  The session.<br />
			[property:XRAnchorSet trackedAnchors]? -  The tracked anchors.<br />
			[property:any worldInformation] -  The world information.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Promise createAnchor](  [param:XRRigidTransform pose],  [param:EventTarget space] ) <br />
			[method:XRHitTestResult[] getHitTestResults](  [param:XRHitTestSource hitTestSource] ) <br />
			[method:XRTransientInputHitTestResult[] getHitTestResultsForTransientInput](  [param:XRTransientInputHitTestSource hitTestSource] ) <br />
			[method:XRJointPose getJointPose](  [param:XRJointSpace joint],  [param:EventTarget baseSpace] ) <br />
			[method:XRPose getPose](  [param:EventTarget space],  [param:EventTarget baseSpace] ) <br />
			[method:XRViewerPose getViewerPose](  [param:XRReferenceSpace referenceSpace] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRGamepad">XRGamepad <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Float32Array axes] -  The axes.<br />
			[property:GamepadButton[] buttons] -  The buttons.<br />
			[property:boolean connected] -  The connected.<br />
			[property:string id] -  The id.<br />
			[property:number index] -  The index.<br />
			[property:GamepadMappingType mapping] -  The mapping.<br />
			[property:number timestamp] -  The timestamp.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Map] &rarr;

		<h3 id="XRHand">XRHand <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number size] -  The size.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHandMeshModel">XRHandMeshModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XRHandMeshModel XRHandMeshModel](  [param:Object3D handModel],  [param:Object3D controller],  [param:string path],  [param:string handedness] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Object3D[] bones] -  The bones.<br />
			[property:Object3D controller] -  The controller.<br />
			[property:Object3D handModel] -  The hand model.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void updateMesh](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventDispatcher] &rarr; [page:Object3D] &rarr;

		<h3 id="XRHandModel">XRHandModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XRHandModel XRHandModel](  ) - The constructor takes no arguments.<br />
			[constructor:XRHandModel XRHandModel](  ) - The constructor takes no arguments.<br />
			[constructor:XRHandModel XRHandModel](  ) - Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>
		<h4>Properties</h4>
		<p>
			[property:XRHandMeshModel|XRHandPrimitiveModel motionController] -  The motion controller.
		</p>
		<h4>Methods</h4>
		<p>
			[method:XRHandModel add](  [param:Object3D[] object] ) - Adds *object* as child of this object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent.<br />
			See [page:Group Group] for info on manually grouping objects.<br />
			[method:void addEventListener](  [param:T type],  [param:EventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:Matrix4 matrix] ) - Applies the matrix transform to the object and updates the object's position, rotation and scale.<br />
			[method:XRHandModel applyQuaternion](  [param:Quaternion quaternion] ) - Applies the rotation represented by the quaternion to the object.<br />
			[method:XRHandModel attach](  [param:Object3D object] ) - Adds *object* as a child of this, while maintaining the object's world transform.<br />
			Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).<br />
			[method:XRHandModel clear](  ) - Removes all child objects.<br />
			[method:XRHandModel clone](  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also cloned. Default is true.<br />
			<br />
			Returns : Returns a clone of this object and optionally all descendants.<br />
			[method:XRHandModel copy](  [param:XRHandModel source],  [param:boolean recursive]? ) - recursive -- if true, descendants of the object are also copied. Default is true.<br />
			Copy the given object into this object.<br />
			Note: event listeners and user-defined callbacks (*.onAfterRender* and *.onBeforeRender*) are not copied.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:Object3D getObjectById](  [param:number id] ) - id -- Unique number of the object instance Searches through an object and its children, starting with the object itself, and returns the first with a matching id.<br />
			Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.<br />
			[method:Object3D getObjectByName](  [param:string name] ) - name -- String to match to the children's Object3D.name property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a matching name.<br />
			Note that for most objects the name is an empty string by default. You will have to set it manually to make use of this method.<br />
			[method:Object3D getObjectByProperty](  [param:string name],  [param:string value] ) - name -- the property name to search for.<br />
			value -- value of the given property.<br />
			Searches through an object and its children, starting with the object itself, and returns the first with a property that matches the value given.<br />
			[method:Vector3 getWorldDirection](  [param:Vector3 target] ) - Returns : Returns a vector representing the direction of object's positive z-axis in world space.<br />
			[method:Vector3 getWorldPosition](  [param:Vector3 target] ) - Returns : Returns a vector representing the position of the object in world space.<br />
			[method:Quaternion getWorldQuaternion](  [param:Quaternion target] ) - Returns : Returns a quaternion representing the rotation of the object in world space.<br />
			[method:Vector3 getWorldScale](  [param:Vector3 target] ) - Returns : Returns a vector of the scaling factors applied to the object for each axis in world space.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:Vector3 localToWorld](  [param:Vector3 vector] ) - vector - A vector representing a position in this object's local space.<br />
			Converts the vector from this object's local space to world space.<br />
			[method:void lookAt](  [param:number|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Optionally, the *.x*, *.y* and *.z* components of the world space position.<br />
			Rotates the object to face a point in world space.<br />
			This method does not support objects having non-uniformly-scaled parent(s).<br />
			[method:void onAfterRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately after a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void onBeforeRender](  [param:WebGLRenderer renderer],  [param:Scene scene],  [param:Camera camera],  [param:BufferGeometry geometry],  [param:Material material],  [param:Group group] ) - An optional callback that is executed immediately before a 3D object is rendered.<br />
			This function is called with the following parameters: renderer, scene, camera, geometry, material, group.<br />
			Please notice that this callback is only executed for *renderable* 3D objects. Meaning 3D objects which define their visual appearance with geometries and materials like instances of [page:Mesh Mesh], [page:Line Line], [page:Points Points] or [page:Sprite Sprite].<br />
			Instances of [page:Object3D Object3D], [page:Group Group] or [page:Bone Bone] are not renderable and thus this callback is not executed for such objects.<br />
			[method:void raycast](  [param:Raycaster raycaster],  [param:Intersection[] intersects] ) - Abstract (empty) method to get intersections between a casted ray and this object.<br />
			Subclasses such as [page:Mesh Mesh], [page:Line Line], and [page:Points Points] implement this method in order to use raycasting.<br />
			[method:XRHandModel remove](  [param:Object3D[] object] ) - Removes *object* as child of this object. An arbitrary number of objects may be removed.<br />
			[method:void removeEventListener](  [param:T type],  [param:EventListener listener] ) - Removes a listener from an event type.<br />
			[method:XRHandModel removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:XRHandModel rotateOnAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:XRHandModel rotateOnWorldAxis](  [param:Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized.<br />
			Method Assumes no rotated parent.<br />
			[method:XRHandModel rotateX](  [param:number angle] ) - Rotates the object around x axis in local space.<br />
			[method:XRHandModel rotateY](  [param:number angle] ) - Rotates the object around y axis in local space.<br />
			[method:XRHandModel rotateZ](  [param:number angle] ) - Rotates the object around z axis in local space.<br />
			[method:void setRotationFromAxisAngle](  [param:Vector3 axis],  [param:number angle] ) - Calls [page:Quaternion.setFromAxisAngle setFromAxisAngle]( [page:Float axis], [page:Float angle] ) on the *.quaternion*.<br />
			[method:void setRotationFromEuler](  [param:Euler euler] ) - Calls [page:Quaternion.setRotationFromEuler setRotationFromEuler]( [page:Euler euler]) on the *.quaternion*.<br />
			[method:void setRotationFromMatrix](  [param:Matrix4 m] ) - Calls [page:Quaternion.setFromRotationMatrix setFromRotationMatrix]( [page:Matrix4 m]) on the *.quaternion*.<br />
			Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br />
			[method:void setRotationFromQuaternion](  [param:Quaternion q] ) - Copy the given quaternion into *.quaternion*.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:XRHandModel translateOnAxis](  [param:Vector3 axis],  [param:number distance] ) - Translate an object by distance along an axis in object space. The axis is assumed to be normalized.<br />
			[method:XRHandModel translateX](  [param:number distance] ) - Translates object along x axis in object space by *distance* units.<br />
			[method:XRHandModel translateY](  [param:number distance] ) - Translates object along y axis in object space by *distance* units.<br />
			[method:XRHandModel translateZ](  [param:number distance] ) - Translates object along z axis in object space by *distance* units.<br />
			[method:void traverse](  [param:any callback] ) - Executes the callback on this object and all descendants.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseAncestors](  [param:any callback] ) - Executes the callback on all ancestors.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void traverseVisible](  [param:any callback] ) - Like traverse, but the callback will only be executed for visible objects.<br />
			Descendants of invisible objects are not traversed.<br />
			Note: Modifying the scene graph inside the callback is discouraged.<br />
			[method:void updateMatrix](  ) - Updates the local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates the global transform of the object and its descendants.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) - Updates the global transform of the object.<br />
			[method:Vector3 worldToLocal](  [param:Vector3 vector] ) - Converts the vector from world space to this object's local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHandModelFactory">XRHandModelFactory <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XRHandModelFactory XRHandModelFactory](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string path] -  The path.
		</p>
		<h4>Methods</h4>
		<p>
			[method:XRHandModel createHandModel](  [param:Group controller],  [param:'spheres'|'boxes'|'oculus' profile]?,  [param:XRHandPrimitiveModelOptions options]? ) <br />
			[method:XRHandModelFactory setPath](  [param:string path] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHandPrimitiveModel">XRHandPrimitiveModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XRHandPrimitiveModel XRHandPrimitiveModel](  [param:XRHandModel handModel],  [param:Group controller],  [param:string path],  [param:XRHandModelHandedness handedness],  [param:XRHandPrimitiveModelOptions options] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Group controller] -  The controller.<br />
			[property:Texture envMap] -  The env map.<br />
			[property:Group handMesh] -  The hand mesh.<br />
			[property:XRHandModel handModel] -  The hand model.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void updateMesh](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHandPrimitiveModelOptions">XRHandPrimitiveModelOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:'sphere'|'box' primitive]? -  The primitive.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHitResult">XRHitResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Float32Array hitMatrix] -  The hit matrix.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHitTestOptionsInit">XRHitTestOptionsInit <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRHitTestTrackableType[] entityTypes]? -  The entity types.<br />
			[property:XRRay offsetRay]? -  The offset ray.<br />
			[property:EventTarget space] -  The space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHitTestResult">XRHitTestResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:Promise createAnchor](  [param:XRRigidTransform pose] ) <br />
			[method:XRPose getPose](  [param:EventTarget baseSpace] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHitTestSource">XRHitTestSource <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void cancel](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRInputSource">XRInputSource <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRGamepad gamepad] -  The gamepad.<br />
			[property:EventTarget gripSpace]? -  The grip space.<br />
			[property:XRHand hand]? -  The hand.<br />
			[property:XRHandedness handedness] -  The handedness.<br />
			[property:string[] profiles] -  The profiles.<br />
			[property:XRTargetRayMode targetRayMode] -  The target ray mode.<br />
			[property:EventTarget targetRaySpace] -  The target ray space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRInputSourceChangeEvent">XRInputSourceChangeEvent <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRInputSource[] added] -  The added.<br />
			[property:XRInputSource[] removed] -  The removed.<br />
			[property:XRSession session] -  The session.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:BaseEvent] &rarr; [page:Event] &rarr;

		<h3 id="XRInputSourceEvent">XRInputSourceEvent <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRFrame frame] -  The frame.<br />
			[property:XRInputSource inputSource] -  The input source.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:XRPose] &rarr;

		<h3 id="XRJointPose">XRJointPose <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean emulatedPosition] -  The emulated position.<br />
			[property:number radius] -  The radius.<br />
			[property:XRRigidTransform transform] -  The transform.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventTarget] &rarr;

		<h3 id="XRJointSpace">XRJointSpace <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRHandJoint jointName] -  The joint name.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRPlane">XRPlane <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number lastChangedTime] -  The last changed time.<br />
			[property:'Horizontal'|'Vertical' orientation] -  The orientation.<br />
			[property:EventTarget planeSpace] -  The plane space.<br />
			[property:DOMPointReadOnly[] polygon] -  The polygon.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRPose">XRPose <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean emulatedPosition] -  The emulated position.<br />
			[property:XRRigidTransform transform] -  The transform.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRRay">XRRay <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XRRay XRRay](  [param:XRRigidTransform|DOMPointInit transformOrOrigin],  [param:XRRayDirectionInit direction]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:XRRayDirectionInit direction] -  The direction.<br />
			[property:Float32Array matrix] -  The matrix.<br />
			[property:DOMPointReadOnly origin] -  The origin.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRRayDirectionInit">XRRayDirectionInit <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number w]? -  The w.<br />
			[property:number x]? -  The x.<br />
			[property:number y]? -  The y.<br />
			[property:number z]? -  The z.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventTarget] &rarr;

		<h3 id="XRReferenceSpace">XRReferenceSpace <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any onreset] -  The onreset.
		</p>
		<h4>Methods</h4>
		<p>
			[method:XRReferenceSpace getOffsetReferenceSpace](  [param:XRRigidTransform originOffset] ) <br />
			[method:XRReferenceSpace getOffsetReferenceSpace](  [param:XRRigidTransform originOffset],  [param:XRRigidTransform originOffset] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRRenderState">XRRenderState <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRWebGLLayer baseLayer]? -  The base layer.<br />
			[property:number depthFar] -  The depth far.<br />
			[property:number depthNear] -  The depth near.<br />
			[property:number inlineVerticalFieldOfView]? -  The inline vertical field of view.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRRenderStateInit">XRRenderStateInit <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRWebGLLayer baseLayer]? -  The base layer.<br />
			[property:number depthFar]? -  The depth far.<br />
			[property:number depthNear]? -  The depth near.<br />
			[property:number inlineVerticalFieldOfView]? -  The inline vertical field of view.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRRigidTransform">XRRigidTransform <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XRRigidTransform XRRigidTransform](  [param:Float32Array|DOMPointInit matrix],  [param:DOMPointInit direction]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:XRRigidTransform inverse] -  The inverse.<br />
			[property:Float32Array matrix] -  The matrix.<br />
			[property:DOMPointReadOnly orientation] -  The orientation.<br />
			[property:DOMPointReadOnly position] -  The position.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:EventTarget] &rarr;

		<h3 id="XRSession">XRSession <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XREnvironmentBlendMode environmentBlendMode] -  The environment blend mode.<br />
			[property:XRInputSource[] inputSources] -  The input sources.<br />
			[property:XRRenderState renderState] -  The render state.<br />
			[property:XRVisibilityState visibilityState] -  The visibility state.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void cancelAnimationFrame](  [param:number id] ) <br />
			[method:Promise end](  ) <br />
			[method:number requestAnimationFrame](  [param:XRFrameRequestCallback callback] ) <br />
			[method:Promise requestHitTest](  [param:XRRay ray],  [param:XRReferenceSpace referenceSpace] ) <br />
			[method:Promise requestHitTestSource](  [param:XRHitTestOptionsInit options] ) <br />
			[method:Promise requestHitTestSourceForTransientInput](  [param:XRTransientInputHitTestOptionsInit options] ) <br />
			[method:Promise requestReferenceSpace](  [param:XRReferenceSpaceType type] ) <br />
			[method:Promise updateRenderState](  [param:XRRenderStateInit renderStateInit] ) <br />
			[method:void updateWorldTrackingState](  [param:any options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRSessionInit">XRSessionInit <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string[] optionalFeatures]? -  The optional features.<br />
			[property:string[] requiredFeatures]? -  The required features.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRTransientInputHitTestOptionsInit">XRTransientInputHitTestOptionsInit <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRHitTestTrackableType[] entityTypes]? -  The entity types.<br />
			[property:XRRay offsetRay]? -  The offset ray.<br />
			[property:string profile] -  The profile.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRTransientInputHitTestResult">XRTransientInputHitTestResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRInputSource inputSource] -  The input source.<br />
			[property:XRHitTestResult[] results] -  The results.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRTransientInputHitTestSource">XRTransientInputHitTestSource <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void cancel](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRView">XRView <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XREye eye] -  The eye.<br />
			[property:Float32Array projectionMatrix] -  The projection matrix.<br />
			[property:XRRigidTransform transform] -  The transform.<br />
			[property:Float32Array viewMatrix] -  The view matrix.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRViewerPose">XRViewerPose <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:XRRigidTransform transform] -  The transform.<br />
			[property:XRView[] views] -  The views.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRViewport">XRViewport <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number height] -  The height.<br />
			[property:number width] -  The width.<br />
			[property:number x] -  The x.<br />
			[property:number y] -  The y.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRWebGLLayer">XRWebGLLayer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XRWebGLLayer XRWebGLLayer](  [param:XRSession session],  [param:WebGLRenderingContext gl],  [param:XRWebGLLayerInit options]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:WebGLFramebuffer framebuffer] -  The framebuffer.<br />
			[property:number framebufferHeight] -  The framebuffer height.<br />
			[property:number framebufferWidth] -  The framebuffer width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:XRViewport getViewport](  [param:XRView view] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRWebGLLayerInit">XRWebGLLayerInit <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean alpha]? -  The alpha.<br />
			[property:boolean antialias]? -  The antialias.<br />
			[property:boolean depth]? -  The depth.<br />
			[property:number framebufferScaleFactor]? -  The framebuffer scale factor.<br />
			[property:boolean ignoreDepthValues]? -  The ignore depth values.<br />
			[property:boolean stencil]? -  The stencil.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:Loader] &rarr;

		<h3 id="XYZLoader">XYZLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:XYZLoader XYZLoader](  [param:LoadingManager manager]? ) <br />
			[constructor:XYZLoader XYZLoader](  [param:LoadingManager manager]?,  [param:LoadingManager manager]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:object parse](  [param:string data],  [param:any onLoad] ) <br />
			[method:XYZLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:XYZLoader setPath](  [param:string path] ) <br />
			[method:XYZLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:XYZLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:XYZLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ZipAttributes">ZipAttributes <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number attrs]? - The file's attributes. These are traditionally somewhat complicated<br />
			and platform-dependent, so using them is scarcely necessary. However,<br />
			here is a representation of what this is, bit by bit:<br />
			`TTTTugtrwxrwxrwx0000000000ADVSHR`<br />
			<br />
			TTTT = file type (rarely useful)<br />
			<br />
			u = setuid, g = setgid, t = sticky<br />
			<br />
			rwx = user permissions, rwx = group permissions, rwx = other permissions<br />
			<br />
			0000000000 = unused<br />
			<br />
			A = archive, D = directory, V = volume label, S = system file, H = hidden, R = read-only<br />
			<br />
			If you want to set the Unix permissions, for instance, just bit shift by 16, e.g. 0644 &lt;&lt; 16<br />
			[property:string comment]? - The comment to attach to the file. This field is defined by PKZIP's APPNOTE.txt,<br />
			section 4.4.26. The comment must be at most 65,535 bytes long UTF-8 encoded. This<br />
			field is not read by consumer software.<br />
			[property:Record extra]? - Extra metadata to add to the file. This field is defined by PKZIP's APPNOTE.txt,<br />
			section 4.4.28. At most 65,535 bytes may be used in each ID. The ID must be an<br />
			integer between 0 and 65,535, inclusive.<br />
			This field is incredibly rare and almost never needed except for compliance with<br />
			proprietary standards and software.<br />
			[property:string|number|Date mtime]? - When the file was last modified. Defaults to the current time.<br />
			[property:number os]? - The operating system of origin for this file. The value is defined<br />
			by PKZIP's APPNOTE.txt, section 4.4.2.2. For example, 0 (the default)<br />
			is MS/DOS, 3 is UNIX, 19 is macOS.
		</p>

		<p class="desc">
			Attributes for files added to a ZIP archive object
		</p>

		<hr class="interface-line"/>
		<h3 id="ZipDeflate">ZipDeflate <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ZipDeflate ZipDeflate](  [param:string filename],  [param:DeflateOptions opts]? ) - Creates a DEFLATE stream that can be added to ZIP archives
		</p>
		<h4>Properties</h4>
		<p>
			[property:number attrs]? -  The attrs.<br />
			[property:string comment]? -  The comment.<br />
			[property:number compression] -  The compression.<br />
			[property:number crc] -  The crc.<br />
			[property:Record extra]? -  The extra.<br />
			[property:string filename] -  The filename.<br />
			[property:'0'|'1'|'2'|'3' flag] -  The flag.<br />
			[property:string|number|Date mtime]? -  The mtime.<br />
			[property:AsyncFlateStreamHandler ondata] -  The ondata.<br />
			[property:number os]? -  The os.<br />
			[property:number size] -  The size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void process](  [param:Uint8Array chunk],  [param:boolean final] ) <br />
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be deflated
		</p>

		<p class="desc">
			Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate<br />
			for better performance
		</p>

		<hr class="interface-line"/>
		[page:ZipAttributes] &rarr;

		<h3 id="ZipInputFile">ZipInputFile <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number attrs]? - The file's attributes. These are traditionally somewhat complicated<br />
			and platform-dependent, so using them is scarcely necessary. However,<br />
			here is a representation of what this is, bit by bit:<br />
			`TTTTugtrwxrwxrwx0000000000ADVSHR`<br />
			<br />
			TTTT = file type (rarely useful)<br />
			<br />
			u = setuid, g = setgid, t = sticky<br />
			<br />
			rwx = user permissions, rwx = group permissions, rwx = other permissions<br />
			<br />
			0000000000 = unused<br />
			<br />
			A = archive, D = directory, V = volume label, S = system file, H = hidden, R = read-only<br />
			<br />
			If you want to set the Unix permissions, for instance, just bit shift by 16, e.g. 0644 &lt;&lt; 16<br />
			[property:string comment]? - The comment to attach to the file. This field is defined by PKZIP's APPNOTE.txt,<br />
			section 4.4.26. The comment must be at most 65,535 bytes long UTF-8 encoded. This<br />
			field is not read by consumer software.<br />
			[property:number compression] - The compression format for the data stream. This number is determined by<br />
			the spec in PKZIP's APPNOTE.txt, section 4.4.5. For example, 0 = no<br />
			compression, 8 = deflate, 14 = LZMA<br />
			[property:number crc] - A CRC of the original file contents. This attribute may be invalid after<br />
			the file is added to the ZIP archive; it must be correct only before the<br />
			stream completes.<br />
			If you don't want to have to generate this yourself, consider extending the<br />
			ZipPassThrough class and overriding its process() method, or using one of<br />
			ZipDeflate or AsyncZipDeflate.<br />
			[property:Record extra]? - Extra metadata to add to the file. This field is defined by PKZIP's APPNOTE.txt,<br />
			section 4.4.28. At most 65,535 bytes may be used in each ID. The ID must be an<br />
			integer between 0 and 65,535, inclusive.<br />
			This field is incredibly rare and almost never needed except for compliance with<br />
			proprietary standards and software.<br />
			[property:string filename] - The filename to associate with the data provided to this stream. If you<br />
			want a file in a subdirectory, use forward slashes as a separator (e.g.<br />
			`directory/filename.ext`). This will still work on Windows.<br />
			[property:number flag]? - Bits 1 and 2 of the general purpose bit flag, specified in PKZIP's<br />
			APPNOTE.txt, section 4.4.4. Should be between 0 and 3. This is unlikely<br />
			to be necessary.<br />
			[property:string|number|Date mtime]? - When the file was last modified. Defaults to the current time.<br />
			[property:AsyncFlateStreamHandler ondata]? - The handler to be called when data is added. After passing this stream to<br />
			the ZIP file object, this handler will always be defined. To call it:<br />
			`stream.ondata(error, chunk, final)`<br />
			<br />
			error = any error that occurred (null if there was no error)<br />
			<br />
			chunk = a Uint8Array of the data that was added (null if there was an<br />
			error)<br />
			<br />
			final = boolean, whether this is the final chunk in the stream<br />
			[property:number os]? - The operating system of origin for this file. The value is defined<br />
			by PKZIP's APPNOTE.txt, section 4.4.2.2. For example, 0 (the default)<br />
			is MS/DOS, 3 is UNIX, 19 is macOS.<br />
			[property:number size] - The size of the file in bytes. This attribute may be invalid after<br />
			the file is added to the ZIP archive; it must be correct only before the<br />
			stream completes.<br />
			If you don't want to have to compute this yourself, consider extending the<br />
			ZipPassThrough class and overriding its process() method, or using one of<br />
			ZipDeflate or AsyncZipDeflate.<br />
			[property:AsyncTerminable terminate]? - A method called when the stream is no longer needed, for clean-up<br />
			purposes. This will not always be called after the stream completes,<br />
			so you may wish to call this.terminate() after the final chunk is<br />
			processed if you have clean-up logic.
		</p>

		<p class="desc">
			A stream that can be used to create a file in a ZIP archive
		</p>

		<hr class="interface-line"/>
		[page:DeflateOptions] &rarr;

		<h3 id="ZipOptions">ZipOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number attrs]? - The file's attributes. These are traditionally somewhat complicated<br />
			and platform-dependent, so using them is scarcely necessary. However,<br />
			here is a representation of what this is, bit by bit:<br />
			`TTTTugtrwxrwxrwx0000000000ADVSHR`<br />
			<br />
			TTTT = file type (rarely useful)<br />
			<br />
			u = setuid, g = setgid, t = sticky<br />
			<br />
			rwx = user permissions, rwx = group permissions, rwx = other permissions<br />
			<br />
			0000000000 = unused<br />
			<br />
			A = archive, D = directory, V = volume label, S = system file, H = hidden, R = read-only<br />
			<br />
			If you want to set the Unix permissions, for instance, just bit shift by 16, e.g. 0644 &lt;&lt; 16<br />
			[property:string comment]? - The comment to attach to the file. This field is defined by PKZIP's APPNOTE.txt,<br />
			section 4.4.26. The comment must be at most 65,535 bytes long UTF-8 encoded. This<br />
			field is not read by consumer software.<br />
			[property:Record extra]? - Extra metadata to add to the file. This field is defined by PKZIP's APPNOTE.txt,<br />
			section 4.4.28. At most 65,535 bytes may be used in each ID. The ID must be an<br />
			integer between 0 and 65,535, inclusive.<br />
			This field is incredibly rare and almost never needed except for compliance with<br />
			proprietary standards and software.<br />
			[property:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' level]? - The level of compression to use, ranging from 0-9.<br />
			0 will store the data without compression.<br />
			1 is fastest but compresses the worst, 9 is slowest but compresses the best.<br />
			The default level is 6.<br />
			<br />
			Typically, binary data benefits much more from higher values than text data.<br />
			In both cases, higher values usually take disproportionately longer than the reduction in final size that results.<br />
			<br />
			For example, a 1 MB text file could:<br />
			- become 1.01 MB with level 0 in 1ms<br />
			- become 400 kB with level 1 in 10ms<br />
			- become 320 kB with level 9 in 100ms<br />
			[property:'0'|'1'|'2'|'3'|'4'|'10'|'5'|'6'|'7'|'8'|'9'|'11'|'12' mem]? - The memory level to use, ranging from 0-12. Increasing this increases speed and compression ratio at the cost of memory.<br />
			Note that this is exponential: while level 0 uses 4 kB, level 4 uses 64 kB, level 8 uses 1 MB, and level 12 uses 16 MB.<br />
			It is recommended not to lower the value below 4, since that tends to hurt performance.<br />
			In addition, values above 8 tend to help very little on most data and can even hurt performance.<br />
			<br />
			The default value is automatically determined based on the size of the input data.<br />
			[property:string|number|Date mtime]? - When the file was last modified. Defaults to the current time.<br />
			[property:number os]? - The operating system of origin for this file. The value is defined<br />
			by PKZIP's APPNOTE.txt, section 4.4.2.2. For example, 0 (the default)<br />
			is MS/DOS, 3 is UNIX, 19 is macOS.
		</p>

		<p class="desc">
			Options for creating a ZIP archive
		</p>

		<hr class="interface-line"/>
		<h3 id="ZipPassThrough">ZipPassThrough <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ZipPassThrough ZipPassThrough](  [param:string filename] ) - Creates a pass-through stream that can be added to ZIP archives
		</p>
		<h4>Properties</h4>
		<p>
			[property:number attrs]? -  The attrs.<br />
			[property:string comment]? -  The comment.<br />
			[property:number compression] -  The compression.<br />
			[property:number crc] -  The crc.<br />
			[property:Record extra]? -  The extra.<br />
			[property:string filename] -  The filename.<br />
			[property:string|number|Date mtime]? -  The mtime.<br />
			[property:AsyncFlateStreamHandler ondata] -  The ondata.<br />
			[property:number os]? -  The os.<br />
			[property:number size] -  The size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void process](  [param:Uint8Array chunk],  [param:boolean final] ) - Processes a chunk and pushes to the output stream. You can override this<br />
			method in a subclass for custom behavior, but by default this passes<br />
			the data through. You must call this.ondata(err, chunk, final) at some<br />
			point in this method.<br />
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be added. If you are subclassing this with a custom<br />
			compression algorithm, note that you must push data from the source<br />
			file only, pre-compression.
		</p>

		<p class="desc">
			A pass-through stream to keep data uncompressed in a ZIP archive.
		</p>


		<p class="desc">
			The complete directory structure of a ZIPpable archive
		</p>

		<hr class="interface-line"/>
		<h3 id="Zlib">Zlib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:Zlib Zlib](  [param:DeflateOptions opts],  [param:FlateStreamHandler cb]? ) - Creates a Zlib stream<br />
			[constructor:Zlib Zlib](  [param:DeflateOptions opts],  [param:FlateStreamHandler cb]?,  [param:FlateStreamHandler cb]? ) - Creates a Zlib stream
		</p>
		<h4>Properties</h4>
		<p>
			[property:FlateStreamHandler ondata] - The handler to call whenever data is available
		</p>
		<h4>Methods</h4>
		<p>
			[method:void push](  [param:Uint8Array chunk],  [param:boolean final]? ) - Pushes a chunk to be zlibbed
		</p>

		<p class="desc">
			Streaming Zlib compression
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="pName">pName <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string key] -  The key.<br />
			[property:number name] -  The name.<br />
			[property:string related] -  The related.<br />
			[property:string relating] -  The relating.
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ArcballControlsMouseActionMouse">ArcballControlsMouseActionMouse <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'0'|'1'|'2'|'WHEEL' ArcballControlsMouseActionMouse]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncFlateStreamHandler">AsyncFlateStreamHandler <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:Error err],  [param:Uint8Array data],  [param:boolean final] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:Error err] - Any error that occurred<br />
			[property:Uint8Array data] - The data output from the stream processor<br />
			[property:boolean final] - Whether this is the final block
		</p>
		<p>
			Handler for asynchronous data (de)compression streams
		</p>



		<p class="desc">
			
		</p>


		<p class="desc">
			Options for decompressing GZIP data asynchronously
		</p>


		<p class="desc">
			Options for asynchronously expanding a ZIP archive
		</p>


		<p class="desc">
			Options for decompressing Zlib data asynchronously
		</p>

		<hr class="interface-line"/>
		<h3 id="AsyncZippableFile">AsyncZippableFile <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:Uint8Array AsyncZippableFile]</h3>


		<p class="desc">
			A file that can be used to asynchronously create a ZIP archive
		</p>

		<hr class="interface-line"/>
		<h3 id="BuiltinShaderAttributeName">BuiltinShaderAttributeName <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'position'|'normal'|'uv'|'color'|'skinIndex'|'skinWeight'|'instanceMatrix'|'morphTarget0'|'morphTarget1'|'morphTarget2'|'morphTarget3'|'morphTarget4'|'morphTarget5'|'morphTarget6'|'morphTarget7'|'morphNormal0'|'morphNormal1'|'morphNormal2'|'morphNormal3' BuiltinShaderAttributeName]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CSS2DParameters">CSS2DParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="CSS3DParameters">CSS3DParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ColorRepresentation">ColorRepresentation <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:Color|string|number ColorRepresentation]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="EventListener">EventListener <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:any event] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:any event] -  The event.
		</p>
		<p>
			
		</p>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FlateCallback">FlateCallback <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:Error|string err],  [param:Uint8Array data] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:Error|string err] - Any error that occurred<br />
			[property:Uint8Array data] - The resulting data. Only present if `err` is null
		</p>
		<p>
			Callback for asynchronous (de)compression methods
		</p>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="FlateStreamHandler">FlateStreamHandler <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:Uint8Array data],  [param:boolean final] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:Uint8Array data] - The data output from the stream processor<br />
			[property:boolean final] - Whether this is the final block
		</p>
		<p>
			Handler for data (de)compression streams
		</p>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="GLTFReferenceType">GLTFReferenceType <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'materials'|'nodes'|'textures'|'meshes' GLTFReferenceType]</h3>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="PixelFormatGPU">PixelFormatGPU <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'ALPHA'|'RGB'|'RGBA'|'LUMINANCE'|'LUMINANCE_ALPHA'|'RED_INTEGER'|'R8'|'R8_SNORM'|'R8I'|'R8UI'|'R16I'|'R16UI'|'R16F'|'R32I'|'R32UI'|'R32F'|'RG8'|'RG8_SNORM'|'RG8I'|'RG8UI'|'RG16I'|'RG16UI'|'RG16F'|'RG32I'|'RG32UI'|'RG32F'|'RGB565'|'RGB8'|'RGB8_SNORM'|'RGB8I'|'RGB8UI'|'RGB16I'|'RGB16UI'|'RGB16F'|'RGB32I'|'RGB32UI'|'RGB32F'|'RGB9_E5'|'SRGB8'|'R11F_G11F_B10F'|'RGBA4'|'RGBA8'|'RGBA8_SNORM'|'RGBA8I'|'RGBA8UI'|'RGBA16I'|'RGBA16UI'|'RGBA16F'|'RGBA32I'|'RGBA32UI'|'RGBA32F'|'RGB5_A1'|'RGB10_A2'|'RGB10_A2UI'|'SRGB8_ALPHA8'|'DEPTH_COMPONENT16'|'DEPTH_COMPONENT24'|'DEPTH_COMPONENT32F'|'DEPTH24_STENCIL8'|'DEPTH32F_STENCIL8' PixelFormatGPU]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="StringStreamHandler">StringStreamHandler <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:string data],  [param:boolean final] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:string data] - The string output from the stream processor<br />
			[property:boolean final] - Whether this is the final block
		</p>
		<p>
			Handler for string generation streams
		</p>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="UnzipCallback">UnzipCallback <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:Error|string err],  [param:Unzipped data] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:Error|string err] - Any error that occurred<br />
			[property:Unzipped data] - The decompressed ZIP archive
		</p>
		<p>
			Callback for asynchronous ZIP decompression
		</p>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="UnzipFileHandler">UnzipFileHandler <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:UnzipFile file] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:UnzipFile file] - The file that was found in the archive
		</p>
		<p>
			Handler for streaming ZIP decompression
		</p>



		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRAnimationLoopCallback">XRAnimationLoopCallback <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:number time],  [param:XRFrame frame]? )</h4>
		<h4>Parameters</h4>
		<p>
			[property:number time] -  The time.<br />
			[property:XRFrame frame]? -  The frame.
		</p>
		<p>
			
		</p>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRControllerEventType">XRControllerEventType <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:XREventType|'disconnected'|'connected' XRControllerEventType]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XREnvironmentBlendMode">XREnvironmentBlendMode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'opaque'|'additive'|'alpha-blend' XREnvironmentBlendMode]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XREventType">XREventType <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'end'|'select'|'selectstart'|'selectend'|'squeeze'|'squeezestart'|'squeezeend'|'inputsourceschange' XREventType]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XREye">XREye <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'none'|'left'|'right' XREye]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRFrameRequestCallback">XRFrameRequestCallback <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:number time],  [param:XRFrame frame] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:number time] -  The time.<br />
			[property:XRFrame frame] -  The frame.
		</p>
		<p>
			
		</p>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHandModelHandedness">XRHandModelHandedness <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'left'|'right' XRHandModelHandedness]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRHandedness">XRHandedness <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'none'|'left'|'right' XRHandedness]</h3>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRReferenceSpaceType">XRReferenceSpaceType <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'viewer'|'local'|'local-floor'|'bounded-floor'|'unbounded' XRReferenceSpaceType]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRSessionMode">XRSessionMode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'inline'|'immersive-vr'|'immersive-ar' XRSessionMode]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRTargetRayMode">XRTargetRayMode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'gaze'|'tracked-pointer'|'screen' XRTargetRayMode]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="XRVisibilityState">XRVisibilityState <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'visible'|'visible-blurred'|'hidden' XRVisibilityState]</h3>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ZippableFile">ZippableFile <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:Uint8Array ZippableFile]</h3>


		<p class="desc">
			A file that can be used to create a ZIP archive
		</p>


		<p class="desc">
			Options for compressing data into a Zlib format
		</p>

		<br /><br />
		<h2>Source</h2>
		<p>[link:https://github.com/outmindkjg/ngx3js-module/tree/master/projects/ngx3js/src/lib/threejs-library/three-interface.ts /threejs-library/three-interface.ts]</p>
	</body>
</html>