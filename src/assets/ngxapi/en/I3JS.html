<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>I3JS - Namespace</h1>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IAMFLoader">IAMFLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAMFLoader IAMFLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IGroup parse](  [param:ArrayBuffer data] ) <br />
			[method:IAMFLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IAMFLoader setPath](  [param:string path] ) <br />
			[method:IAMFLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IAMFLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IAMFLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IAdaptiveToneMappingPass">IAdaptiveToneMappingPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAdaptiveToneMappingPass IAdaptiveToneMappingPass](  [param:boolean adaptive]?,  [param:number resolution]? ) - Creates an instance of ngx adaptive tone mapping pass.<br />
			[constructor:IAdaptiveToneMappingPass IAdaptiveToneMappingPass](  [param:boolean adaptive]?,  [param:number resolution]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object adaptLuminanceShader] -  The adapt luminance shader.<br />
			[property:boolean adaptive] -  The adaptive.<br />
			[property:boolean clear] -  The clear.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:IWebGLRenderTarget currentLuminanceRT] -  The current luminance r t.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IWebGLRenderTarget luminanceRT] -  The luminance r t.<br />
			[property:IShaderMaterial materialAdaptiveLum] -  The material adaptive lum.<br />
			[property:IShaderMaterial materialCopy] -  The material copy.<br />
			[property:IShaderMaterial materialLuminance] -  The material luminance.<br />
			[property:IShaderMaterial materialToneMap] -  The material tone map.<br />
			[property:number needsInit] -  The needs init.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:IWebGLRenderTarget previousLuminanceRT] -  The previous luminance r t.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:number resolution] -  The resolution.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void reset](  ) <br />
			[method:void setAdaptionRate](  [param:number rate] ) <br />
			[method:void setAdaptive](  [param:boolean adaptive] ) <br />
			[method:void setAverageLuminance](  [param:number avgLum] ) <br />
			[method:void setMaxLuminance](  [param:number maxLum] ) <br />
			[method:void setMiddleGrey](  [param:number middleGrey] ) <br />
			[method:void setMinLuminance](  [param:number minLum] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			AdaptiveToneMapping pass<br />
			See the [page:NgxAdaptiveToneMappingPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/AdaptiveToneMappingPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IAfterimagePass">IAfterimagePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAfterimagePass IAfterimagePass](  [param:number damp]? ) - Creates an instance of ngx afterimage pass.<br />
			[constructor:IAfterimagePass IAfterimagePass](  [param:number damp]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:object compFsQuad] -  The comp fs quad.<br />
			[property:object copyFsQuad] -  The copy fs quad.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object shader] -  The shader.<br />
			[property:IShaderMaterial shaderMaterial] -  The shader material.<br />
			[property:IWebGLRenderTarget textureComp] -  The texture comp.<br />
			[property:IWebGLRenderTarget textureOld] -  The texture old.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Afterimage pass<br />
			See the [page:NgxAfterimagePass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/AfterimagePass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILight] &rarr;

		<h3 id="IAmbientLight">IAmbientLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAmbientLight IAmbientLight](  [param:any color]?,  [param:number intensity]? ) <br />
			[constructor:IAmbientLight IAmbientLight](  [param:any color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:IAmbientLight IAmbientLight](  [param:any color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isAmbientLight] -  The is ambient light.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ILightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IAmbientLight add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IAmbientLight applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IAmbientLight attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IAmbientLight clear](  ) - Removes all child objects.<br />
			[method:IAmbientLight clone](  [param:boolean recursive]? ) <br />
			[method:IAmbientLight copy](  [param:IAmbientLight source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IAmbientLight remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IAmbientLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IAmbientLight rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IAmbientLight rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IAmbientLight rotateX](  [param:number angle] ) <br />
			[method:IAmbientLight rotateY](  [param:number angle] ) <br />
			[method:IAmbientLight rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IAmbientLight translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IAmbientLight translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IAmbientLight translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IAmbientLight translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			This light's color gets applied to all the objects in the scene globally.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILight] &rarr; [page:ILightProbe] &rarr;

		<h3 id="IAmbientLightProbe">IAmbientLightProbe <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAmbientLightProbe IAmbientLightProbe](  [param:ISphericalHarmonics3 sh]?,  [param:number intensity]? ) <br />
			[constructor:IAmbientLightProbe IAmbientLightProbe](  [param:ISphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:IAmbientLightProbe IAmbientLightProbe](  [param:ISphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isAmbientLightProbe] -  The is ambient light probe.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isLightProbe] -  The is light probe.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ISphericalHarmonics3 sh] -  The sh.<br />
			[property:ILightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IAmbientLightProbe add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IAmbientLightProbe applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IAmbientLightProbe attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IAmbientLightProbe clear](  ) - Removes all child objects.<br />
			[method:IAmbientLightProbe clone](  [param:boolean recursive]? ) <br />
			[method:IAmbientLightProbe copy](  [param:IAmbientLightProbe source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IAmbientLightProbe remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IAmbientLightProbe removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IAmbientLightProbe rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IAmbientLightProbe rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IAmbientLightProbe rotateX](  [param:number angle] ) <br />
			[method:IAmbientLightProbe rotateY](  [param:number angle] ) <br />
			[method:IAmbientLightProbe rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IAmbientLightProbe translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IAmbientLightProbe translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IAmbientLightProbe translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IAmbientLightProbe translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IAnimationAction">IAnimationAction <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:AnimationBlendMode blendMode] -  The blend mode.<br />
			[property:boolean clampWhenFinished] -  The clamp when finished.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:AnimationActionLoopStyles loop] -  The loop.<br />
			[property:boolean paused] -  The paused.<br />
			[property:number repetitions] -  The repetitions.<br />
			[property:number time] -  The time.<br />
			[property:number timeScale] -  The time scale.<br />
			[property:number weight] -  The weight.<br />
			[property:boolean zeroSlopeAtEnd] -  The zero slope at end.<br />
			[property:boolean zeroSlopeAtStart] -  The zero slope at start.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IAnimationAction crossFadeFrom](  [param:IAnimationAction fadeOutAction],  [param:number duration],  [param:boolean warp] ) <br />
			[method:IAnimationAction crossFadeTo](  [param:IAnimationAction fadeInAction],  [param:number duration],  [param:boolean warp] ) <br />
			[method:IAnimationAction fadeIn](  [param:number duration] ) <br />
			[method:IAnimationAction fadeOut](  [param:number duration] ) <br />
			[method:IAnimationClip getClip](  ) <br />
			[method:number getEffectiveTimeScale](  ) <br />
			[method:number getEffectiveWeight](  ) <br />
			[method:IAnimationMixer getMixer](  ) <br />
			[method:IObject3D getRoot](  ) <br />
			[method:IAnimationAction halt](  [param:number duration] ) <br />
			[method:boolean isRunning](  ) <br />
			[method:boolean isScheduled](  ) <br />
			[method:IAnimationAction play](  ) <br />
			[method:IAnimationAction reset](  ) <br />
			[method:IAnimationAction setDuration](  [param:number duration] ) <br />
			[method:IAnimationAction setEffectiveTimeScale](  [param:number timeScale] ) <br />
			[method:IAnimationAction setEffectiveWeight](  [param:number weight] ) <br />
			[method:IAnimationAction setLoop](  [param:AnimationActionLoopStyles mode],  [param:number repetitions] ) <br />
			[method:IAnimationAction startAt](  [param:number time] ) <br />
			[method:IAnimationAction stop](  ) <br />
			[method:IAnimationAction stopFading](  ) <br />
			[method:IAnimationAction stopWarping](  ) <br />
			[method:IAnimationAction syncWith](  [param:IAnimationAction action] ) <br />
			[method:IAnimationAction warp](  [param:number statTimeScale],  [param:number endTimeScale],  [param:number duration] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IAnimationClip">IAnimationClip <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAnimationClip IAnimationClip](  [param:string name]?,  [param:number duration]?,  [param:IKeyframeTrack[] tracks]?,  [param:AnimationBlendMode blendMode]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:AnimationBlendMode blendMode] -  The blend mode.<br />
			[property:number duration] -  The duration.<br />
			[property:string name] -  The name.<br />
			[property:any[] results] -  The results.<br />
			[property:IKeyframeTrack[] tracks] -  The tracks.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IAnimationClip[] CreateClipsFromMorphTargetSequences](  [param:IMorphTarget[] morphTargets],  [param:number fps],  [param:boolean noLoop] ) <br />
			[method:IAnimationClip CreateFromMorphTargetSequence](  [param:string name],  [param:IMorphTarget[] morphTargetSequence],  [param:number fps],  [param:boolean noLoop] ) <br />
			[method:IAnimationClip clone](  ) <br />
			[method:IAnimationClip findByName](  [param:IAnimationClip[] clipArray],  [param:string name] ) <br />
			[method:IAnimationClip optimize](  ) <br />
			[method:IAnimationClip parse](  [param:any json] ) <br />
			[method:IAnimationClip parseAnimation](  [param:any animation],  [param:IBone[] bones] ) <br />
			[method:IAnimationClip resetDuration](  ) <br />
			[method:any toJSON](  [param:IAnimationClip clip] ) <br />
			[method:IAnimationClip trim](  ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IAnimationLoader">IAnimationLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAnimationLoader IAnimationLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IAnimationClip[] parse](  [param:any json] ) <br />
			[method:IAnimationLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IAnimationLoader setPath](  [param:string path] ) <br />
			[method:IAnimationLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IAnimationLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IAnimationLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IAnimationMixer">IAnimationMixer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAnimationMixer IAnimationMixer](  [param:IObject3D|IAnimationObjectGroup root] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number time] -  The time.<br />
			[property:number timeScale] -  The time scale.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IAnimationAction clipAction](  [param:IAnimationClip clip],  [param:IObject3D|IAnimationObjectGroup root]?,  [param:AnimationBlendMode blendMode]? ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:IAnimationAction existingAction](  [param:IAnimationClip clip],  [param:IObject3D|IAnimationObjectGroup root]? ) <br />
			[method:IObject3D|IAnimationObjectGroup getRoot](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IAnimationMixer setTime](  [param:number timeInSeconds] ) <br />
			[method:IAnimationMixer stopAllAction](  ) <br />
			[method:void uncacheAction](  [param:IAnimationClip clip],  [param:IObject3D|IAnimationObjectGroup root]? ) <br />
			[method:void uncacheClip](  [param:IAnimationClip clip] ) <br />
			[method:void uncacheRoot](  [param:IObject3D|IAnimationObjectGroup root] ) <br />
			[method:IAnimationMixer update](  [param:number deltaTime] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IAnimationObjectGroup">IAnimationObjectGroup <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAnimationObjectGroup IAnimationObjectGroup](  [param:any[] args] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isAnimationObjectGroup] -  The is animation object group.<br />
			[property:any stats] -  The stats.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void add](  [param:any[] args] ) <br />
			[method:void remove](  [param:any[] args] ) <br />
			[method:void uncache](  [param:any[] args] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IAnimationUtils">IAnimationUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:any arraySlice](  [param:any array],  [param:number from],  [param:number to] ) <br />
			[method:any convertArray](  [param:any array],  [param:any type],  [param:boolean forceClone] ) <br />
			[method:void flattenJSON](  [param:string[] jsonKeys],  [param:any[] times],  [param:any[] values],  [param:string valuePropertyName] ) <br />
			[method:number[] getKeyFrameOrder](  [param:number[] times] ) <br />
			[method:boolean isTypedArray](  [param:any object] ) <br />
			[method:IAnimationClip makeClipAdditive](  [param:IAnimationClip targetClip],  [param:number referenceFrame]?,  [param:IAnimationClip referenceClip]?,  [param:number fps]? ) <br />
			[method:any[] sortedArray](  [param:any[] values],  [param:number stride],  [param:number[] order] ) <br />
			[method:IAnimationClip subclip](  [param:IAnimationClip sourceClip],  [param:string name],  [param:number startFrame],  [param:number endFrame],  [param:number fps]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr; [page:IEllipseCurve] &rarr;

		<h3 id="IArcCurve">IArcCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IArcCurve IArcCurve](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[constructor:IArcCurve IArcCurve](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[constructor:IArcCurve IArcCurve](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean aClockwise] -  The a clockwise.<br />
			[property:number aEndAngle] -  The a end angle.<br />
			[property:number aRotation] -  The a rotation.<br />
			[property:number aStartAngle] -  The a start angle.<br />
			[property:number aX] -  The a x.<br />
			[property:number aY] -  The a y.<br />
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:number xRadius] -  The x radius.<br />
			[property:number yRadius] -  The y radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IArcCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:IArcCurve copy](  [param:ICurve source] ) <br />
			[method:IArcCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector2|Vector2 getPoint](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getPointAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:void getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:void getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector2|Vector2 getTangent](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getTangentAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IArcballControls">IArcballControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IArcballControls IArcballControls](  [param:ICamera camera],  [param:HTMLElement domElement],  [param:IScene scene]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean adjustNearFar] -  The adjust near far.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:boolean cursorZoom] -  The cursor zoom.<br />
			[property:number dampingFactor] -  The damping factor.<br />
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:boolean enableAnimations] -  The enable animations.<br />
			[property:boolean enableGizmos] -  The enable gizmos.<br />
			[property:boolean enableGrid] -  The enable grid.<br />
			[property:boolean enablePan] -  The enable pan.<br />
			[property:boolean enableRotate] -  The enable rotate.<br />
			[property:boolean enableZoom] -  The enable zoom.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:number focusAnimationTime] -  The focus animation time.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number maxFov] -  The max fov.<br />
			[property:number maxZoom] -  The max zoom.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:number minFov] -  The min fov.<br />
			[property:number minZoom] -  The min zoom.<br />
			[property:number radiusFactor] -  The radius factor.<br />
			[property:number scaleFactor] -  The scale factor.<br />
			[property:IScene scene]? -  The scene.<br />
			[property:IVector3 target] -  The target.<br />
			[property:number wMax] -  The w max.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void activateGizmos](  [param:boolean isActive] ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void copyState](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IRaycaster getRaycaster](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void pasteState](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void reset](  ) <br />
			[method:void saveState](  ) <br />
			[method:void setCamera](  [param:ICamera camera] ) <br />
			[method:void setGizmosVisible](  [param:boolean value] ) <br />
			[method:boolean setMouseAction](  [param:EArcballControlsMouseActionOperations operation],  [param:TArcballControlsMouseActionMouse mouse],  [param:EArcballControlsMouseActionKeys key]? ) <br />
			[method:void setTarget](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:void setTbRadius](  [param:number value] ) <br />
			[method:boolean unsetMouseAction](  [param:TArcballControlsMouseActionMouse mouse],  [param:EArcballControlsMouseActionKeys key]? ) <br />
			[method:void update](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ICamera] &rarr; [page:IPerspectiveCamera] &rarr;

		<h3 id="IArrayCamera">IArrayCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IArrayCamera IArrayCamera](  [param:IPerspectiveCamera[] cameras]? ) <br />
			[constructor:IArrayCamera IArrayCamera](  [param:IPerspectiveCamera[] cameras]?,  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) <br />
			[constructor:IArrayCamera IArrayCamera](  [param:IPerspectiveCamera[] cameras]?,  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:number aspect] - Camera frustum aspect ratio, window width divided by window height.<br />
			[property:IPerspectiveCamera[] cameras] -  The cameras.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number far] - Camera frustum far plane.<br />
			[property:number filmGauge] -  The film gauge.<br />
			[property:number filmOffset] -  The film offset.<br />
			[property:number focus] -  The focus.<br />
			[property:number fov] - Camera frustum vertical field of view, from bottom to top of view, in degrees.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isArrayCamera] -  The is array camera.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isPerspectiveCamera] -  The is perspective camera.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:IMatrix4|Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:number near] - Camera frustum near plane.<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IMatrix4|Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:IMatrix4|Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:any view] -  The view.<br />
			[property:boolean visible] - Object gets rendered if true.<br />
			[property:number zoom] -  The zoom.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IArrayCamera add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IArrayCamera applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IArrayCamera attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IArrayCamera clear](  ) - Removes all child objects.<br />
			[method:void clearViewOffset](  ) <br />
			[method:IArrayCamera clone](  [param:boolean recursive]? ) <br />
			[method:IArrayCamera copy](  [param:IArrayCamera source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:number getEffectiveFOV](  ) <br />
			[method:number getFilmHeight](  ) <br />
			[method:number getFilmWidth](  ) <br />
			[method:number getFocalLength](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IArrayCamera remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IArrayCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IArrayCamera rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IArrayCamera rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IArrayCamera rotateX](  [param:number angle] ) <br />
			[method:IArrayCamera rotateY](  [param:number angle] ) <br />
			[method:IArrayCamera rotateZ](  [param:number angle] ) <br />
			[method:void setFocalLength](  [param:number focalLength] ) <br />
			[method:void setLens](  [param:number focalLength],  [param:number frameHeight]? ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:void setViewOffset](  [param:number fullWidth],  [param:number fullHeight],  [param:number x],  [param:number y],  [param:number width],  [param:number height] ) - Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.<br />
			For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:<br />
			+---+---+---+<br />
			| A | B | C |<br />
			+---+---+---+<br />
			| D | E | F |<br />
			+---+---+---+<br />
			<br />
			then for each monitor you would call it like this:<br />
			<br />
			const w = 1920;<br />
			const h = 1080;<br />
			const fullWidth = w * 3;<br />
			const fullHeight = h * 2;<br />
			<br />
			// A<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );<br />
			// B<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );<br />
			// C<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );<br />
			// D<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );<br />
			// E<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );<br />
			// F<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); Note there is no reason monitors have to be the same size or in a grid.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IArrayCamera translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IArrayCamera translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IArrayCamera translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IArrayCamera translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateProjectionMatrix](  ) - Updates the camera projection matrix. Must be called after change of parameters.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IArrowHelper">IArrowHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IArrowHelper IArrowHelper](  [param:IVector3|Vector3 dir]?,  [param:IVector3|Vector3 origin]?,  [param:number length]?,  [param:any color]?,  [param:number headLength]?,  [param:number headWidth]? ) <br />
			[constructor:IArrowHelper IArrowHelper](  [param:IVector3|Vector3 dir]?,  [param:IVector3|Vector3 origin]?,  [param:number length]?,  [param:any color]?,  [param:number headLength]?,  [param:number headWidth]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMesh cone] - Contains the cone part of the arrowHelper.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:ILine line] - Contains the line part of the arrowHelper.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IArrowHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IArrowHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IArrowHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IArrowHelper clear](  ) - Removes all child objects.<br />
			[method:IArrowHelper clone](  [param:boolean recursive]? ) <br />
			[method:IArrowHelper copy](  [param:IArrowHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IArrowHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IArrowHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IArrowHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IArrowHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IArrowHelper rotateX](  [param:number angle] ) <br />
			[method:IArrowHelper rotateY](  [param:number angle] ) <br />
			[method:IArrowHelper rotateZ](  [param:number angle] ) <br />
			[method:void setColor](  [param:any color] ) <br />
			[method:void setDirection](  [param:IVector3|Vector3 dir] ) <br />
			[method:void setLength](  [param:number length],  [param:number headLength]?,  [param:number headWidth]? ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IArrowHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IArrowHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IArrowHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IArrowHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IAsciiEffect">IAsciiEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAsciiEffect IAsciiEffect](  [param:IWebGLRenderer renderer],  [param:string charSet]?,  [param:IAsciiEffectOptions options]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IScene scene],  [param:ICamera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IAsciiEffectOptions">IAsciiEffectOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean alpha]? -  The alpha.<br />
			[property:boolean block]? -  The block.<br />
			[property:boolean color]? -  The color.<br />
			[property:boolean invert]? -  The invert.<br />
			[property:number resolution]? -  The resolution.<br />
			[property:number scale]? -  The scale.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IAttributeNode">IAttributeNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAttributeNode IAttributeNode](  [param:string name],  [param:string type]? ) <br />
			[constructor:IAttributeNode IAttributeNode](  [param:string name],  [param:string type]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IAttributeNode IAttributeNode](  [param:string name],  [param:string type]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IAttributeNode copy](  [param:IAttributeNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getAttributeType](  [param:INodeBuilder builder] ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IAttributeNode setLabel](  [param:string name] ) <br />
			[method:IAttributeNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IAudio">IAudio <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAudio IAudio](  [param:IAudioListener listener] ) <br />
			[constructor:IAudio IAudio](  [param:IAudioListener listener] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean autoplay] -  The autoplay.<br />
			[property:AudioBuffer buffer] -  The buffer.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:AudioContext context] -  The context.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number detune] -  The detune.<br />
			[property:number duration] -  The duration.<br />
			[property:AudioNode[] filters] -  The filters.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:GainNode gain] -  The gain.<br />
			[property:boolean hasPlaybackControl] -  The has playback control.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:boolean isPlaying] -  The is playing.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IAudioListener listener] -  The listener.<br />
			[property:boolean loop] -  The loop.<br />
			[property:number loopEnd] -  The loop end.<br />
			[property:number loopStart] -  The loop start.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:number offset] -  The offset.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:number playbackRate] -  The playback rate.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:AudioBufferSourceNode source] -  The source.<br />
			[property:string sourceType] -  The source type.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IAudio add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IAudio applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IAudio attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IAudio clear](  ) - Removes all child objects.<br />
			[method:IAudio clone](  [param:boolean recursive]? ) <br />
			[method:IAudio connect](  ) <br />
			[method:IAudio copy](  [param:IAudio source],  [param:boolean recursive]? ) <br />
			[method:IAudio disconnect](  ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:number getDetune](  ) <br />
			[method:AudioNode getFilter](  ) <br />
			[method:AudioNode[] getFilters](  ) <br />
			[method:boolean getLoop](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:NodeType getOutput](  ) <br />
			[method:number getPlaybackRate](  ) <br />
			[method:number getVolume](  ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IAudio load](  [param:string file] ) <br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void onEnded](  ) <br />
			[method:IAudio pause](  ) <br />
			[method:IAudio play](  [param:number delay]? ) <br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IAudio remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IAudio removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IAudio rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IAudio rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IAudio rotateX](  [param:number angle] ) <br />
			[method:IAudio rotateY](  [param:number angle] ) <br />
			[method:IAudio rotateZ](  [param:number angle] ) <br />
			[method:IAudio setBuffer](  [param:AudioBuffer audioBuffer] ) <br />
			[method:IAudio setDetune](  [param:number value] ) <br />
			[method:IAudio setFilter](  [param:AudioNode filter] ) <br />
			[method:IAudio setFilters](  [param:AudioNode[] value] ) <br />
			[method:IAudio setLoop](  [param:boolean value] ) <br />
			[method:IAudio setLoopEnd](  [param:number value] ) <br />
			[method:IAudio setLoopStart](  [param:number value] ) <br />
			[method:IAudio setMediaElementSource](  [param:HTMLMediaElement mediaElement] ) <br />
			[method:IAudio setMediaStreamSource](  [param:MediaStream mediaStream] ) <br />
			[method:IAudio setNodeSource](  [param:AudioBufferSourceNode audioNode] ) <br />
			[method:IAudio setPlaybackRate](  [param:number value] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IAudio setVolume](  [param:number value] ) <br />
			[method:IAudio stop](  ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IAudio translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IAudio translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IAudio translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IAudio translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IAudioAnalyser">IAudioAnalyser <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAudioAnalyser IAudioAnalyser](  [param:IAudio audio],  [param:number fftSize]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:AnalyserNode analyser] -  The analyser.<br />
			[property:Uint8Array data] -  The data.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number getAverageFrequency](  ) <br />
			[method:Uint8Array getFrequencyData](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IAudioListener">IAudioListener <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAudioListener IAudioListener](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:AudioContext context] -  The context.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:any filter] -  The filter.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:GainNode gain] -  The gain.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:number timeDelta] -  The time delta.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IAudioListener add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IAudioListener applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IAudioListener attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IAudioListener clear](  ) - Removes all child objects.<br />
			[method:IAudioListener clone](  [param:boolean recursive]? ) <br />
			[method:IAudioListener copy](  [param:IAudioListener source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:any getFilter](  ) <br />
			[method:GainNode getInput](  ) <br />
			[method:number getMasterVolume](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IAudioListener remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IAudioListener removeFilter](  ) <br />
			[method:IAudioListener removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IAudioListener rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IAudioListener rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IAudioListener rotateX](  [param:number angle] ) <br />
			[method:IAudioListener rotateY](  [param:number angle] ) <br />
			[method:IAudioListener rotateZ](  [param:number angle] ) <br />
			[method:IAudioListener setFilter](  [param:any value] ) <br />
			[method:IAudioListener setMasterVolume](  [param:number value] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IAudioListener translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IAudioListener translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IAudioListener translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IAudioListener translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IAudioLoader">IAudioLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAudioLoader IAudioLoader](  [param:ILoadingManager manager]? ) <br />
			[constructor:IAudioLoader IAudioLoader](  [param:ILoadingManager manager]?,  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]?,  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]?,  [param:string url],  [param:any onProgress]? ) <br />
			[method:IAudioLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IAudioLoader setPath](  [param:string path] ) <br />
			[method:IAudioLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IAudioLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IAudioLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IAudioManager">IAudioManager <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAudioManager IAudioManager](  [param:IAudio audio],  [param:IAudioManagerParameter params]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAudio audio] -  The audio.<br />
			[property:number audioDuration] -  The audio duration.<br />
			[property:number currentTime] -  The current time.<br />
			[property:number delayTime] -  The delay time.<br />
			[property:number duration] -  The duration.<br />
			[property:number elapsedTime] -  The elapsed time.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IAudioManager control](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IAudioManagerParameter">IAudioManagerParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number delayTime]? -  The delay time.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="IAxesHelper">IAxesHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IAxesHelper IAxesHelper](  [param:number size]? ) <br />
			[constructor:IAxesHelper IAxesHelper](  [param:number size]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IAxesHelper IAxesHelper](  [param:number size]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IAxesHelper IAxesHelper](  [param:number size]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IAxesHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IAxesHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IAxesHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IAxesHelper clear](  ) - Removes all child objects.<br />
			[method:IAxesHelper clone](  [param:boolean recursive]? ) <br />
			[method:IAxesHelper computeLineDistances](  ) <br />
			[method:IAxesHelper copy](  [param:IAxesHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IAxesHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IAxesHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IAxesHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IAxesHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IAxesHelper rotateX](  [param:number angle] ) <br />
			[method:IAxesHelper rotateY](  [param:number angle] ) <br />
			[method:IAxesHelper rotateZ](  [param:number angle] ) <br />
			[method:IAxesHelper setColors](  [param:IColor xAxisColor],  [param:IColor yAxisColor],  [param:IColor zAxisColor] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IAxesHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IAxesHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IAxesHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IAxesHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IBVH">IBVH <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip clip] -  The clip.<br />
			[property:ISkeleton skeleton] -  The skeleton.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IBVHLoader">IBVHLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBVHLoader IBVHLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean animateBonePositions] -  The animate bone positions.<br />
			[property:boolean animateBoneRotations] -  The animate bone rotations.<br />
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IBVH parse](  [param:string text] ) <br />
			[method:IBVHLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IBVHLoader setPath](  [param:string path] ) <br />
			[method:IBVHLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IBVHLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IBVHLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IBaseEvent">IBaseEvent <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr;

		<h3 id="IBasicNode">IBasicNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBasicNode IBasicNode](  ) <br />
			[constructor:IBasicNode IBasicNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode alpha] -  The alpha.<br />
			[property:INode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:INode mask] -  The mask.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:INode position] -  The position.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder] ) <br />
			[method:IBasicNode copy](  [param:IBasicNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:IBasicNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr; [page:INodeMaterial] &rarr;

		<h3 id="IBasicNodeMaterial">IBasicNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBasicNodeMaterial IBasicNodeMaterial](  ) <br />
			[constructor:IBasicNodeMaterial IBasicNodeMaterial](  [param:INode vertex],  [param:INode fragment] ) <br />
			[constructor:IBasicNodeMaterial IBasicNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:IBasicNodeMaterial IBasicNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode alpha] -  The alpha.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:INode color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:INode|IRawNode fragment] -  The fragment.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:INode mask] -  The mask.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:INode position] -  The position.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:object properties] -  The properties.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:INode|IRawNode vertex] -  The vertex.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IBasicNodeMaterial build](  [param:INodeMaterialBuildParams params]? ) <br />
			[method:IBasicNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IBasicNodeMaterial copy](  [param:INodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IBasisTextureLoader">IBasisTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBasisTextureLoader IBasisTextureLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:ArrayBuffer transcoderBinary] -  The transcoder binary.<br />
			[property:string transcoderPath] -  The transcoder path.<br />
			[property:Promise transcoderPending] -  The transcoder pending.<br />
			[property:boolean withCredentials] -  The with credentials.<br />
			[property:any workerConfig] -  The worker config.<br />
			[property:number workerLimit] -  The worker limit.<br />
			[property:number workerNextTaskID] -  The worker next task i d.<br />
			[property:object[] workerPool] -  The worker pool.<br />
			[property:string workerSourceURL] -  The worker source u r l.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBasisTextureLoader detectSupport](  [param:IWebGLRenderer renderer] ) <br />
			[method:void dispose](  ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IBasisTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IBasisTextureLoader setPath](  [param:string path] ) <br />
			[method:IBasisTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IBasisTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IBasisTextureLoader setTranscoderPath](  [param:string path] ) <br />
			[method:IBasisTextureLoader setWithCredentials](  [param:boolean value] ) <br />
			[method:IBasisTextureLoader setWorkerLimit](  [param:number workerLimit] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IBloomPass">IBloomPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBloomPass IBloomPass](  [param:number strength]?,  [param:number kernelSize]?,  [param:number sigma]?,  [param:number resolution]? ) - Creates an instance of ngx bloom pass.<br />
			[constructor:IBloomPass IBloomPass](  [param:number strength]?,  [param:number kernelSize]?,  [param:number sigma]?,  [param:number resolution]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:object convolutionUniforms] -  The convolution uniforms.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial materialConvolution] -  The material convolution.<br />
			[property:IShaderMaterial materialCopy] -  The material copy.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:IWebGLRenderTarget renderTargetX] -  The render target x.<br />
			[property:IWebGLRenderTarget renderTargetY] -  The render target y.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Bloom pass<br />
			See the [page:NgxBloomPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/BloomPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IBlurNode">IBlurNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBlurNode IBlurNode](  [param:ITextureNode value],  [param:IUVNode uv]?,  [param:number radius]?,  [param:IVector2 size]? ) <br />
			[constructor:IBlurNode IBlurNode](  [param:ITextureNode value],  [param:IUVNode uv]?,  [param:number radius]?,  [param:IVector2 size]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IBlurNode IBlurNode](  [param:ITextureNode value],  [param:IUVNode uv]?,  [param:number radius]?,  [param:IVector2 size]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:boolean blurX] -  The blur x.<br />
			[property:boolean blurY] -  The blur y.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:IFloatNode horizontal] -  The horizontal.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:IVector2Node radius] -  The radius.<br />
			[property:boolean shared] -  The shared.<br />
			[property:IVector2 size] -  The size.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IUVNode uv] -  The uv.<br />
			[property:ITextureNode value] -  The value.<br />
			[property:IFloatNode vertical] -  The vertical.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IBlurNode copy](  [param:IBlurNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IBlurNode setLabel](  [param:string name] ) <br />
			[method:IBlurNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IBokehPass">IBokehPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBokehPass IBokehPass](  [param:IScene scene],  [param:ICamera camera],  [param:IBokehPassParamters params] ) - Creates an instance of ngx bokeh pass.<br />
			[constructor:IBokehPass IBokehPass](  [param:IScene scene],  [param:ICamera camera],  [param:IBokehPassParamters params] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ICamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial materialBokeh] -  The material bokeh.<br />
			[property:IMeshDepthMaterial materialDepth] -  The material depth.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:IColor oldClearColor] -  The old clear color.<br />
			[property:IWebGLRenderTarget renderTargetColor] -  The render target color.<br />
			[property:IWebGLRenderTarget renderTargetDepth] -  The render target depth.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IScene scene] -  The scene.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Bokeh pass<br />
			See the [page:NgxBokehPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/BokehPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IBokehPassParamters">IBokehPassParamters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number aperture]? -  The aperture.<br />
			[property:number aspect]? -  The aspect.<br />
			[property:number focus]? -  The focus.<br />
			[property:number height]? -  The height.<br />
			[property:number maxblur]? -  The maxblur.<br />
			[property:number width]? -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IBone">IBone <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBone IBone](  ) <br />
			[constructor:IBone IBone](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isBone] -  The is bone.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBone add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IBone applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IBone attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IBone clear](  ) - Removes all child objects.<br />
			[method:IBone clone](  [param:boolean recursive]? ) <br />
			[method:IBone copy](  [param:IBone source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IBone remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBone removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IBone rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IBone rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IBone rotateX](  [param:number angle] ) <br />
			[method:IBone rotateY](  [param:number angle] ) <br />
			[method:IBone rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IBone translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IBone translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IBone translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IBone translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IBoolNode">IBoolNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBoolNode IBoolNode](  [param:boolean value]? ) <br />
			[constructor:IBoolNode IBoolNode](  [param:boolean value]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IBoolNode IBoolNode](  [param:boolean value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IBoolNode IBoolNode](  [param:boolean value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IBoolNode copy](  [param:IBoolNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IBoolNode setLabel](  [param:string name] ) <br />
			[method:IBoolNode setName](  [param:string name] ) <br />
			[method:IBoolNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IKeyframeTrack] &rarr;

		<h3 id="IBooleanKeyframeTrack">IBooleanKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBooleanKeyframeTrack IBooleanKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:ILinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:ICubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:IBooleanKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:IKeyframeTrack optimize](  ) <br />
			[method:IKeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:IKeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:IKeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:IKeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IBox2">IBox2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBox2 IBox2](  [param:IVector2|Vector2 min]?,  [param:IVector2|Vector2 max]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IVector2 max] -  The max.<br />
			[property:IVector2 min] -  The min.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IVector2 clampPoint](  [param:IVector2|Vector2 point],  [param:IVector2|Vector2 target] ) <br />
			[method:IBox2 clone](  ) <br />
			[method:boolean containsBox](  [param:IBox2 box] ) <br />
			[method:boolean containsPoint](  [param:IVector2|Vector2 point] ) <br />
			[method:IBox2 copy](  [param:IBox2 box] ) <br />
			[method:number distanceToPoint](  [param:IVector2|Vector2 point] ) <br />
			[method:boolean equals](  [param:IBox2 box] ) <br />
			[method:IBox2 expandByPoint](  [param:IVector2|Vector2 point] ) <br />
			[method:IBox2 expandByScalar](  [param:number scalar] ) <br />
			[method:IBox2 expandByVector](  [param:IVector2|Vector2 vector] ) <br />
			[method:IVector2 getCenter](  [param:IVector2|Vector2 target] ) <br />
			[method:IVector2 getParameter](  [param:IVector2|Vector2 point],  [param:IVector2|Vector2 target] ) <br />
			[method:IVector2 getSize](  [param:IVector2|Vector2 target] ) <br />
			[method:IBox2 intersect](  [param:IBox2 box] ) <br />
			[method:boolean intersectsBox](  [param:IBox2 box] ) <br />
			[method:boolean isEmpty](  ) <br />
			[method:IBox2 makeEmpty](  ) <br />
			[method:IBox2 set](  [param:IVector2|Vector2 min],  [param:IVector2|Vector2 max] ) <br />
			[method:IBox2 setFromCenterAndSize](  [param:IVector2|Vector2 center],  [param:IVector2|Vector2 size] ) <br />
			[method:IBox2 setFromPoints](  [param:any points] ) <br />
			[method:IBox2 translate](  [param:IVector2|Vector2 offset] ) <br />
			[method:IBox2 union](  [param:IBox2 box] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IBox3">IBox3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBox3 IBox3](  [param:IVector3|Vector3 min]?,  [param:IVector3|Vector3 max]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isBox3] -  The is box3.<br />
			[property:IVector3 max] -  The max.<br />
			[property:IVector3 min] -  The min.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBox3 applyMatrix4](  [param:IMatrix4 matrix] ) <br />
			[method:IVector3 clampPoint](  [param:IVector3|Vector3 point],  [param:IVector3|Vector3 target] ) <br />
			[method:IBox3 clone](  ) <br />
			[method:boolean containsBox](  [param:IBox3 box] ) <br />
			[method:boolean containsPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:IBox3 copy](  [param:IBox3 box] ) <br />
			[method:number distanceToPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:any empty](  ) <br />
			[method:boolean equals](  [param:IBox3 box] ) <br />
			[method:IBox3 expandByObject](  [param:IObject3D object] ) <br />
			[method:IBox3 expandByPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:IBox3 expandByScalar](  [param:number scalar] ) <br />
			[method:IBox3 expandByVector](  [param:IVector3|Vector3 vector] ) <br />
			[method:ISphere getBoundingSphere](  [param:ISphere target] ) <br />
			[method:IVector3 getCenter](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getParameter](  [param:IVector3|Vector3 point],  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getSize](  [param:IVector3|Vector3 target] ) <br />
			[method:IBox3 intersect](  [param:IBox3 box] ) <br />
			[method:boolean intersectsBox](  [param:IBox3 box] ) <br />
			[method:boolean intersectsPlane](  [param:IPlane plane] ) <br />
			[method:boolean intersectsSphere](  [param:ISphere sphere] ) <br />
			[method:boolean intersectsTriangle](  [param:ITriangle triangle] ) <br />
			[method:boolean isEmpty](  ) <br />
			[method:any isIntersectionBox](  [param:any b] ) <br />
			[method:any isIntersectionSphere](  [param:any s] ) <br />
			[method:IBox3 makeEmpty](  ) <br />
			[method:IBox3 set](  [param:IVector3|Vector3 min],  [param:IVector3|Vector3 max] ) <br />
			[method:IBox3 setFromArray](  [param:ArrayLike array] ) <br />
			[method:IBox3 setFromBufferAttribute](  [param:IBufferAttribute bufferAttribute] ) <br />
			[method:IBox3 setFromCenterAndSize](  [param:IVector3|Vector3 center],  [param:IVector3|Vector3 size] ) <br />
			[method:IBox3 setFromObject](  [param:IObject3D object] ) <br />
			[method:IBox3 setFromPoints](  [param:any points] ) <br />
			[method:IBox3 translate](  [param:IVector3|Vector3 offset] ) <br />
			[method:IBox3 union](  [param:IBox3 box] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="IBox3Helper">IBox3Helper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBox3Helper IBox3Helper](  [param:IBox3 box],  [param:IColor color]? ) <br />
			[constructor:IBox3Helper IBox3Helper](  [param:IBox3 box],  [param:IColor color]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IBox3Helper IBox3Helper](  [param:IBox3 box],  [param:IColor color]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IBox3Helper IBox3Helper](  [param:IBox3 box],  [param:IColor color]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:IBox3 box] -  The box.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBox3Helper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IBox3Helper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IBox3Helper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IBox3Helper clear](  ) - Removes all child objects.<br />
			[method:IBox3Helper clone](  [param:boolean recursive]? ) <br />
			[method:IBox3Helper computeLineDistances](  ) <br />
			[method:IBox3Helper copy](  [param:IBox3Helper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IBox3Helper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBox3Helper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IBox3Helper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IBox3Helper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IBox3Helper rotateX](  [param:number angle] ) <br />
			[method:IBox3Helper rotateY](  [param:number angle] ) <br />
			[method:IBox3Helper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IBox3Helper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IBox3Helper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IBox3Helper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IBox3Helper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IBoxGeometry">IBoxGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBoxGeometry IBoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) <br />
			[constructor:IBoxGeometry IBoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IBoxGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="IBoxHelper">IBoxHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBoxHelper IBoxHelper](  [param:IObject3D object],  [param:any color]? ) <br />
			[constructor:IBoxHelper IBoxHelper](  [param:IObject3D object],  [param:any color]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IBoxHelper IBoxHelper](  [param:IObject3D object],  [param:any color]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IBoxHelper IBoxHelper](  [param:IObject3D object],  [param:any color]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBoxHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IBoxHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IBoxHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IBoxHelper clear](  ) - Removes all child objects.<br />
			[method:IBoxHelper clone](  [param:boolean recursive]? ) <br />
			[method:IBoxHelper computeLineDistances](  ) <br />
			[method:IBoxHelper copy](  [param:IBoxHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IBoxHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBoxHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IBoxHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IBoxHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IBoxHelper rotateX](  [param:number angle] ) <br />
			[method:IBoxHelper rotateY](  [param:number angle] ) <br />
			[method:IBoxHelper rotateZ](  [param:number angle] ) <br />
			[method:IBoxHelper setFromObject](  [param:IObject3D object] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IBoxHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IBoxHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IBoxHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IBoxHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  [param:IObject3D object]? ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IBoxLineGeometry">IBoxLineGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBoxLineGeometry IBoxLineGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) <br />
			[constructor:IBoxLineGeometry IBoxLineGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IBoxLineGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IBufferAttribute">IBufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBufferAttribute IBufferAttribute](  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IBufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IBufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IBufferAttribute clone](  ) <br />
			[method:IBufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IBufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IBufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IBufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IBufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IBufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IBufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IBufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IBufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IBufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IBufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IBufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IBufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IBufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IBufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IBufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IBufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IBufferGeometry">IBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBufferGeometry IBufferGeometry](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IBufferGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			This is a superefficent class for geometries because it saves all data in buffers.<br />
			It reduces memory costs and cpu cycles. But it is not as easy to work with because of all the necessary buffer calculations.<br />
			It is mainly interesting when working with static objects.<br />
			see {@link https://github.com/mrdoob/three.js/blob/master/src/core/BufferGeometry.js|src/core/BufferGeometry.js}
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IBufferGeometryLoader">IBufferGeometryLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBufferGeometryLoader IBufferGeometryLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IBufferGeometry|IInstancedBufferGeometry parse](  [param:any json] ) <br />
			[method:IBufferGeometryLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IBufferGeometryLoader setPath](  [param:string path] ) <br />
			[method:IBufferGeometryLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IBufferGeometryLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IBufferGeometryLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IBumpMapNode">IBumpMapNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBumpMapNode IBumpMapNode](  [param:ITextureNode value],  [param:IFloatNode scale]? ) <br />
			[constructor:IBumpMapNode IBumpMapNode](  [param:ITextureNode value],  [param:IFloatNode scale]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IBumpMapNode IBumpMapNode](  [param:ITextureNode value],  [param:IFloatNode scale]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:IFloatNode scale] -  The scale.<br />
			[property:boolean shared] -  The shared.<br />
			[property:boolean toNormalMap] -  The to normal map.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:ITextureNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IBumpMapNode copy](  [param:IBumpMapNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IBumpMapNode setLabel](  [param:string name] ) <br />
			[method:IBumpMapNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr;

		<h3 id="IBypassNode">IBypassNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IBypassNode IBypassNode](  [param:INode code],  [param:INode value]? ) <br />
			[constructor:IBypassNode IBypassNode](  [param:INode code],  [param:INode value]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode code] -  The code.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:INode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:IBypassNode copy](  [param:IBypassNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:IBypassNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ICCDIKHelper">ICCDIKHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICCDIKHelper ICCDIKHelper](  [param:ISkinnedMesh mesh],  [param:IIKS[] iks] ) <br />
			[constructor:ICCDIKHelper ICCDIKHelper](  [param:ISkinnedMesh mesh],  [param:IIKS[] iks] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICCDIKHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ICCDIKHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ICCDIKHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ICCDIKHelper clear](  ) - Removes all child objects.<br />
			[method:ICCDIKHelper clone](  [param:boolean recursive]? ) <br />
			[method:ICCDIKHelper copy](  [param:ICCDIKHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ICCDIKHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ICCDIKHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ICCDIKHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ICCDIKHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ICCDIKHelper rotateX](  [param:number angle] ) <br />
			[method:ICCDIKHelper rotateY](  [param:number angle] ) <br />
			[method:ICCDIKHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ICCDIKHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ICCDIKHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ICCDIKHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ICCDIKHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ICCDIKSolver">ICCDIKSolver <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICCDIKSolver ICCDIKSolver](  [param:ISkinnedMesh mesh],  [param:IIKS[] iks] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICCDIKHelper createHelper](  ) <br />
			[method:ICCDIKSolver update](  ) <br />
			[method:ICCDIKSolver updateOne](  [param:IIKS iks] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ICSM">ICSM <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICSM ICSM](  [param:any data] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any[] breaks] -  The breaks.<br />
			[property:any camera] -  The camera.<br />
			[property:any cascades] -  The cascades.<br />
			[property:any customSplitsCallback] -  The custom splits callback.<br />
			[property:boolean fade] -  The fade.<br />
			[property:any[] frustums] -  The frustums.<br />
			[property:any lightDirection] -  The light direction.<br />
			[property:any lightFar] -  The light far.<br />
			[property:any lightIntensity] -  The light intensity.<br />
			[property:any lightMargin] -  The light margin.<br />
			[property:any lightNear] -  The light near.<br />
			[property:any[] lights] -  The lights.<br />
			[property:IFrustum mainFrustum] -  The main frustum.<br />
			[property:any maxFar] -  The max far.<br />
			[property:any mode] -  The mode.<br />
			[property:any parent] -  The parent.<br />
			[property:Map shaders] -  The shaders.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowMapSize] -  The shadow map size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void createLights](  ) <br />
			[method:void dispose](  ) <br />
			[method:void getBreaks](  ) <br />
			[method:void getExtendedBreaks](  [param:any target] ) <br />
			[method:void initCascades](  ) <br />
			[method:void injectInclude](  ) <br />
			[method:void remove](  ) <br />
			[method:void setupMaterial](  [param:any material] ) <br />
			[method:void update](  ) <br />
			[method:void updateFrustums](  ) <br />
			[method:void updateShadowBounds](  ) <br />
			[method:void updateUniforms](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ICSMHelper">ICSMHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICSMHelper ICSMHelper](  [param:any csm] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any[] cascadeLines] -  The cascade lines.<br />
			[property:any[] cascadePlanes] -  The cascade planes.<br />
			[property:any csm] -  The csm.<br />
			[property:boolean displayFrustum] -  The display frustum.<br />
			[property:boolean displayPlanes] -  The display planes.<br />
			[property:boolean displayShadowBounds] -  The display shadow bounds.<br />
			[property:any frustumLines] -  The frustum lines.<br />
			[property:any[] shadowLines] -  The shadow lines.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void update](  ) <br />
			[method:void updateVisibility](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ICSS2DObject">ICSS2DObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICSS2DObject ICSS2DObject](  [param:HTMLElement element] ) <br />
			[constructor:ICSS2DObject ICSS2DObject](  [param:HTMLElement element] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:HTMLElement element] -  The element.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICSS2DObject add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ICSS2DObject applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ICSS2DObject attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ICSS2DObject clear](  ) - Removes all child objects.<br />
			[method:ICSS2DObject clone](  [param:boolean recursive]? ) <br />
			[method:ICSS2DObject copy](  [param:ICSS2DObject source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:unknown renderer],  [param:IScene scene],  [param:ICamera camera] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:unknown renderer],  [param:IScene scene],  [param:ICamera camera] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ICSS2DObject remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ICSS2DObject removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ICSS2DObject rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ICSS2DObject rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ICSS2DObject rotateX](  [param:number angle] ) <br />
			[method:ICSS2DObject rotateY](  [param:number angle] ) <br />
			[method:ICSS2DObject rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ICSS2DObject translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ICSS2DObject translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ICSS2DObject translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ICSS2DObject translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ICSS2DRenderer">ICSS2DRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICSS2DRenderer ICSS2DRenderer](  [param:TCSS2DParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void getSize](  ) <br />
			[method:void render](  [param:IScene scene],  [param:ICamera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ICSS3DObject">ICSS3DObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICSS3DObject ICSS3DObject](  [param:HTMLElement element] ) <br />
			[constructor:ICSS3DObject ICSS3DObject](  [param:HTMLElement element] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:HTMLElement element] -  The element.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICSS3DObject add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ICSS3DObject applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ICSS3DObject attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ICSS3DObject clear](  ) - Removes all child objects.<br />
			[method:ICSS3DObject clone](  [param:boolean recursive]? ) <br />
			[method:ICSS3DObject copy](  [param:ICSS3DObject source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:unknown renderer],  [param:IScene scene],  [param:ICamera camera] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:unknown renderer],  [param:IScene scene],  [param:ICamera camera] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ICSS3DObject remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ICSS3DObject removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ICSS3DObject rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ICSS3DObject rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ICSS3DObject rotateX](  [param:number angle] ) <br />
			[method:ICSS3DObject rotateY](  [param:number angle] ) <br />
			[method:ICSS3DObject rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ICSS3DObject translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ICSS3DObject translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ICSS3DObject translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ICSS3DObject translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ICSS3DRenderer">ICSS3DRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICSS3DRenderer ICSS3DRenderer](  [param:TCSS3DParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void getSize](  ) <br />
			[method:void render](  [param:IScene scene],  [param:ICamera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ICSS3DObject] &rarr;

		<h3 id="ICSS3DSprite">ICSS3DSprite <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICSS3DSprite ICSS3DSprite](  [param:HTMLElement element] ) <br />
			[constructor:ICSS3DSprite ICSS3DSprite](  [param:HTMLElement element],  [param:HTMLElement element] ) <br />
			[constructor:ICSS3DSprite ICSS3DSprite](  [param:HTMLElement element],  [param:HTMLElement element] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:HTMLElement element] -  The element.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICSS3DSprite add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ICSS3DSprite applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ICSS3DSprite attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ICSS3DSprite clear](  ) - Removes all child objects.<br />
			[method:ICSS3DSprite clone](  [param:boolean recursive]? ) <br />
			[method:ICSS3DSprite copy](  [param:ICSS3DSprite source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:unknown renderer],  [param:IScene scene],  [param:ICamera camera] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:unknown renderer],  [param:IScene scene],  [param:ICamera camera] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ICSS3DSprite remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ICSS3DSprite removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ICSS3DSprite rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ICSS3DSprite rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ICSS3DSprite rotateX](  [param:number angle] ) <br />
			[method:ICSS3DSprite rotateY](  [param:number angle] ) <br />
			[method:ICSS3DSprite rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ICSS3DSprite translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ICSS3DSprite translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ICSS3DSprite translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ICSS3DSprite translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ICamera">ICamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICamera ICamera](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:IMatrix4|Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IMatrix4|Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:IMatrix4|Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICamera add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ICamera applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ICamera attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ICamera clear](  ) - Removes all child objects.<br />
			[method:ICamera clone](  [param:boolean recursive]? ) <br />
			[method:ICamera copy](  [param:ICamera source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ICamera remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ICamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ICamera rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ICamera rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ICamera rotateX](  [param:number angle] ) <br />
			[method:ICamera rotateY](  [param:number angle] ) <br />
			[method:ICamera rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ICamera translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ICamera translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ICamera translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ICamera translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			Abstract base class for cameras. This class should always be inherited when you build a new camera.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="ICameraHelper">ICameraHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICameraHelper ICameraHelper](  [param:ICamera camera] ) <br />
			[constructor:ICameraHelper ICameraHelper](  [param:ICamera camera],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:ICameraHelper ICameraHelper](  [param:ICamera camera],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:ICameraHelper ICameraHelper](  [param:ICamera camera],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:any pointMap] -  The point map.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICameraHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ICameraHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ICameraHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ICameraHelper clear](  ) - Removes all child objects.<br />
			[method:ICameraHelper clone](  [param:boolean recursive]? ) <br />
			[method:ICameraHelper computeLineDistances](  ) <br />
			[method:ICameraHelper copy](  [param:ICameraHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ICameraHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ICameraHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ICameraHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ICameraHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ICameraHelper rotateX](  [param:number angle] ) <br />
			[method:ICameraHelper rotateY](  [param:number angle] ) <br />
			[method:ICameraHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ICameraHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ICameraHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ICameraHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ICameraHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="ICameraNode">ICameraNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICameraNode ICameraNode](  [param:string scope]?,  [param:ICamera camera]? ) <br />
			[constructor:ICameraNode ICameraNode](  [param:string scope]?,  [param:ICamera camera]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ICameraNode ICameraNode](  [param:string scope]?,  [param:ICamera camera]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string DEPTH] -  The d e p t h.<br />
			[property:any Nodes] -  The nodes.<br />
			[property:string POSITION] -  The p o s i t i o n.<br />
			[property:string TO_VERTEX] -  The t o_ v e r t e x.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:IFloatNode far] -  The far.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:IFloatNode near] -  The near.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean updateFrame] -  The update frame.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ICameraNode copy](  [param:ICameraNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void onUpdateFrame](  [param:INodeFrame frame] ) <br />
			[method:void setCamera](  [param:ICamera camera] ) <br />
			[method:ICameraNode setLabel](  [param:string name] ) <br />
			[method:ICameraNode setName](  [param:string name] ) <br />
			[method:void setScope](  [param:string scope] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:ITexture] &rarr;

		<h3 id="ICanvasTexture">ICanvasTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICanvasTexture ICanvasTexture](  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement|ImageBitmap canvas],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]? ) <br />
			[constructor:ICanvasTexture ICanvasTexture](  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement|ImageBitmap canvas],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isCanvasTexture] -  The is canvas texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ICanvasTexture clone](  ) <br />
			[method:ICanvasTexture copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ICapsule">ICapsule <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICapsule ICapsule](  [param:IVector3 start]?,  [param:IVector3 end]?,  [param:number radius]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IVector3 end] -  The end.<br />
			[property:number radius] -  The radius.<br />
			[property:IVector3 start] -  The start.
		</p>
		<h4>Methods</h4>
		<p>
			[method:boolean checkAABBAxis](  [param:number p1x],  [param:number p1y],  [param:number p2x],  [param:number p2y],  [param:number minx],  [param:number maxx],  [param:number miny],  [param:number maxy],  [param:number radius] ) <br />
			[method:ICapsule clone](  ) <br />
			[method:ICapsule copy](  [param:ICapsule capsule] ) <br />
			[method:IVector3 getCenter](  [param:number target] ) <br />
			[method:boolean intersectsBox](  [param:IBox3 box] ) <br />
			[method:IVector3[] lineLineMinimumPoints](  [param:ILine3 line1],  [param:ILine3 line2] ) <br />
			[method:ICapsule set](  [param:IVector3 start],  [param:IVector3 end],  [param:number radius] ) <br />
			[method:ICapsule translate](  [param:IVector3 v] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ICapsuleGeometry">ICapsuleGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICapsuleGeometry ICapsuleGeometry](  [param:number radius]?,  [param:number radiusSegments]?,  [param:number height]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]? ) <br />
			[constructor:ICapsuleGeometry ICapsuleGeometry](  [param:number radius]?,  [param:number radiusSegments]?,  [param:number height]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] - The Parameters of capsule geometry<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ICapsuleGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			The Capsule geometry.<br />
			See the [page:NgxCapsuleGeometry ngx3js docs] page for details.<br />
			See the [example:ngx_geometry/CapsuleGeometry ngx geometey] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="ICatmullRomCurve3">ICatmullRomCurve3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICatmullRomCurve3 ICatmullRomCurve3](  [param:any points]?,  [param:boolean closed]?,  [param:string curveType]?,  [param:number tension]? ) <br />
			[constructor:ICatmullRomCurve3 ICatmullRomCurve3](  [param:any points]?,  [param:boolean closed]?,  [param:string curveType]?,  [param:number tension]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:any points] -  The points.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICatmullRomCurve3 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ICatmullRomCurve3 copy](  [param:ICurve source] ) <br />
			[method:ICatmullRomCurve3 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector3 getPoint](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getPointAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:IVector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:IVector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector3 getTangent](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getTangentAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="ICheckerNode">ICheckerNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICheckerNode ICheckerNode](  [param:IUVNode|IUVTransformNode uv]? ) <br />
			[constructor:ICheckerNode ICheckerNode](  [param:IUVNode|IUVTransformNode uv]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ICheckerNode ICheckerNode](  [param:IUVNode|IUVTransformNode uv]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IUVNode|IUVTransformNode uv] -  The uv.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ICheckerNode copy](  [param:ICheckerNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ICheckerNode setLabel](  [param:string name] ) <br />
			[method:ICheckerNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IChunk">IChunk <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Uint8Array data] -  The data.<br />
			[property:number[] palette] -  The palette.<br />
			[property:any size] -  The size.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ICamera] &rarr; [page:IPerspectiveCamera] &rarr;

		<h3 id="ICinematicCamera">ICinematicCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICinematicCamera ICinematicCamera](  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far] ) <br />
			[constructor:ICinematicCamera ICinematicCamera](  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far],  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) <br />
			[constructor:ICinematicCamera ICinematicCamera](  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far],  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:number aperture] -  The aperture.<br />
			[property:number aspect] - Camera frustum aspect ratio, window width divided by window height.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:number coc] -  The coc.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number fNumber] -  The f number.<br />
			[property:number far] - Camera frustum far plane.<br />
			[property:number filmGauge] -  The film gauge.<br />
			[property:number filmOffset] -  The film offset.<br />
			[property:number focus] -  The focus.<br />
			[property:number fov] - Camera frustum vertical field of view, from bottom to top of view, in degrees.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number hyperFocal] -  The hyper focal.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isPerspectiveCamera] -  The is perspective camera.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IShaderMaterial materialDepth] -  The material depth.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:IMatrix4|Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:number near] - Camera frustum near plane.<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:any postprocessing] -  The postprocessing.<br />
			[property:IMatrix4|Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:IMatrix4|Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any shaderSettings] -  The shader settings.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:any view] -  The view.<br />
			[property:boolean visible] - Object gets rendered if true.<br />
			[property:number zoom] -  The zoom.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICinematicCamera add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ICinematicCamera applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ICinematicCamera attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ICinematicCamera clear](  ) - Removes all child objects.<br />
			[method:void clearViewOffset](  ) <br />
			[method:ICinematicCamera clone](  [param:boolean recursive]? ) <br />
			[method:ICinematicCamera copy](  [param:ICinematicCamera source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void focusAt](  [param:number focusDistance] ) <br />
			[method:number getEffectiveFOV](  ) <br />
			[method:number getFilmHeight](  ) <br />
			[method:number getFilmWidth](  ) <br />
			[method:number getFocalLength](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void initPostProcessing](  ) <br />
			[method:number linearize](  [param:number depth] ) <br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ICinematicCamera remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ICinematicCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:void renderCinematic](  [param:IScene scene],  [param:IWebGLRenderer renderer] ) <br />
			[method:ICinematicCamera rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ICinematicCamera rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ICinematicCamera rotateX](  [param:number angle] ) <br />
			[method:ICinematicCamera rotateY](  [param:number angle] ) <br />
			[method:ICinematicCamera rotateZ](  [param:number angle] ) <br />
			[method:number saturate](  [param:number x] ) <br />
			[method:void setFocalLength](  [param:number focalLength] ) <br />
			[method:void setLens](  [param:number focalLength],  [param:number frameHeight]?,  [param:number fNumber]?,  [param:number coc]? ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:void setViewOffset](  [param:number fullWidth],  [param:number fullHeight],  [param:number x],  [param:number y],  [param:number width],  [param:number height] ) - Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.<br />
			For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:<br />
			+---+---+---+<br />
			| A | B | C |<br />
			+---+---+---+<br />
			| D | E | F |<br />
			+---+---+---+<br />
			<br />
			then for each monitor you would call it like this:<br />
			<br />
			const w = 1920;<br />
			const h = 1080;<br />
			const fullWidth = w * 3;<br />
			const fullHeight = h * 2;<br />
			<br />
			// A<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );<br />
			// B<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );<br />
			// C<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );<br />
			// D<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );<br />
			// E<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );<br />
			// F<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); Note there is no reason monitors have to be the same size or in a grid.<br />
			[method:number smoothstep](  [param:number near],  [param:number far],  [param:number depth] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ICinematicCamera translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ICinematicCamera translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ICinematicCamera translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ICinematicCamera translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateProjectionMatrix](  ) - Updates the camera projection matrix. Must be called after change of parameters.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ICircleDepthGeometry">ICircleDepthGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICircleDepthGeometry ICircleDepthGeometry](  [param:number radius]?,  [param:number depth]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number depthRate]? ) <br />
			[constructor:ICircleDepthGeometry ICircleDepthGeometry](  [param:number radius]?,  [param:number depth]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number depthRate]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] - The Parameters of circle depth geometry<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ICircleDepthGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			The Circle Depth geometry.<br />
			See the [page:NgxCircleDepthGeometry ngx3js docs] page for details.<br />
			See the [example:ngx_geometry/CircleDepthGeometry ngx geometey] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ICircleGeometry">ICircleGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICircleGeometry ICircleGeometry](  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:ICircleGeometry ICircleGeometry](  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ICircleGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IClearMaskPass">IClearMaskPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IClearMaskPass IClearMaskPass](  ) - Creates an instance of ngx clear mask pass.<br />
			[constructor:IClearMaskPass IClearMaskPass](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			ClearMask pass<br />
			See the [page:NgxClearMaskPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/ClearMaskPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IClearPass">IClearPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IClearPass IClearPass](  [param:any clearColor]?,  [param:number clearAlpha]? ) - Creates an instance of ngx clear pass.<br />
			[constructor:IClearPass IClearPass](  [param:any clearColor]?,  [param:number clearAlpha]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:number clearAlpha] -  The clear alpha.<br />
			[property:any clearColor] -  The clear color.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Clear pass<br />
			See the [page:NgxClearPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/ClearPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IClock">IClock <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IClock IClock](  [param:boolean autoStart]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoStart] - If set, starts the clock automatically when the first update is called.<br />
			[property:number elapsedTime] - When the clock is running, It holds the time elapsed between the start of the clock to the previous update.<br />
			This parameter is in seconds of three decimal places.<br />
			[property:number oldTime] - When the clock is running, It holds the previous time from a update.<br />
			This counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.<br />
			[property:boolean running] - This property keeps track whether the clock is running or not.<br />
			[property:number startTime] - When the clock is running, It holds the starttime of the clock.<br />
			This counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number getDelta](  ) - Get the seconds passed since the last call to this method.<br />
			[method:number getElapsedTime](  ) - Get the seconds passed since the clock started.<br />
			[method:void start](  ) - Starts clock.<br />
			[method:void stop](  ) - Stops clock.
		</p>

		<p class="desc">
			Object for keeping track of time.<br />
			see {@link https://github.com/mrdoob/three.js/blob/master/src/core/Clock.js|src/core/Clock.js}
		</p>

		<hr class="interface-line"/>
		<h3 id="ICollada">ICollada <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:object kinematics] -  The kinematics.<br />
			[property:object library] -  The library.<br />
			[property:IScene scene] -  The scene.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IColladaExporter">IColladaExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IColladaExporter IColladaExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:IColladaExporterResult parse](  [param:IObject3D object],  [param:any onDone],  [param:IColladaExporterOptions options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IColladaExporterOptions">IColladaExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string author]? -  The author.<br />
			[property:string textureDirectory]? -  The texture directory.<br />
			[property:string version]? -  The version.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IColladaExporterResult">IColladaExporterResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string data] -  The data.<br />
			[property:object[] textures] -  The textures.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IColladaLoader">IColladaLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IColladaLoader IColladaLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ICollada parse](  [param:string text],  [param:string path] ) <br />
			[method:IColladaLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IColladaLoader setPath](  [param:string path] ) <br />
			[method:IColladaLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IColladaLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IColladaLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IColor">IColor <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IColor IColor](  [param:any color]? ) <br />
			[constructor:IColor IColor](  [param:any color]?,  [param:number r],  [param:number g],  [param:number b] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number b] - Blue channel value between 0 and 1. Default is 1.<br />
			[property:number g] - Green channel value between 0 and 1. Default is 1.<br />
			[property:any isColor] -  The is color.<br />
			[property:number r] - Red channel value between 0 and 1. Default is 1.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IColor add](  [param:IColor color] ) <br />
			[method:IColor addColors](  [param:IColor color1],  [param:IColor color2] ) <br />
			[method:IColor addScalar](  [param:number s] ) <br />
			[method:IColor clone](  ) - Clones this color.<br />
			[method:IColor convertGammaToLinear](  [param:number gammaFactor]? ) - Converts this color from gamma to linear space.<br />
			[method:IColor convertLinearToGamma](  [param:number gammaFactor]? ) - Converts this color from linear to gamma space.<br />
			[method:IColor convertLinearToSRGB](  ) - Converts this color from linear to sRGB space.<br />
			[method:IColor convertSRGBToLinear](  ) - Converts this color from sRGB to linear space.<br />
			[method:IColor copy](  [param:IColor color] ) - Copies given color.<br />
			[method:IColor copyGammaToLinear](  [param:IColor color],  [param:number gammaFactor]? ) - Copies given color making conversion from gamma to linear space.<br />
			[method:IColor copyLinearToGamma](  [param:IColor color],  [param:number gammaFactor]? ) - Copies given color making conversion from linear to gamma space.<br />
			[method:IColor copyLinearToSRGB](  [param:IColor color] ) - Copies given color making conversion from linear to sRGB space.<br />
			[method:IColor copySRGBToLinear](  [param:IColor color] ) - Copies given color making conversion from sRGB to linear space.<br />
			[method:boolean equals](  [param:IColor color] ) <br />
			[method:IColor fromArray](  [param:number[]|ArrayLike array],  [param:number offset]? ) - Sets this color's red, green and blue value from the provided array or array-like.<br />
			[method:IColor fromBufferAttribute](  [param:IBufferAttribute attribute],  [param:number index] ) <br />
			[method:IHSL getHSL](  [param:IHSL target] ) <br />
			[method:number getHex](  ) - Returns the hexadecimal value of this color.<br />
			[method:string getHexString](  ) - Returns the string formated hexadecimal value of this color.<br />
			[method:string getStyle](  ) - Returns the value of this color in CSS context style.<br />
			Example: rgb(r, g, b)<br />
			[method:IColor lerp](  [param:IColor color],  [param:number alpha] ) <br />
			[method:IColor lerpColors](  [param:IColor color1],  [param:IColor color2],  [param:number alpha] ) <br />
			[method:IColor lerpHSL](  [param:IColor color],  [param:number alpha] ) <br />
			[method:IColor multiply](  [param:IColor color] ) <br />
			[method:IColor multiplyScalar](  [param:number s] ) <br />
			[method:IColor offsetHSL](  [param:number h],  [param:number s],  [param:number l] ) <br />
			[method:IColor set](  [param:any color] ) <br />
			[method:IColor setColorName](  [param:string style] ) - Sets this color from a color name.<br />
			Faster than {@line THREE.Color#setStyle .setStyle()} method if you don't need the other CSS-style formats.<br />
			[method:IColor setHSL](  [param:number h],  [param:number s],  [param:number l] ) - Sets this color from HSL values.<br />
			Based on MochiKit implementation by Bob Ippolito.<br />
			[method:IColor setHex](  [param:number hex] ) <br />
			[method:IColor setRGB](  [param:number r],  [param:number g],  [param:number b] ) - Sets this color from RGB values.<br />
			[method:IColor setScalar](  [param:number scalar] ) <br />
			[method:IColor setStyle](  [param:string style] ) - Sets this color from a CSS context style string.<br />
			[method:IColor sub](  [param:IColor color] ) <br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns an array [red, green, blue], or copies red, green and blue into the provided array.<br />
			<br />
			Returns : The created or provided array.<br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:ArrayLike xyz],  [param:number offset]? ) - Copies red, green and blue into the provided array-like.<br />
			<br />
			Returns : The provided array-like.
		</p>

		<p class="desc">
			Represents a color. See also {@link ColorUtils}.<br />
			see {@link https://github.com/mrdoob/three.js/blob/master/src/math/Color.js|src/math/Color.js}
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IColorAdjustmentNode">IColorAdjustmentNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IColorAdjustmentNode IColorAdjustmentNode](  [param:INode rgb],  [param:IFloatNode adjustment]?,  [param:string method]? ) <br />
			[constructor:IColorAdjustmentNode IColorAdjustmentNode](  [param:INode rgb],  [param:IFloatNode adjustment]?,  [param:string method]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IColorAdjustmentNode IColorAdjustmentNode](  [param:INode rgb],  [param:IFloatNode adjustment]?,  [param:string method]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string BRIGHTNESS] -  The b r i g h t n e s s.<br />
			[property:string CONTRAST] -  The c o n t r a s t.<br />
			[property:string HUE] -  The h u e.<br />
			[property:any Nodes] -  The nodes.<br />
			[property:string SATURATION] -  The s a t u r a t i o n.<br />
			[property:string VIBRANCE] -  The v i b r a n c e.<br />
			[property:IFloatNode adjustment] -  The adjustment.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string method] -  The method.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:INode rgb] -  The rgb.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IColorAdjustmentNode copy](  [param:IColorAdjustmentNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IColorAdjustmentNode setLabel](  [param:string name] ) <br />
			[method:IColorAdjustmentNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IKeyframeTrack] &rarr;

		<h3 id="IColorKeyframeTrack">IColorKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IColorKeyframeTrack IColorKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:ILinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:ICubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:IColorKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:IKeyframeTrack optimize](  ) <br />
			[method:IKeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:IKeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:IKeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:IKeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IColorMapKeywords">IColorMapKeywords <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any blackbody] -  The blackbody.<br />
			[property:any cooltowarm] -  The cooltowarm.<br />
			[property:any grayscale] -  The grayscale.<br />
			[property:any rainbow] -  The rainbow.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IColorNode">IColorNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IColorNode IColorNode](  [param:any color],  [param:number g]?,  [param:number b]? ) <br />
			[constructor:IColorNode IColorNode](  [param:any color],  [param:number g]?,  [param:number b]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IColorNode IColorNode](  [param:any color],  [param:number g]?,  [param:number b]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IColorNode IColorNode](  [param:any color],  [param:number g]?,  [param:number b]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IColor value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IColorNode copy](  [param:IColorNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IColorNode setLabel](  [param:string name] ) <br />
			[method:IColorNode setName](  [param:string name] ) <br />
			[method:IColorNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IColorSpaceNode">IColorSpaceNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IColorSpaceNode IColorSpaceNode](  [param:INode input],  [param:string method]? ) <br />
			[constructor:IColorSpaceNode IColorSpaceNode](  [param:INode input],  [param:string method]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IColorSpaceNode IColorSpaceNode](  [param:INode input],  [param:string method]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string GAMMA_TO_LINEAR] -  The g a m m a_ t o_ l i n e a r.<br />
			[property:string LINEAR_TO_GAMMA] -  The l i n e a r_ t o_ g a m m a.<br />
			[property:string LINEAR_TO_LINEAR] -  The l i n e a r_ t o_ l i n e a r.<br />
			[property:string LINEAR_TO_LOG_LUV] -  The l i n e a r_ t o_ l o g_ l u v.<br />
			[property:string LINEAR_TO_RGBD] -  The l i n e a r_ t o_ r g b d.<br />
			[property:string LINEAR_TO_RGBE] -  The l i n e a r_ t o_ r g b e.<br />
			[property:string LINEAR_TO_RGBM] -  The l i n e a r_ t o_ r g b m.<br />
			[property:string LINEAR_TO_SRGB] -  The l i n e a r_ t o_ s r g b.<br />
			[property:string LOG_LUV_TO_LINEAR] -  The l o g_ l u v_ t o_ l i n e a r.<br />
			[property:any Nodes] -  The nodes.<br />
			[property:string RGBD_TO_LINEAR] -  The r g b d_ t o_ l i n e a r.<br />
			[property:string RGBE_TO_LINEAR] -  The r g b e_ t o_ l i n e a r.<br />
			[property:string RGBM_TO_LINEAR] -  The r g b m_ t o_ l i n e a r.<br />
			[property:string SRGB_TO_LINEAR] -  The s r g b_ t o_ l i n e a r.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:INode input] -  The input.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string method] -  The method.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IColorSpaceNode copy](  [param:IColorSpaceNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void fromDecoding](  [param:number encoding] ) <br />
			[method:void fromEncoding](  [param:number encoding] ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:any[] getEncodingComponents](  [param:number encoding] ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IColorSpaceNode setLabel](  [param:string name] ) <br />
			[method:IColorSpaceNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IColorsNode">IColorsNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IColorsNode IColorsNode](  [param:number index]? ) <br />
			[constructor:IColorsNode IColorsNode](  [param:number index]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IColorsNode IColorsNode](  [param:number index]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:number index] -  The index.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IColorsNode copy](  [param:IColorsNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IColorsNode setLabel](  [param:string name] ) <br />
			[method:IColorsNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:ITexture] &rarr;

		<h3 id="ICompressedTexture">ICompressedTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICompressedTexture ICompressedTexture](  [param:ImageData[] mipmaps],  [param:number width],  [param:number height],  [param:CompressedPixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:ICompressedTexture ICompressedTexture](  [param:ImageData[] mipmaps],  [param:number width],  [param:number height],  [param:CompressedPixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isCompressedTexture] -  The is compressed texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:ImageData[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ICompressedTexture clone](  ) <br />
			[method:ICompressedTexture copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ICompressedTextureLoader">ICompressedTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICompressedTextureLoader ICompressedTextureLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ICompressedTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ICompressedTextureLoader setPath](  [param:string path] ) <br />
			[method:ICompressedTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ICompressedTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ICompressedTextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="ICondNode">ICondNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICondNode ICondNode](  [param:INode a],  [param:INode b],  [param:string op],  [param:INode ifNode]?,  [param:INode elseNode]? ) <br />
			[constructor:ICondNode ICondNode](  [param:INode a],  [param:INode b],  [param:string op],  [param:INode ifNode]?,  [param:INode elseNode]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ICondNode ICondNode](  [param:INode a],  [param:INode b],  [param:string op],  [param:INode ifNode]?,  [param:INode elseNode]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string AND] -  The a n d.<br />
			[property:string EQUAL] -  The e q u a l.<br />
			[property:string GREATER] -  The g r e a t e r.<br />
			[property:string GREATER_EQUAL] -  The g r e a t e r_ e q u a l.<br />
			[property:string LESS] -  The l e s s.<br />
			[property:string LESS_EQUAL] -  The l e s s_ e q u a l.<br />
			[property:string NOT_EQUAL] -  The n o t_ e q u a l.<br />
			[property:string OR] -  The o r.<br />
			[property:INode a] -  The a.<br />
			[property:INode b] -  The b.<br />
			[property:INode elseNode] -  The else node.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:INode ifNode] -  The if node.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string op] -  The op.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ICondNode copy](  [param:ICondNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getCondType](  [param:INodeBuilder builder] ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ICondNode setLabel](  [param:string name] ) <br />
			[method:ICondNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:ICylinderGeometry] &rarr;

		<h3 id="IConeGeometry">IConeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IConeGeometry IConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:IConeGeometry IConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:IConeGeometry IConeGeometry](  [param:number radius]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IConeGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IConstNode">IConstNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IConstNode IConstNode](  [param:string src],  [param:boolean useDefine]? ) <br />
			[constructor:IConstNode IConstNode](  [param:string src],  [param:boolean useDefine]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IConstNode IConstNode](  [param:string src],  [param:boolean useDefine]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string EPSILON] -  The e p s i l o n.<br />
			[property:string LOG2] -  The l o g2.<br />
			[property:string PI] -  The p i.<br />
			[property:string PI2] -  The p i2.<br />
			[property:string RECIPROCAL_PI] -  The r e c i p r o c a l_ p i.<br />
			[property:string RECIPROCAL_PI2] -  The r e c i p r o c a l_ p i2.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string src] -  The src.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean useDefine] -  The use define.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:IConstNode copy](  [param:IConstNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src],  [param:boolean useDefine]? ) <br />
			[method:IConstNode setLabel](  [param:string name] ) <br />
			[method:IConstNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IConvexGeometry">IConvexGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IConvexGeometry IConvexGeometry](  [param:IVector3[] points] ) <br />
			[constructor:IConvexGeometry IConvexGeometry](  [param:IVector3[] points] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IConvexGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ICubeCamera">ICubeCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICubeCamera ICubeCamera](  [param:number near],  [param:number far],  [param:IWebGLCubeRenderTarget renderTarget] ) <br />
			[constructor:ICubeCamera ICubeCamera](  [param:number near],  [param:number far],  [param:IWebGLCubeRenderTarget renderTarget] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IWebGLCubeRenderTarget renderTarget] -  The render target.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICubeCamera add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ICubeCamera applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ICubeCamera attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ICubeCamera clear](  ) - Removes all child objects.<br />
			[method:ICubeCamera clone](  [param:boolean recursive]? ) <br />
			[method:ICubeCamera copy](  [param:ICubeCamera source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ICubeCamera remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ICubeCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ICubeCamera rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ICubeCamera rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ICubeCamera rotateX](  [param:number angle] ) <br />
			[method:ICubeCamera rotateY](  [param:number angle] ) <br />
			[method:ICubeCamera rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ICubeCamera translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ICubeCamera translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ICubeCamera translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ICubeCamera translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  [param:IWebGLRenderer renderer],  [param:IScene scene] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:ITexture] &rarr;

		<h3 id="ICubeTexture">ICubeTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICubeTexture ICubeTexture](  [param:any[] images]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:ICubeTexture ICubeTexture](  [param:any[] images]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:any images] -  The images.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isCubeTexture] -  The is cube texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ICubeTexture clone](  ) <br />
			[method:ICubeTexture copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ICubeTextureLoader">ICubeTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICubeTextureLoader ICubeTextureLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICubeTexture load](  [param:string[] urls],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ICubeTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ICubeTextureLoader setPath](  [param:string path] ) <br />
			[method:ICubeTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ICubeTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ICubeTextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="ICubeTextureNode">ICubeTextureNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICubeTextureNode ICubeTextureNode](  [param:ICubeTexture value],  [param:INode uv]?,  [param:INode bias]? ) <br />
			[constructor:ICubeTextureNode ICubeTextureNode](  [param:ICubeTexture value],  [param:INode uv]?,  [param:INode bias]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ICubeTextureNode ICubeTextureNode](  [param:ICubeTexture value],  [param:INode uv]?,  [param:INode bias]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ICubeTextureNode ICubeTextureNode](  [param:ICubeTexture value],  [param:INode uv]?,  [param:INode bias]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode bias] -  The bias.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:INode uv] -  The uv.<br />
			[property:ICubeTexture value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ICubeTextureNode copy](  [param:ICubeTextureNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getTexture](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ICubeTextureNode setLabel](  [param:string name] ) <br />
			[method:ICubeTextureNode setName](  [param:string name] ) <br />
			[method:ICubeTextureNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ICubeTexturePass">ICubeTexturePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICubeTexturePass ICubeTexturePass](  [param:IPerspectiveCamera camera],  [param:ICubeTexture envMap]?,  [param:number opacity]? ) - Creates an instance of ngx cube texture pass.<br />
			[constructor:ICubeTexturePass ICubeTexturePass](  [param:IPerspectiveCamera camera],  [param:ICubeTexture envMap]?,  [param:number opacity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IPerspectiveCamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:IPerspectiveCamera cubeCamera] -  The cube camera.<br />
			[property:IMesh cubeMesh] -  The cube mesh.<br />
			[property:IScene cubeScene] -  The cube scene.<br />
			[property:object cubeShader] -  The cube shader.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:ICubeTexture envMap] -  The env map.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number opacity] -  The opacity.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			CubeTexture pass<br />
			See the [page:NgxCubeTexturePass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/CubeTexturePass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="ICubicBezierCurve">ICubicBezierCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICubicBezierCurve ICubicBezierCurve](  [param:IVector2|Vector2 v0],  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2],  [param:IVector2|Vector2 v3] ) <br />
			[constructor:ICubicBezierCurve ICubicBezierCurve](  [param:IVector2|Vector2 v0],  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2],  [param:IVector2|Vector2 v3],  [param:IVector2|Vector2 v0],  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2],  [param:IVector2|Vector2 v3] ) <br />
			[constructor:ICubicBezierCurve ICubicBezierCurve](  [param:IVector2|Vector2 v0],  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2],  [param:IVector2|Vector2 v3],  [param:IVector2|Vector2 v0],  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2],  [param:IVector2|Vector2 v3] ) <br />
			[constructor:ICubicBezierCurve ICubicBezierCurve](  [param:IVector2|Vector2 v0],  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2],  [param:IVector2|Vector2 v3],  [param:IVector2|Vector2 v0],  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2],  [param:IVector2|Vector2 v3] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:IVector2|Vector2 v0] -  The v0.<br />
			[property:IVector2|Vector2 v1] -  The v1.<br />
			[property:IVector2|Vector2 v2] -  The v2.<br />
			[property:IVector2|Vector2 v3] -  The v3.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICubicBezierCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ICubicBezierCurve copy](  [param:ICurve source] ) <br />
			[method:ICubicBezierCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector2|Vector2 getPoint](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getPointAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:void getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:void getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector2|Vector2 getTangent](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getTangentAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="ICubicBezierCurve3">ICubicBezierCurve3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICubicBezierCurve3 ICubicBezierCurve3](  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2],  [param:IVector3|Vector3 v3] ) <br />
			[constructor:ICubicBezierCurve3 ICubicBezierCurve3](  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2],  [param:IVector3|Vector3 v3],  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2],  [param:IVector3|Vector3 v3] ) <br />
			[constructor:ICubicBezierCurve3 ICubicBezierCurve3](  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2],  [param:IVector3|Vector3 v3],  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2],  [param:IVector3|Vector3 v3] ) <br />
			[constructor:ICubicBezierCurve3 ICubicBezierCurve3](  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2],  [param:IVector3|Vector3 v3],  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2],  [param:IVector3|Vector3 v3] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:IVector3|Vector3 v0] -  The v0.<br />
			[property:IVector3|Vector3 v1] -  The v1.<br />
			[property:IVector3|Vector3 v2] -  The v2.<br />
			[property:IVector3|Vector3 v3] -  The v3.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICubicBezierCurve3 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ICubicBezierCurve3 copy](  [param:ICurve source] ) <br />
			[method:ICubicBezierCurve3 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector3 getPoint](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getPointAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:IVector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:IVector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector3 getTangent](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getTangentAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IInterpolant] &rarr;

		<h3 id="ICubicInterpolant">ICubicInterpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICubicInterpolant ICubicInterpolant](  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] -  The parameter positions.<br />
			[property:any resultBuffer] -  The result buffer.<br />
			[property:any sampleValues] -  The sample values.<br />
			[property:number valueSize] -  The value size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any evaluate](  [param:number time] ) <br />
			[method:any evaluate](  [param:number time],  [param:number time] ) <br />
			[method:any interpolate_](  [param:number i1],  [param:number t0],  [param:number t],  [param:number t1] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ICurve">ICurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICurve ICurve](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ICurve copy](  [param:ICurve source] ) <br />
			[method:ICurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:T getPoint](  [param:number t],  [param:T optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:T getPointAt](  [param:number u],  [param:T optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:T[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:T[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:T getTangent](  [param:number t],  [param:T optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:T getTangentAt](  [param:number u],  [param:T optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			An extensible curve object which contains methods for interpolation<br />
			class Curve&lt;T extends Vector&gt;
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="ICurvePath">ICurvePath <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICurvePath ICurvePath](  ) <br />
			[constructor:ICurvePath ICurvePath](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:boolean autoClose] -  The auto close.<br />
			[property:ICurve[] curves] -  The curves.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void add](  [param:ICurve curve] ) <br />
			[method:ICurvePath clone](  ) <br />
			[method:void closePath](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ICurvePath copy](  [param:ICurve source] ) <br />
			[method:ICurvePath fromJSON](  [param:object json] ) <br />
			[method:number[] getCurveLengths](  ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:T getPoint](  [param:number t],  [param:T optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:T getPointAt](  [param:number u],  [param:T optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:T[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:T[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:T getTangent](  [param:number t],  [param:T optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:T getTangentAt](  [param:number u],  [param:T optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ICylinderGeometry">ICylinderGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICylinderGeometry ICylinderGeometry](  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:ICylinderGeometry ICylinderGeometry](  [param:number radiusTop]?,  [param:number radiusBottom]?,  [param:number height]?,  [param:number radialSegments]?,  [param:number heightSegments]?,  [param:boolean openEnded]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ICylinderGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ICylindrical">ICylindrical <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ICylindrical ICylindrical](  [param:number radius]?,  [param:number theta]?,  [param:number y]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number radius] -  The radius.<br />
			[property:number theta] -  The theta.<br />
			[property:number y] -  The y.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICylindrical clone](  ) <br />
			[method:ICylindrical copy](  [param:ICylindrical other] ) <br />
			[method:ICylindrical set](  [param:number radius],  [param:number theta],  [param:number y] ) <br />
			[method:ICylindrical setFromCartesianCoords](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:ICylindrical setFromVector3](  [param:IVector3|Vector3 vec3] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IDDS">IDDS <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:PixelFormat|CompressedPixelFormat format] -  The format.<br />
			[property:number height] -  The height.<br />
			[property:boolean isCubemap] -  The is cubemap.<br />
			[property:number mipmapCount] -  The mipmap count.<br />
			[property:object[] mipmaps] -  The mipmaps.<br />
			[property:number width] -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr; [page:ICompressedTextureLoader] &rarr;

		<h3 id="IDDSLoader">IDDSLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDDSLoader IDDSLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IDDS parse](  [param:ArrayBuffer buffer],  [param:boolean loadMipmaps] ) <br />
			[method:IDDSLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IDDSLoader setPath](  [param:string path] ) <br />
			[method:IDDSLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IDDSLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IDDSLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IDRACOExporter">IDRACOExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDRACOExporter IDRACOExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:Int8Array parse](  [param:IMesh|IPoints object],  [param:IDRACOExporterOptions options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IDRACOExporterOptions">IDRACOExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number decodeSpeed]? -  The decode speed.<br />
			[property:number encodeSpeed]? -  The encode speed.<br />
			[property:number encoderMethod]? -  The encoder method.<br />
			[property:boolean exportColor]? -  The export color.<br />
			[property:boolean exportNormals]? -  The export normals.<br />
			[property:boolean exportUvs]? -  The export uvs.<br />
			[property:number[] quantization]? -  The quantization.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IDRACOLoader">IDRACOLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDRACOLoader IDRACOLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDRACOLoader dispose](  ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IDRACOLoader preload](  ) <br />
			[method:IDRACOLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IDRACOLoader setDecoderConfig](  [param:object config] ) <br />
			[method:IDRACOLoader setDecoderPath](  [param:string path] ) <br />
			[method:IDRACOLoader setPath](  [param:string path] ) <br />
			[method:IDRACOLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IDRACOLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IDRACOLoader setWithCredentials](  [param:boolean value] ) <br />
			[method:IDRACOLoader setWorkerLimit](  [param:number workerLimit] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:ITexture] &rarr;

		<h3 id="IDataTexture">IDataTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDataTexture IDataTexture](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) <br />
			[constructor:IDataTexture IDataTexture](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:ImageData image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isDataTexture] -  The is data texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IDataTexture clone](  ) <br />
			[method:IDataTexture copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:ITexture] &rarr;

		<h3 id="IDataTexture2DArray">IDataTexture2DArray <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDataTexture2DArray IDataTexture2DArray](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:number depth]? ) <br />
			[constructor:IDataTexture2DArray IDataTexture2DArray](  [param:BufferSource data]?,  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isDataTexture2DArray] -  The is data texture2 d array.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:boolean wrapR] -  The wrap r.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IDataTexture2DArray clone](  ) <br />
			[method:IDataTexture2DArray copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:ITexture] &rarr;

		<h3 id="IDataTexture3D">IDataTexture3D <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDataTexture3D IDataTexture3D](  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth] ) <br />
			[constructor:IDataTexture3D IDataTexture3D](  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth],  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isDataTexture3D] -  The is data texture3 d.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:boolean wrapR] -  The wrap r.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IDataTexture3D clone](  ) <br />
			[method:IDataTexture3D copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IDataTextureLoader">IDataTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDataTextureLoader IDataTextureLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDataTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IDataTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IDataTextureLoader setPath](  [param:string path] ) <br />
			[method:IDataTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IDataTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IDataTextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IDecalGeometry">IDecalGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDecalGeometry IDecalGeometry](  [param:IMesh mesh],  [param:IVector3 position],  [param:IEuler orientation],  [param:IVector3 size] ) <br />
			[constructor:IDecalGeometry IDecalGeometry](  [param:IMesh mesh],  [param:IVector3 position],  [param:IEuler orientation],  [param:IVector3 size] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IDecalGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IDecalVertex">IDecalVertex <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDecalVertex IDecalVertex](  [param:IVector3 position],  [param:IVector3 normal] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDecalVertex clone](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:ITexture] &rarr;

		<h3 id="IDepthTexture">IDepthTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDepthTexture IDepthTexture](  [param:number width],  [param:number height],  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]? ) <br />
			[constructor:IDepthTexture IDepthTexture](  [param:number width],  [param:number height],  [param:TextureDataType type]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:number anisotropy]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isDepthTexture] -  The is depth texture.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IDepthTexture clone](  ) <br />
			[method:IDepthTexture copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILight] &rarr;

		<h3 id="IDirectionalLight">IDirectionalLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDirectionalLight IDirectionalLight](  [param:any color]?,  [param:number intensity]? ) <br />
			[constructor:IDirectionalLight IDirectionalLight](  [param:any color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:IDirectionalLight IDirectionalLight](  [param:any color]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] - Light's intensity.<br />
			[property:any isDirectionalLight] -  The is directional light.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] -  The position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:IDirectionalLightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:IObject3D target] - Target used for shadow camera orientation.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDirectionalLight add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IDirectionalLight applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IDirectionalLight attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IDirectionalLight clear](  ) - Removes all child objects.<br />
			[method:IDirectionalLight clone](  [param:boolean recursive]? ) <br />
			[method:IDirectionalLight copy](  [param:IDirectionalLight source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IDirectionalLight remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IDirectionalLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IDirectionalLight rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IDirectionalLight rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IDirectionalLight rotateX](  [param:number angle] ) <br />
			[method:IDirectionalLight rotateY](  [param:number angle] ) <br />
			[method:IDirectionalLight rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IDirectionalLight translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IDirectionalLight translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IDirectionalLight translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IDirectionalLight translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			see {@link https://github.com/mrdoob/three.js/blob/master/src/lights/DirectionalLight.js|src/lights/DirectionalLight.js}
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IDirectionalLightHelper">IDirectionalLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDirectionalLightHelper IDirectionalLightHelper](  [param:IDirectionalLight light],  [param:number size]?,  [param:any color]? ) <br />
			[constructor:IDirectionalLightHelper IDirectionalLightHelper](  [param:IDirectionalLight light],  [param:number size]?,  [param:any color]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:any color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IDirectionalLight light] -  The light.<br />
			[property:ILine lightPlane] -  The light plane.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ILine targetLine] -  The target line.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDirectionalLightHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IDirectionalLightHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IDirectionalLightHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IDirectionalLightHelper clear](  ) - Removes all child objects.<br />
			[method:IDirectionalLightHelper clone](  [param:boolean recursive]? ) <br />
			[method:IDirectionalLightHelper copy](  [param:IDirectionalLightHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IDirectionalLightHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IDirectionalLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IDirectionalLightHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IDirectionalLightHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IDirectionalLightHelper rotateX](  [param:number angle] ) <br />
			[method:IDirectionalLightHelper rotateY](  [param:number angle] ) <br />
			[method:IDirectionalLightHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IDirectionalLightHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IDirectionalLightHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IDirectionalLightHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IDirectionalLightHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILightShadow] &rarr;

		<h3 id="IDirectionalLightShadow">IDirectionalLightShadow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:number bias] -  The bias.<br />
			[property:number blurSamples] -  The blur samples.<br />
			[property:IOrthographicCamera camera] -  The camera.<br />
			[property:any isDirectionalLightShadow] -  The is directional light shadow.<br />
			[property:IWebGLRenderTarget map] -  The map.<br />
			[property:IWebGLRenderTarget mapPass] -  The map pass.<br />
			[property:IVector2|Vector2 mapSize] -  The map size.<br />
			[property:IMatrix4 matrix] -  The matrix.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number normalBias] -  The normal bias.<br />
			[property:number radius] -  The radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDirectionalLightShadow clone](  [param:boolean recursive]? ) <br />
			[method:IDirectionalLightShadow copy](  [param:ILightShadow source] ) <br />
			[method:void dispose](  ) <br />
			[method:IVector2 getFrameExtents](  ) <br />
			[method:number getFrustum](  ) <br />
			[method:IVector4 getViewport](  [param:number viewportIndex] ) <br />
			[method:any toJSON](  ) <br />
			[method:void updateMatrices](  [param:ILight light],  [param:number viewportIndex]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IInterpolant] &rarr;

		<h3 id="IDiscreteInterpolant">IDiscreteInterpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDiscreteInterpolant IDiscreteInterpolant](  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] -  The parameter positions.<br />
			[property:any resultBuffer] -  The result buffer.<br />
			[property:any sampleValues] -  The sample values.<br />
			[property:number valueSize] -  The value size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any evaluate](  [param:number time] ) <br />
			[method:any evaluate](  [param:number time],  [param:number time] ) <br />
			[method:any interpolate_](  [param:number i1],  [param:number t0],  [param:number t],  [param:number t1] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IPolyhedronGeometry] &rarr;

		<h3 id="IDodecahedronGeometry">IDodecahedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDodecahedronGeometry IDodecahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IDodecahedronGeometry IDodecahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IDodecahedronGeometry IDodecahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IDodecahedronGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IDotScreenPass">IDotScreenPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDotScreenPass IDotScreenPass](  [param:IVector2 center]?,  [param:number angle]?,  [param:number scale]? ) - Creates an instance of ngx dot screen pass.<br />
			[constructor:IDotScreenPass IDotScreenPass](  [param:IVector2 center]?,  [param:number angle]?,  [param:number scale]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			DotScreen pass<br />
			See the [page:NgxDotScreenPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/DotScreenPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IDragControls">IDragControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IDragControls IDragControls](  [param:IObject3D[] objects],  [param:ICamera camera],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean enabled] -  The enabled.<br />
			[property:ICamera object] -  The object.<br />
			[property:boolean transformGroup] -  The transform group.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void activate](  ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void deactivate](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D[] getObjects](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IEXR">IEXR <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Float32Array data] -  The data.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:object header] -  The header.<br />
			[property:number height] -  The height.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number width] -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr; [page:IDataTextureLoader] &rarr;

		<h3 id="IEXRLoader">IEXRLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IEXRLoader IEXRLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDataTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IEXR parse](  [param:ArrayBuffer buffer] ) <br />
			[method:IEXRLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IEXRLoader setDataType](  [param:TextureDataType type] ) <br />
			[method:IEXRLoader setPath](  [param:string path] ) <br />
			[method:IEXRLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IEXRLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IEXRLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IEdgeSplitModifier">IEdgeSplitModifier <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IEdgeSplitModifier IEdgeSplitModifier](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry modify](  [param:IBufferGeometry geometry],  [param:number cutOffPoint],  [param:boolean tryKeepNormals] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IEdgesGeometry">IEdgesGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IEdgesGeometry IEdgesGeometry](  [param:TBufferGeometry geometry]?,  [param:number thresholdAngle]? ) <br />
			[constructor:IEdgesGeometry IEdgesGeometry](  [param:TBufferGeometry geometry]?,  [param:number thresholdAngle]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IEdgesGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IEffectComposer">IEffectComposer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IEffectComposer IEffectComposer](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget renderTarget]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IClock clock] -  The clock.<br />
			[property:IShaderPass copyPass] -  The copy pass.<br />
			[property:IPass[] passes] -  The passes.<br />
			[property:IWebGLRenderTarget readBuffer] -  The read buffer.<br />
			[property:IWebGLRenderTarget renderTarget1] -  The render target1.<br />
			[property:IWebGLRenderTarget renderTarget2] -  The render target2.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IWebGLRenderer renderer] -  The renderer.<br />
			[property:IWebGLRenderTarget writeBuffer] -  The write buffer.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addPass](  [param:IPass pass] ) <br />
			[method:void insertPass](  [param:IPass pass],  [param:number index] ) <br />
			[method:boolean isLastEnabledPass](  [param:number passIndex] ) <br />
			[method:void removePass](  [param:IPass pass] ) <br />
			[method:void render](  [param:number deltaTime]? ) <br />
			[method:void reset](  [param:IWebGLRenderTarget renderTarget]? ) <br />
			[method:void setPixelRatio](  [param:number pixelRatio] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) <br />
			[method:void swapBuffers](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="IEllipseCurve">IEllipseCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IEllipseCurve IEllipseCurve](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[constructor:IEllipseCurve IEllipseCurve](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean aClockwise] -  The a clockwise.<br />
			[property:number aEndAngle] -  The a end angle.<br />
			[property:number aRotation] -  The a rotation.<br />
			[property:number aStartAngle] -  The a start angle.<br />
			[property:number aX] -  The a x.<br />
			[property:number aY] -  The a y.<br />
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:number xRadius] -  The x radius.<br />
			[property:number yRadius] -  The y radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IEllipseCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:IEllipseCurve copy](  [param:ICurve source] ) <br />
			[method:IEllipseCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector2|Vector2 getPoint](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getPointAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:void getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:void getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector2|Vector2 getTangent](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getTangentAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IEuler">IEuler <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IEuler IEuler](  [param:number x]?,  [param:number y]?,  [param:number z]?,  [param:string order]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isEuler] -  The is euler.<br />
			[property:string order] -  The order.<br />
			[property:number x] -  The x.<br />
			[property:number y] -  The y.<br />
			[property:number z] -  The z.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IEuler _onChange](  [param:any callback] ) <br />
			[method:void _onChangeCallback](  ) <br />
			[method:IEuler clone](  ) <br />
			[method:IEuler copy](  [param:IEuler|Euler euler] ) <br />
			[method:boolean equals](  [param:IEuler|Euler euler] ) <br />
			[method:IEuler|Euler fromArray](  [param:any[] xyzo] ) <br />
			[method:IEuler|Euler reorder](  [param:string newOrder] ) <br />
			[method:IEuler|Euler set](  [param:number x],  [param:number y],  [param:number z],  [param:string order]? ) <br />
			[method:IEuler|Euler setFromQuaternion](  [param:IQuaternion|Quaternion q],  [param:string order]?,  [param:boolean update]? ) <br />
			[method:IEuler|Euler setFromRotationMatrix](  [param:IMatrix4|Matrix4 m],  [param:string order]?,  [param:boolean update]? ) <br />
			[method:IEuler|Euler setFromVector3](  [param:IVector3|Vector3 v],  [param:string order]? ) <br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) <br />
			[method:IVector3 toVector3](  [param:IVector3|Vector3 optionalResult]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBaseEvent] &rarr;

		<h3 id="IEvent">IEvent <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any target]? -  The target.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			Event object.
		</p>

		<hr class="interface-line"/>
		<h3 id="IEventDispatcher">IEventDispatcher <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void dispatchEvent](  [param:E event] ) - Fire an event type.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IFunctionNode] &rarr;

		<h3 id="IExpressionNode">IExpressionNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IExpressionNode IExpressionNode](  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]? ) <br />
			[constructor:IExpressionNode IExpressionNode](  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]? ) <br />
			[constructor:IExpressionNode IExpressionNode](  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IExpressionNode IExpressionNode](  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object extensions] -  The extensions.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:object[] includes] -  The includes.<br />
			[property:IFunctionNodeInput[] inputs] -  The inputs.<br />
			[property:boolean isMethod] -  The is method.<br />
			[property:any isNode] -  The is node.<br />
			[property:object keywords] -  The keywords.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean useKeywords] -  The use keywords.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IExpressionNode copy](  [param:IFunctionNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getIncludeByName](  [param:string name] ) <br />
			[method:IFunctionNodeInput getInputByName](  [param:string name] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]? ) <br />
			[method:IExpressionNode setLabel](  [param:string name] ) <br />
			[method:IExpressionNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IExtrudeGeometry">IExtrudeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IExtrudeGeometry IExtrudeGeometry](  [param:IShape|IShape[] shapes]?,  [param:IExtrudeGeometryOptions options]? ) <br />
			[constructor:IExtrudeGeometry IExtrudeGeometry](  [param:IShape|IShape[] shapes]?,  [param:IExtrudeGeometryOptions options]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:void addShape](  [param:IShape shape],  [param:any options]? ) <br />
			[method:void addShapeList](  [param:IShape[] shapes],  [param:any options]? ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IExtrudeGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IExtrudeGeometryOptions">IExtrudeGeometryOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IUVGenerator UVGenerator]? -  The u v generator.<br />
			[property:boolean bevelEnabled]? -  The bevel enabled.<br />
			[property:number bevelOffset]? -  The bevel offset.<br />
			[property:number bevelSegments]? -  The bevel segments.<br />
			[property:number bevelSize]? -  The bevel size.<br />
			[property:number bevelThickness]? -  The bevel thickness.<br />
			[property:number curveSegments]? -  The curve segments.<br />
			[property:number depth]? -  The depth.<br />
			[property:ICurve extrudePath]? -  The extrude path.<br />
			[property:number steps]? -  The steps.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IFBXLoader">IFBXLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFBXLoader IFBXLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IGroup parse](  [param:string|ArrayBuffer FBXBuffer],  [param:string path] ) <br />
			[method:IFBXLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IFBXLoader setPath](  [param:string path] ) <br />
			[method:IFBXLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IFBXLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IFBXLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IFace">IFace <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number a] -  The a.<br />
			[property:number b] -  The b.<br />
			[property:number c] -  The c.<br />
			[property:number materialIndex] -  The material index.<br />
			[property:IVector3 normal] -  The normal.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IFileLoader">IFileLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFileLoader IFileLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:MimeType mimeType] -  The mime type.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:string responseType] -  The response type.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IFileLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IFileLoader setMimeType](  [param:MimeType mimeType] ) <br />
			[method:IFileLoader setPath](  [param:string path] ) <br />
			[method:IFileLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IFileLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IFileLoader setResponseType](  [param:string responseType] ) <br />
			[method:IFileLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IFilmPass">IFilmPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFilmPass IFilmPass](  [param:number noiseIntensity]?,  [param:number scanlinesIntensity]?,  [param:number scanlinesCount]?,  [param:number grayscale]? ) - Creates an instance of ngx film pass.<br />
			[constructor:IFilmPass IFilmPass](  [param:number noiseIntensity]?,  [param:number scanlinesIntensity]?,  [param:number scanlinesCount]?,  [param:number grayscale]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Film pass<br />
			See the [page:NgxFilmPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/FilmPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IFirstPersonControls">IFirstPersonControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFirstPersonControls IFirstPersonControls](  [param:ICamera object],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean activeLook] -  The active look.<br />
			[property:boolean autoForward] -  The auto forward.<br />
			[property:boolean constrainVertical] -  The constrain vertical.<br />
			[property:HTMLElement|HTMLDocument domElement] -  The dom element.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:number heightCoef] -  The height coef.<br />
			[property:number heightMax] -  The height max.<br />
			[property:number heightMin] -  The height min.<br />
			[property:boolean heightSpeed] -  The height speed.<br />
			[property:number lookSpeed] -  The look speed.<br />
			[property:boolean lookVertical] -  The look vertical.<br />
			[property:boolean mouseDragOn] -  The mouse drag on.<br />
			[property:number movementSpeed] -  The movement speed.<br />
			[property:ICamera object] -  The object.<br />
			[property:number verticalMax] -  The vertical max.<br />
			[property:number verticalMin] -  The vertical min.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void handleResize](  ) <br />
			[method:IFirstPersonControls lookAt](  [param:number|IVector3 x],  [param:number y],  [param:number z] ) <br />
			[method:IFirstPersonControls update](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IFloat16BufferAttribute">IFloat16BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFloat16BufferAttribute IFloat16BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IFloat16BufferAttribute IFloat16BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IFloat16BufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IFloat16BufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IFloat16BufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IFloat16BufferAttribute clone](  ) <br />
			[method:IFloat16BufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IFloat16BufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IFloat16BufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IFloat16BufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IFloat16BufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IFloat16BufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IFloat16BufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IFloat16BufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IFloat16BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IFloat16BufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IFloat16BufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IFloat16BufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IFloat16BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IFloat16BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IFloat16BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IFloat16BufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IFloat16BufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IFloat16BufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IFloat32BufferAttribute">IFloat32BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFloat32BufferAttribute IFloat32BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IFloat32BufferAttribute IFloat32BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IFloat32BufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IFloat32BufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IFloat32BufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IFloat32BufferAttribute clone](  ) <br />
			[method:IFloat32BufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IFloat32BufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IFloat32BufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IFloat32BufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IFloat32BufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IFloat32BufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IFloat32BufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IFloat32BufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IFloat32BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IFloat32BufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IFloat32BufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IFloat32BufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IFloat32BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IFloat32BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IFloat32BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IFloat32BufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IFloat32BufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IFloat32BufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IFloat64BufferAttribute">IFloat64BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFloat64BufferAttribute IFloat64BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IFloat64BufferAttribute IFloat64BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IFloat64BufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IFloat64BufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IFloat64BufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IFloat64BufferAttribute clone](  ) <br />
			[method:IFloat64BufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IFloat64BufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IFloat64BufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IFloat64BufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IFloat64BufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IFloat64BufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IFloat64BufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IFloat64BufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IFloat64BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IFloat64BufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IFloat64BufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IFloat64BufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IFloat64BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IFloat64BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IFloat64BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IFloat64BufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IFloat64BufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IFloat64BufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IFloatNode">IFloatNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFloatNode IFloatNode](  [param:number value]? ) <br />
			[constructor:IFloatNode IFloatNode](  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IFloatNode IFloatNode](  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IFloatNode IFloatNode](  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IFloatNode copy](  [param:IFloatNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IFloatNode setLabel](  [param:string name] ) <br />
			[method:IFloatNode setName](  [param:string name] ) <br />
			[method:IFloatNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IFlow">IFlow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFlow IFlow](  [param:IMesh mesh],  [param:number numberOfCurves]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] curveArray] -  The curve array.<br />
			[property:number[] curveLengthArray] -  The curve length array.<br />
			[property:IMesh object3D] -  The object3 d.<br />
			[property:IDataTexture splineTexure] -  The spline texure.<br />
			[property:ISplineUniform uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void moveAlongCurve](  [param:number amount] ) <br />
			[method:void updateCurve](  [param:number index],  [param:ICurve curve] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IFlyControls">IFlyControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFlyControls IFlyControls](  [param:ICamera object],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoForward] -  The auto forward.<br />
			[property:HTMLElement|HTMLDocument domElement] -  The dom element.<br />
			[property:boolean dragToLook] -  The drag to look.<br />
			[property:number movementSpeed] -  The movement speed.<br />
			[property:ICamera object] -  The object.<br />
			[property:number rollSpeed] -  The roll speed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void update](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IFogBase] &rarr;

		<h3 id="IFog">IFog <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFog IFog](  [param:any color],  [param:number near]?,  [param:number far]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IColor color] -  The color.<br />
			[property:number far] - The maximum distance at which fog stops being calculated and applied. Objects that are more than 'far' units away from the active camera won't be affected by fog.<br />
			[property:any isFog] -  The is fog.<br />
			[property:string name] -  The name.<br />
			[property:number near] - The minimum distance to start applying fog. Objects that are less than 'near' units from the active camera won't be affected by fog.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IFog clone](  ) <br />
			[method:any toJSON](  ) 
		</p>

		<p class="desc">
			This class contains the parameters that define linear fog, i.e., that grows linearly denser with the distance.
		</p>

		<hr class="interface-line"/>
		<h3 id="IFogBase">IFogBase <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IColor color] -  The color.<br />
			[property:string name] -  The name.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IFogBase clone](  ) <br />
			[method:any toJSON](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IFogBase] &rarr;

		<h3 id="IFogExp2">IFogExp2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFogExp2 IFogExp2](  [param:string|number hex],  [param:number density]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IColor color] -  The color.<br />
			[property:number density] - Defines how fast the fog will grow dense.<br />
			[property:any isFogExp2] -  The is fog exp2.<br />
			[property:string name] -  The name.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IFogExp2 clone](  ) <br />
			[method:any toJSON](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IFont">IFont <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFont IFont](  [param:any jsondata] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string data] -  The data.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IShape[] generateShapes](  [param:string text],  [param:number size] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IFontLoader">IFontLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFontLoader IFontLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IFont parse](  [param:any json] ) <br />
			[method:IFontLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IFontLoader setPath](  [param:string path] ) <br />
			[method:IFontLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IFontLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IFontLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IFrustum">IFrustum <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFrustum IFrustum](  [param:IPlane p0]?,  [param:IPlane p1]?,  [param:IPlane p2]?,  [param:IPlane p3]?,  [param:IPlane p4]?,  [param:IPlane p5]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IPlane[] planes] - Array of 6 vectors.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IFrustum clone](  ) <br />
			[method:boolean containsPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:IFrustum copy](  [param:IFrustum frustum] ) <br />
			[method:boolean intersectsBox](  [param:IBox3 box] ) <br />
			[method:boolean intersectsObject](  [param:IObject3D object] ) <br />
			[method:boolean intersectsSphere](  [param:ISphere sphere] ) <br />
			[method:boolean intersectsSprite](  [param:ISprite sprite] ) <br />
			[method:IFrustum set](  [param:IPlane p0],  [param:IPlane p1],  [param:IPlane p2],  [param:IPlane p3],  [param:IPlane p4],  [param:IPlane p5] ) <br />
			[method:IFrustum setFromProjectionMatrix](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			Frustums are used to determine what is inside the camera's field of view. They help speed up the rendering process.
		</p>

		<hr class="interface-line"/>
		<h3 id="IFullScreenQuad">IFullScreenQuad <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFullScreenQuad IFullScreenQuad](  [param:IMaterial material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IMaterial material] -  The material.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void render](  [param:IWebGLRenderer renderer] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IFunctionCallNode">IFunctionCallNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFunctionCallNode IFunctionCallNode](  [param:IFunctionNode func],  [param:INode[] inputs]? ) <br />
			[constructor:IFunctionCallNode IFunctionCallNode](  [param:IFunctionNode func],  [param:INode[] inputs]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IFunctionCallNode IFunctionCallNode](  [param:IFunctionNode func],  [param:INode[] inputs]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:INode[] inputs] -  The inputs.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IFunctionNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IFunctionCallNode copy](  [param:IFunctionCallNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:IFunctionNode getFunction](  ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void setFunction](  [param:IFunctionNode func],  [param:INode[] inputs]? ) <br />
			[method:IFunctionCallNode setLabel](  [param:string name] ) <br />
			[method:IFunctionCallNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IFunctionNode">IFunctionNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IFunctionNode IFunctionNode](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]? ) <br />
			[constructor:IFunctionNode IFunctionNode](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IFunctionNode IFunctionNode](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object extensions] -  The extensions.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:object[] includes] -  The includes.<br />
			[property:IFunctionNodeInput[] inputs] -  The inputs.<br />
			[property:boolean isMethod] -  The is method.<br />
			[property:any isNode] -  The is node.<br />
			[property:object keywords] -  The keywords.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean useKeywords] -  The use keywords.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IFunctionNode copy](  [param:IFunctionNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getIncludeByName](  [param:string name] ) <br />
			[method:IFunctionNodeInput getInputByName](  [param:string name] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]? ) <br />
			[method:IFunctionNode setLabel](  [param:string name] ) <br />
			[method:IFunctionNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IFunctionNodeInput">IFunctionNodeInput <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string name] -  The name.<br />
			[property:string qualifier] -  The qualifier.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IGCodeLoader">IGCodeLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGCodeLoader IGCodeLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean splitLayer] -  The split layer.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IGroup parse](  [param:string data] ) <br />
			[method:IGCodeLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IGCodeLoader setPath](  [param:string path] ) <br />
			[method:IGCodeLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IGCodeLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IGCodeLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGLBufferAttribute">IGLBufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:WebGLBuffer buffer] -  The buffer.<br />
			[property:number count] -  The count.<br />
			[property:'1'|'2'|'4' elementSize] -  The element size.<br />
			[property:any isGLBufferAttribute] -  The is g l buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:number type] -  The type.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IGLBufferAttribute setBuffer](  [param:WebGLBuffer buffer] ) <br />
			[method:IGLBufferAttribute setCount](  [param:number count] ) <br />
			[method:IGLBufferAttribute setItemSize](  [param:number itemSize] ) <br />
			[method:IGLBufferAttribute setType](  [param:number type],  [param:'1'|'2'|'4' elementSize] ) 
		</p>

		<p class="desc">
			see {@link https://github.com/mrdoob/three.js/blob/master/src/core/GLBufferAttribute.js|src/core/GLBufferAttribute.js}
		</p>

		<hr class="interface-line"/>
		<h3 id="IGLTF">IGLTF <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] -  The animations.<br />
			[property:any asset] -  The asset.<br />
			[property:ICamera[] cameras] -  The cameras.<br />
			[property:IGLTFParser parser] -  The parser.<br />
			[property:IGroup scene] -  The scene.<br />
			[property:IGroup[] scenes] -  The scenes.<br />
			[property:any userData] -  The user data.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGLTFExporter">IGLTFExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGLTFExporter IGLTFExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void parse](  [param:IObject3D input],  [param:any onCompleted],  [param:IGLTFExporterOptions options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGLTFExporterOptions">IGLTFExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations]? -  The animations.<br />
			[property:boolean binary]? -  The binary.<br />
			[property:boolean embedImages]? -  The embed images.<br />
			[property:boolean forceIndices]? -  The force indices.<br />
			[property:boolean forcePowerOfTwoTextures]? -  The force power of two textures.<br />
			[property:boolean includeCustomExtensions]? -  The include custom extensions.<br />
			[property:boolean onlyVisible]? -  The only visible.<br />
			[property:boolean trs]? -  The trs.<br />
			[property:boolean truncateDrawRange]? -  The truncate draw range.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IGLTFLoader">IGLTFLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGLTFLoader IGLTFLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:IDRACOLoader dracoLoader] -  The draco loader.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void parse](  [param:string|ArrayBuffer data],  [param:string path],  [param:any onLoad],  [param:any onError]? ) <br />
			[method:IGLTFLoader register](  [param:any callback] ) <br />
			[method:IGLTFLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IGLTFLoader setDRACOLoader](  [param:IDRACOLoader dracoLoader] ) <br />
			[method:IGLTFLoader setKTX2Loader](  [param:IKTX2Loader ktx2Loader] ) <br />
			[method:IGLTFLoader setMeshoptDecoder](  [param:any meshoptDecoder] ) <br />
			[method:IGLTFLoader setPath](  [param:string path] ) <br />
			[method:IGLTFLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IGLTFLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IGLTFLoader setWithCredentials](  [param:boolean value] ) <br />
			[method:IGLTFLoader unregister](  [param:any callback] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGLTFLoaderPlugin">IGLTFLoaderPlugin <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any afterRoot]? -  The after root.<br />
			[property:any beforeRoot]? -  The before root.<br />
			[property:any createNodeAttachment]? -  The create node attachment.<br />
			[property:any createNodeMesh]? -  The create node mesh.<br />
			[property:any extendMaterialParams]? -  The extend material params.<br />
			[property:any getMaterialType]? -  The get material type.<br />
			[property:any loadBufferView]? -  The load buffer view.<br />
			[property:any loadMaterial]? -  The load material.<br />
			[property:any loadMesh]? -  The load mesh.<br />
			[property:any loadTexture]? -  The load texture.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGLTFParser">IGLTFParser <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Map associations] -  The associations.<br />
			[property:any extensions] -  The extensions.<br />
			[property:IFileLoader fileLoader] -  The file loader.<br />
			[property:any json] -  The json.<br />
			[property:any options] -  The options.<br />
			[property:IGLTFLoaderPlugin plugins] -  The plugins.<br />
			[property:ITextureLoader|IImageBitmapLoader textureLoader] -  The texture loader.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void assignFinalMaterial](  [param:IMesh object] ) <br />
			[method:Promise assignTexture](  [param:any materialParams],  [param:string mapName],  [param:any mapDef] ) <br />
			[method:Promise createNodeMesh](  [param:number nodeIndex] ) <br />
			[method:string createUniqueName](  [param:string originalName] ) <br />
			[method:Promise getDependencies](  [param:string type] ) <br />
			[method:Promise getDependency](  [param:string type],  [param:number index] ) <br />
			[method:any getMaterialType](  ) <br />
			[method:Promise loadAccessor](  [param:number accessorIndex] ) <br />
			[method:Promise loadAnimation](  [param:number animationIndex] ) <br />
			[method:Promise loadBuffer](  [param:number bufferIndex] ) <br />
			[method:Promise loadBufferView](  [param:number bufferViewIndex] ) <br />
			[method:Promise loadCamera](  [param:number cameraIndex] ) <br />
			[method:Promise loadGeometries](  [param:any primitives] ) <br />
			[method:Promise loadMaterial](  [param:number materialIndex] ) <br />
			[method:Promise loadMesh](  [param:number meshIndex] ) <br />
			[method:Promise loadNode](  [param:number nodeIndex] ) <br />
			[method:Promise loadScene](  ) <br />
			[method:Promise loadSkin](  [param:number skinIndex] ) <br />
			[method:Promise loadTexture](  [param:number textureIndex] ) <br />
			[method:Promise loadTextureImage](  [param:number textureIndex],  [param:any source],  [param:ILoader loader] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGLTFReference">IGLTFReference <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number materials]? -  The materials.<br />
			[property:number meshes]? -  The meshes.<br />
			[property:number nodes]? -  The nodes.<br />
			[property:number textures]? -  The textures.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGPUComputationRenderer">IGPUComputationRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGPUComputationRenderer IGPUComputationRenderer](  [param:number sizeX],  [param:number sizeY],  [param:IWebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:IGPUComputationVariable addIGPUComputationVariable](  [param:string variableName],  [param:string computeFragmentShader],  [param:ITexture initialValueTexture] ) <br />
			[method:void addResolutionDefine](  [param:IShaderMaterial materialShader] ) <br />
			[method:void compute](  ) <br />
			[method:IWebGLRenderTarget createRenderTarget](  [param:number sizeXTexture],  [param:number sizeYTexture],  [param:Wrapping wrapS],  [param:number wrapT],  [param:TextureFilter minFilter],  [param:TextureFilter magFilter] ) <br />
			[method:IShaderMaterial createShaderMaterial](  [param:string computeFragmentShader],  [param:any uniforms]? ) <br />
			[method:DataTexture createTexture](  ) <br />
			[method:void doRenderTarget](  [param:IMaterial material],  [param:IWebGLRenderTarget output] ) <br />
			[method:IWebGLRenderTarget getAlternateRenderTarget](  [param:IGPUComputationVariable variable] ) <br />
			[method:IWebGLRenderTarget getCurrentRenderTarget](  [param:IGPUComputationVariable variable] ) <br />
			[method:string init](  ) <br />
			[method:void renderTexture](  [param:ITexture input],  [param:ITexture output] ) <br />
			[method:void setDataType](  [param:TextureDataType type] ) <br />
			[method:void setIGPUComputationVariableDependencies](  [param:IGPUComputationVariable variable],  [param:IGPUComputationVariable[] dependencies] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGPUComputationVariable">IGPUComputationVariable <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IGPUComputationVariable[] dependencies] -  The dependencies.<br />
			[property:ITexture initialValueTexture] -  The initial value texture.<br />
			[property:number magFilter] -  The mag filter.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:number minFilter] -  The min filter.<br />
			[property:string name] -  The name.<br />
			[property:IWebGLRenderTarget[] renderTargets] -  The render targets.<br />
			[property:number wrapS] -  The wrap s.<br />
			[property:number wrapT] -  The wrap t.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGeometryCompressionUtils">IGeometryCompressionUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void compressNormals](  [param:IMesh mesh],  [param:string encodeMethod] ) <br />
			[method:void compressPositions](  [param:IMesh mesh] ) <br />
			[method:void compressUvs](  [param:IMesh mesh] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IGeometryUtils">IGeometryUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:object computeMorphedAttributes](  [param:IMesh|ILine|IPoints object] ) <br />
			[method:number estimateBytesUsed](  [param:IBufferGeometry geometry] ) <br />
			[method:number[] gosper](  [param:number size]? ) <br />
			[method:IVector3[] hilbert2D](  [param:IVector3 center]?,  [param:number size]?,  [param:number iterations]?,  [param:number v0]?,  [param:number v1]?,  [param:number v2]?,  [param:number v3]? ) <br />
			[method:IVector3[] hilbert3D](  [param:IVector3 center]?,  [param:number size]?,  [param:number iterations]?,  [param:number v0]?,  [param:number v1]?,  [param:number v2]?,  [param:number v3]?,  [param:number v4]?,  [param:number v5]?,  [param:number v6]?,  [param:number v7]? ) <br />
			[method:IInterleavedBufferAttribute interleaveAttributes](  [param:IBufferAttribute[] attributes] ) <br />
			[method:IBufferAttribute mergeBufferAttributes](  [param:IBufferAttribute[] attributes] ) <br />
			[method:IBufferGeometry mergeBufferGeometries](  [param:IBufferGeometry[] geometries],  [param:boolean useGroups]? ) <br />
			[method:IBufferGeometry mergeVertices](  [param:IBufferGeometry geometry],  [param:number tolerance]? ) <br />
			[method:IBufferGeometry toTrianglesDrawMode](  [param:IBufferGeometry geometry],  [param:TrianglesDrawModes drawMode] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IGlitchPass">IGlitchPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGlitchPass IGlitchPass](  [param:number dtSize]? ) - Creates an instance of ngx glitch pass.<br />
			[constructor:IGlitchPass IGlitchPass](  [param:number dtSize]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:number curF] -  The cur f.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:boolean goWild] -  The go wild.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number randX] -  The rand x.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDataTexture generateHeightmap](  [param:number dt_size] ) <br />
			[method:void generateTrigger](  ) <br />
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Glitch pass<br />
			See the [page:NgxGlitchPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/GlitchPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IGrantSolver">IGrantSolver <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGrantSolver IGrantSolver](  [param:ISkinnedMesh mesh],  [param:object[] grants] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object[] grants] -  The grants.<br />
			[property:ISkinnedMesh mesh] -  The mesh.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IGrantSolver addGrantRotation](  [param:IBone bone],  [param:IQuaternion q],  [param:number ratio] ) <br />
			[method:IGrantSolver update](  ) <br />
			[method:IGrantSolver updateOne](  [param:object[] gran] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IGridGeometry">IGridGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGridGeometry IGridGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:IColor colorW]?,  [param:IColor colorH]? ) <br />
			[constructor:IGridGeometry IGridGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:IColor colorW]?,  [param:IColor colorH]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] - The Parameters of grid geometry<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IGridGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			The Grid geometry.<br />
			See the [page:NgxGridGeometry ngx3js docs] page for details.<br />
			See the [example:ngx_geometry/GridGeometry ngx geometey] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="IGridHelper">IGridHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGridHelper IGridHelper](  [param:number size]?,  [param:number divisions]?,  [param:any color1]?,  [param:any color2]? ) <br />
			[constructor:IGridHelper IGridHelper](  [param:number size]?,  [param:number divisions]?,  [param:any color1]?,  [param:any color2]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IGridHelper IGridHelper](  [param:number size]?,  [param:number divisions]?,  [param:any color1]?,  [param:any color2]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IGridHelper IGridHelper](  [param:number size]?,  [param:number divisions]?,  [param:any color1]?,  [param:any color2]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IGridHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IGridHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IGridHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IGridHelper clear](  ) - Removes all child objects.<br />
			[method:IGridHelper clone](  [param:boolean recursive]? ) <br />
			[method:IGridHelper computeLineDistances](  ) <br />
			[method:IGridHelper copy](  [param:IGridHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IGridHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IGridHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IGridHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IGridHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IGridHelper rotateX](  [param:number angle] ) <br />
			[method:IGridHelper rotateY](  [param:number angle] ) <br />
			[method:IGridHelper rotateZ](  [param:number angle] ) <br />
			[method:void setColors](  [param:any color1]?,  [param:any color2]? ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IGridHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IGridHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IGridHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IGridHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IGroup">IGroup <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGroup IGroup](  ) <br />
			[constructor:IGroup IGroup](  ) <br />
			[constructor:IGroup IGroup](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isGroup] -  The is group.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IGroup add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IGroup applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IGroup attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IGroup clear](  ) - Removes all child objects.<br />
			[method:IGroup clone](  [param:boolean recursive]? ) <br />
			[method:IGroup copy](  [param:IGroup source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IGroup remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IGroup removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IGroup rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IGroup rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IGroup rotateX](  [param:number angle] ) <br />
			[method:IGroup rotateY](  [param:number angle] ) <br />
			[method:IGroup rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IGroup translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IGroup translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IGroup translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IGroup translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IGyroscope">IGyroscope <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IGyroscope IGyroscope](  ) <br />
			[constructor:IGyroscope IGyroscope](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IGyroscope add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IGyroscope applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IGyroscope attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IGyroscope clear](  ) - Removes all child objects.<br />
			[method:IGyroscope clone](  [param:boolean recursive]? ) <br />
			[method:IGyroscope copy](  [param:IGyroscope source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IGyroscope remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IGyroscope removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IGyroscope rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IGyroscope rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IGyroscope rotateX](  [param:number angle] ) <br />
			[method:IGyroscope rotateY](  [param:number angle] ) <br />
			[method:IGyroscope rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IGyroscope translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IGyroscope translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IGyroscope translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IGyroscope translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IHDRCubeTextureLoader">IHDRCubeTextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IHDRCubeTextureLoader IHDRCubeTextureLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:IRGBELoader hdrLoader] -  The hdr loader.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICubeTexture load](  [param:string[] urls],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IHDRCubeTextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IHDRCubeTextureLoader setDataType](  [param:TextureDataType type] ) <br />
			[method:IHDRCubeTextureLoader setPath](  [param:string path] ) <br />
			[method:IHDRCubeTextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IHDRCubeTextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IHDRCubeTextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IHSL">IHSL <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number h] -  The h.<br />
			[property:number l] -  The l.<br />
			[property:number s] -  The s.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IHalftonePass">IHalftonePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IHalftonePass IHalftonePass](  [param:number width],  [param:number height],  [param:IHalftonePassParameters params] ) - Creates an instance of ngx halftone pass.<br />
			[constructor:IHalftonePass IHalftonePass](  [param:number width],  [param:number height],  [param:IHalftonePassParameters params] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Halftone pass<br />
			See the [page:NgxHalftonePass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/HalftonePass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IHalftonePassParameters">IHalftonePassParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number blending]? -  The blending.<br />
			[property:number blendingMode]? -  The blending mode.<br />
			[property:boolean disable]? -  The disable.<br />
			[property:boolean greyscale]? -  The greyscale.<br />
			[property:number radius]? -  The radius.<br />
			[property:number rotateB]? -  The rotate b.<br />
			[property:number rotateG]? -  The rotate g.<br />
			[property:number rotateR]? -  The rotate r.<br />
			[property:number scatter]? -  The scatter.<br />
			[property:number shape]? -  The shape.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILight] &rarr;

		<h3 id="IHemisphereLight">IHemisphereLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IHemisphereLight IHemisphereLight](  [param:any skyColor]?,  [param:any groundColor]?,  [param:number intensity]? ) <br />
			[constructor:IHemisphereLight IHemisphereLight](  [param:any skyColor]?,  [param:any groundColor]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:IHemisphereLight IHemisphereLight](  [param:any skyColor]?,  [param:any groundColor]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IColor groundColor] -  The ground color.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isHemisphereLight] -  The is hemisphere light.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] -  The position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ILightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IHemisphereLight add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IHemisphereLight applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IHemisphereLight attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IHemisphereLight clear](  ) - Removes all child objects.<br />
			[method:IHemisphereLight clone](  [param:boolean recursive]? ) <br />
			[method:IHemisphereLight copy](  [param:IHemisphereLight source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IHemisphereLight remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IHemisphereLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IHemisphereLight rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IHemisphereLight rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IHemisphereLight rotateX](  [param:number angle] ) <br />
			[method:IHemisphereLight rotateY](  [param:number angle] ) <br />
			[method:IHemisphereLight rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IHemisphereLight translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IHemisphereLight translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IHemisphereLight translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IHemisphereLight translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IHemisphereLightHelper">IHemisphereLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IHemisphereLightHelper IHemisphereLightHelper](  [param:IHemisphereLight light],  [param:number size],  [param:any color]? ) <br />
			[constructor:IHemisphereLightHelper IHemisphereLightHelper](  [param:IHemisphereLight light],  [param:number size],  [param:any color]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:any color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IHemisphereLight light] -  The light.<br />
			[property:IMeshBasicMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IHemisphereLightHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IHemisphereLightHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IHemisphereLightHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IHemisphereLightHelper clear](  ) - Removes all child objects.<br />
			[method:IHemisphereLightHelper clone](  [param:boolean recursive]? ) <br />
			[method:IHemisphereLightHelper copy](  [param:IHemisphereLightHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IHemisphereLightHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IHemisphereLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IHemisphereLightHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IHemisphereLightHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IHemisphereLightHelper rotateX](  [param:number angle] ) <br />
			[method:IHemisphereLightHelper rotateY](  [param:number angle] ) <br />
			[method:IHemisphereLightHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IHemisphereLightHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IHemisphereLightHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IHemisphereLightHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IHemisphereLightHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILight] &rarr; [page:ILightProbe] &rarr;

		<h3 id="IHemisphereLightProbe">IHemisphereLightProbe <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IHemisphereLightProbe IHemisphereLightProbe](  [param:ISphericalHarmonics3 sh]?,  [param:number intensity]? ) <br />
			[constructor:IHemisphereLightProbe IHemisphereLightProbe](  [param:ISphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:IHemisphereLightProbe IHemisphereLightProbe](  [param:ISphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isHemisphereLightProbe] -  The is hemisphere light probe.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isLightProbe] -  The is light probe.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ISphericalHarmonics3 sh] -  The sh.<br />
			[property:ILightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IHemisphereLightProbe add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IHemisphereLightProbe applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IHemisphereLightProbe attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IHemisphereLightProbe clear](  ) - Removes all child objects.<br />
			[method:IHemisphereLightProbe clone](  [param:boolean recursive]? ) <br />
			[method:IHemisphereLightProbe copy](  [param:IHemisphereLightProbe source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IHemisphereLightProbe remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IHemisphereLightProbe removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IHemisphereLightProbe rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IHemisphereLightProbe rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IHemisphereLightProbe rotateX](  [param:number angle] ) <br />
			[method:IHemisphereLightProbe rotateY](  [param:number angle] ) <br />
			[method:IHemisphereLightProbe rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IHemisphereLightProbe translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IHemisphereLightProbe translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IHemisphereLightProbe translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IHemisphereLightProbe translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IIFCHighlightConfig">IIFCHighlightConfig <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number[] ids] -  The ids.<br />
			[property:IMaterial material]? -  The material.<br />
			[property:boolean removePrevious] -  The remove previous.<br />
			[property:IObject3D scene] -  The scene.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IIFCHighlightConfig] &rarr;

		<h3 id="IIFCHighlightConfigOfModel">IIFCHighlightConfigOfModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number[] ids] -  The ids.<br />
			[property:IMaterial material]? -  The material.<br />
			[property:number modelID] -  The model i d.<br />
			[property:boolean removePrevious] -  The remove previous.<br />
			[property:IObject3D scene] -  The scene.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IIFCJSONObject">IIFCJSONObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number expressID] -  The express i d.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IIFCLoader">IIFCLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IIFCLoader IIFCLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:IIFCManager ifcManager] -  The ifc manager.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:any url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Promise parse](  [param:ArrayBuffer buffer] ) <br />
			[method:IIFCLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IIFCLoader setPath](  [param:string path] ) <br />
			[method:IIFCLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IIFCLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IIFCLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IIFCLoaderSettings">IIFCLoaderSettings <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number CIRCLE_SEGMENTS_HIGH]? -  The c i r c l e_ s e g m e n t s_ h i g h.<br />
			[property:number CIRCLE_SEGMENTS_LOW]? -  The c i r c l e_ s e g m e n t s_ l o w.<br />
			[property:number CIRCLE_SEGMENTS_MEDIUM]? -  The c i r c l e_ s e g m e n t s_ m e d i u m.<br />
			[property:boolean COORDINATE_TO_ORIGIN] -  The c o o r d i n a t e_ t o_ o r i g i n.<br />
			[property:boolean USE_FAST_BOOLS] -  The u s e_ f a s t_ b o o l s.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IIFCManager">IIFCManager <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void addModelJSONData](  [param:number modelID],  [param:any data] ) - Adds the properties of a model as JSON data.<br />
			[method:void applyWebIfcConfig](  [param:IIFCLoaderSettings settings] ) - Applies a configuration for [link:https://ifcjs.github.io/info/docs/Guide/web-ifc/Introduction web-ifc].<br />
			[method:void close](  [param:number modelID],  [param:IScene scene]? ) - Closes the specified model and deletes it from the [link:https://threejs.org/docs/#api/en/scenes/Scene scene].<br />
			[method:void|IMesh createSubset](  [param:IIFCHighlightConfigOfModel config] ) - Creates a new geometric subset.<br />
			[method:void disposeMemory](  ) - Completely releases the WASM memory, thus drastically decreasing the memory use of the app.<br />
			Only use this in the following scenarios:<br />
			- If you don't need to access the properties of the IFC<br />
			- If you will provide the properties as JSON.<br />
			[method:any[] getAllItemsOfType](  [param:number modelID],  [param:number type],  [param:boolean verbose] ) - Returns all items of the specified type. You can import<br />
			the types from *web-ifc*.<br />
			Example to get all the standard walls of a project:<br />
			<code data-type="text">js<br />
			import { IFCWALLSTANDARDCASE } from 'web-ifc';<br />
			const walls = ifcLoader.getAllItemsOfType(IFCWALLSTANDARDCASE);<br />
			</code><br />
			[method:number getExpressId](  [param:IBufferGeometry geometry],  [param:number faceIndex] ) - Gets the **Express ID** to which the given face belongs.<br />
			This ID uniquely identifies this entity within this IFC file.<br />
			[method:string getIfcType](  [param:number modelID],  [param:number id] ) - Gets the ifc type of the specified item.<br />
			[method:any getItemProperties](  [param:number modelID],  [param:number id],  [param:boolean recursive]? ) - Gets the native properties of the given element.<br />
			[method:any[] getMaterialsProperties](  [param:number modelID],  [param:number id],  [param:boolean recursive]? ) - Gets the materials assigned to the given element.<br />
			[method:any[] getPropertySets](  [param:number modelID],  [param:number id],  [param:boolean recursive]? ) - Gets the [link:https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifckernel/lexical/ifcpropertyset.htm property sets]<br />
			assigned to the given element.<br />
			[method:void getSpatialStructure](  [param:number modelID] ) - Gets the spatial structure of the project. The<br />
			[link:https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifcproductextension/lexical/ifcspatialstructureelement.htm spatial structure]<br />
			is the hierarchical structure that organizes every IFC project (all physical items<br />
			are referenced to an element of the spatial structure). It is formed by<br />
			one IfcProject that contains one or more IfcSites, that contain one or more<br />
			IfcBuildings, that contain one or more IfcBuildingStoreys, that contain<br />
			one or more IfcSpaces.<br />
			[method:IMesh getSubset](  [param:number modelID],  [param:IMaterial material]? ) - Gets the mesh of the subset with the specified [link:https://threejs.org/docs/#api/en/materials/Material material].<br />
			If no material is given, this returns the subset with the original materials.<br />
			[method:any[] getTypeProperties](  [param:number modelID],  [param:number id],  [param:boolean recursive]? ) - Gets the properties of the type assigned to the element.<br />
			For example, if applied to a wall (IfcWall), this would get back the information<br />
			contained in the IfcWallType assigned to it, if any.<br />
			[method:void hideAllItems](  [param:number modelID] ) - Hides all the items of the specified model<br />
			[method:void hideItems](  [param:number modelID],  [param:number[] ids] ) - Hides the selected items in the specified model<br />
			[method:Promise parse](  [param:ArrayBuffer buffer] ) <br />
			[method:void removeSubset](  [param:number modelID],  [param:IObject3D parent]?,  [param:IMaterial material]? ) - Removes the specified subset.<br />
			[method:void setWasmPath](  [param:string path] ) - Sets the relative path of web-ifc.wasm file in the project.<br />
			Beware: you **must** serve this file in your page; this means<br />
			that you have to copy this files from *node_modules/web-ifc*<br />
			to your deployment directory.<br />
			If you don't use this methods,<br />
			IFC.js assumes that you are serving it in the root directory.<br />
			<br />
			Example if web-ifc.wasm is in dist/wasmDir:<br />
			`ifcLoader.setWasmPath("dist/wasmDir/");`<br />
			[method:void setupThreeMeshBVH](  [param:any computeBoundsTree],  [param:any disposeBoundsTree],  [param:any acceleratedRaycast] ) - Makes object picking a lot faster<br />
			Courtesy of gkjohnson's [link:https://github.com/gkjohnson/three-mesh-bvh work].<br />
			Import these objects from his library and pass them as arguments. IFC.js takes care of the rest!<br />
			[method:void showAllItems](  [param:number modelID] ) - Shows all the items of the specified model<br />
			[method:void showItems](  [param:number modelID],  [param:number[] ids] ) - Shows all the items of the specified model<br />
			[method:void useJSONData](  [param:boolean useJSON]? ) - Enables the JSON mode (which consumes way less memory) and eliminates the WASM data.<br />
			Only use this in the following scenarios:<br />
			- If you don't need to access the properties of the IFC<br />
			- If you will provide the properties as JSON.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IIFCModel">IIFCModel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IIFCModel IIFCModel](  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IIFCModel IIFCModel](  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:IIFCManager ifcManager] -  The ifc manager.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IIFCModel mesh] -  The mesh.<br />
			[property:number modelID] -  The model i d.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IIFCModel add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IIFCModel applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IIFCModel attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IIFCModel clear](  ) - Removes all child objects.<br />
			[method:IIFCModel clone](  [param:boolean recursive]? ) <br />
			[method:void close](  [param:IScene scene]? ) <br />
			[method:IIFCModel copy](  [param:IIFCModel source],  [param:boolean recursive]? ) <br />
			[method:void|IMesh createSubset](  [param:IIFCHighlightConfig config] ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:any[] getAllItemsOfType](  [param:number type],  [param:boolean verbose] ) <br />
			[method:number getExpressId](  [param:IBufferGeometry geometry],  [param:number faceIndex] ) <br />
			[method:string getIfcType](  [param:number id] ) <br />
			[method:any getItemProperties](  [param:number id],  [param:boolean recursive]? ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:any[] getPropertySets](  [param:number id],  [param:boolean recursive]? ) <br />
			[method:void getSpatialStructure](  ) <br />
			[method:IMesh getSubset](  [param:IMaterial material]? ) <br />
			[method:any[] getTypeProperties](  [param:number id],  [param:boolean recursive]? ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void hideAllItems](  ) <br />
			[method:void hideItems](  [param:number[] ids] ) <br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IIFCModel remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IIFCModel removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:void removeSubset](  [param:IObject3D parent]?,  [param:IMaterial material]? ) <br />
			[method:IIFCModel rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IIFCModel rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IIFCModel rotateX](  [param:number angle] ) <br />
			[method:IIFCModel rotateY](  [param:number angle] ) <br />
			[method:IIFCModel rotateZ](  [param:number angle] ) <br />
			[method:void setIFCManager](  [param:IIFCManager manager] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:void setWasmPath](  [param:string path] ) <br />
			[method:void showAllItems](  ) <br />
			[method:void showItems](  [param:number[] ids] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IIFCModel translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IIFCModel translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IIFCModel translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IIFCModel translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IIKS">IIKS <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number effector] -  The effector.<br />
			[property:number iteration] -  The iteration.<br />
			[property:any links] -  The links.<br />
			[property:number maxAngle] -  The max angle.<br />
			[property:number target] -  The target.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IPolyhedronBufferGeometry] &rarr;

		<h3 id="IIcosahedronBufferGeometry">IIcosahedronBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IIcosahedronBufferGeometry IIcosahedronBufferGeometry](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IIcosahedronBufferGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IPolyhedronGeometry] &rarr;

		<h3 id="IIcosahedronGeometry">IIcosahedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IIcosahedronGeometry IIcosahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IIcosahedronGeometry IIcosahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IIcosahedronGeometry IIcosahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IIcosahedronGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IImageBitmapLoader">IImageBitmapLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IImageBitmapLoader IImageBitmapLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:any isImageBitmapLoader] -  The is image bitmap loader.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:object options] -  The options.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IImageBitmapLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IImageBitmapLoader setOptions](  [param:object options] ) <br />
			[method:IImageBitmapLoader setPath](  [param:string path] ) <br />
			[method:IImageBitmapLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IImageBitmapLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IImageBitmapLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IImageLoader">IImageLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IImageLoader IImageLoader](  [param:ILoadingManager manager]? ) <br />
			[constructor:IImageLoader IImageLoader](  [param:ILoadingManager manager]?,  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:HTMLImageElement load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:HTMLImageElement load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]?,  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]?,  [param:string url],  [param:any onProgress]? ) <br />
			[method:IImageLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IImageLoader setPath](  [param:string path] ) <br />
			[method:IImageLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IImageLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IImageLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			A loader for loading an image.<br />
			Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IInputNode">IInputNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInputNode IInputNode](  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IInputNode IInputNode](  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IInputNode IInputNode](  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IInputNode copy](  [param:IInputNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IInputNode setLabel](  [param:string name] ) <br />
			[method:IInputNode setName](  [param:string name] ) <br />
			[method:IInputNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IInstancedBufferAttribute">IInstancedBufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInstancedBufferAttribute IInstancedBufferAttribute](  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:number meshPerAttribute] -  The mesh per attribute.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IInstancedBufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IInstancedBufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IInstancedBufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IInstancedBufferAttribute clone](  ) <br />
			[method:IInstancedBufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IInstancedBufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IInstancedBufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IInstancedBufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IInstancedBufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IInstancedBufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IInstancedBufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IInstancedBufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IInstancedBufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IInstancedBufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IInstancedBufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IInstancedBufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IInstancedBufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IInstancedBufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IInstancedBufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IInstancedBufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IInstancedBufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IInstancedBufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			see {@link https://github.com/mrdoob/three.js/blob/master/src/core/InstancedBufferAttribute.js|src/core/InstancedBufferAttribute.js}
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IInstancedBufferGeometry">IInstancedBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInstancedBufferGeometry IInstancedBufferGeometry](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:number instanceCount] -  The instance count.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:boolean isInstancedBufferGeometry] -  The is instanced buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number instances] ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IInstancedBufferGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			see {@link https://github.com/mrdoob/three.js/blob/master/src/core/InstancedBufferGeometry.js|src/core/InstancedBufferGeometry.js}
		</p>

		<hr class="interface-line"/>
		[page:IFlow] &rarr;

		<h3 id="IInstancedFlow">IInstancedFlow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInstancedFlow IInstancedFlow](  [param:number count],  [param:number curveCount],  [param:IBufferGeometry geometry],  [param:IMaterial material] ) <br />
			[constructor:IInstancedFlow IInstancedFlow](  [param:number count],  [param:number curveCount],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IMesh mesh],  [param:number numberOfCurves]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] curveArray] -  The curve array.<br />
			[property:number[] curveLengthArray] -  The curve length array.<br />
			[property:IInstancedMesh object3D] -  The object3 d.<br />
			[property:number[] offsets] -  The offsets.<br />
			[property:IDataTexture splineTexure] -  The spline texure.<br />
			[property:ISplineUniform uniforms] -  The uniforms.<br />
			[property:number[] whichCurve] -  The which curve.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void moveAlongCurve](  [param:number amount] ) <br />
			[method:void moveIndividualAlongCurve](  [param:number index],  [param:number offset] ) <br />
			[method:void setCurve](  [param:number index],  [param:number curveNo] ) <br />
			[method:void updateCurve](  [param:number index],  [param:ICurve curve] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IInterleavedBuffer] &rarr;

		<h3 id="IInstancedInterleavedBuffer">IInstancedInterleavedBuffer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInstancedInterleavedBuffer IInstancedInterleavedBuffer](  [param:ArrayLike array],  [param:number stride],  [param:number meshPerAttribute]? ) <br />
			[constructor:IInstancedInterleavedBuffer IInstancedInterleavedBuffer](  [param:ArrayLike array],  [param:number stride],  [param:number meshPerAttribute]?,  [param:ArrayLike array],  [param:number stride] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:number length] -  The length.<br />
			[property:number meshPerAttribute] -  The mesh per attribute.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number stride] -  The stride.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IInterleavedBuffer clone](  [param:object data] ) <br />
			[method:IInstancedInterleavedBuffer copy](  [param:IInterleavedBuffer source] ) <br />
			[method:IInterleavedBuffer copyAt](  [param:number index1],  [param:IInterleavedBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IInterleavedBuffer set](  [param:ArrayLike value],  [param:number index] ) <br />
			[method:IInterleavedBuffer setUsage](  [param:Usage usage] ) <br />
			[method:void toJSON](  [param:object data] ) 
		</p>

		<p class="desc">
			see {@link https://github.com/mrdoob/three.js/blob/master/src/core/InstancedInterleavedBuffer.js|src/core/InstancedInterleavedBuffer.js}
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IInstancedMesh">IInstancedMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInstancedMesh IInstancedMesh](  [param:TGeometry geometry],  [param:TMaterial material],  [param:number count] ) <br />
			[constructor:IInstancedMesh IInstancedMesh](  [param:TGeometry geometry],  [param:TMaterial material],  [param:number count],  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:IInstancedMesh IInstancedMesh](  [param:TGeometry geometry],  [param:TMaterial material],  [param:number count],  [param:TGeometry geometry]?,  [param:TMaterial material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:number count] -  The count.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:TGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:IInstancedBufferAttribute instanceColor] -  The instance color.<br />
			[property:IInstancedBufferAttribute instanceMatrix] -  The instance matrix.<br />
			[property:any isInstancedMesh] -  The is instanced mesh.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:TMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IInstancedMesh add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IInstancedMesh applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IInstancedMesh attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IInstancedMesh clear](  ) - Removes all child objects.<br />
			[method:IInstancedMesh clone](  [param:boolean recursive]? ) <br />
			[method:IInstancedMesh copy](  [param:IInstancedMesh source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:void getColorAt](  [param:number index],  [param:IColor color] ) <br />
			[method:void getMatrixAt](  [param:number index],  [param:IMatrix4 matrix] ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IInstancedMesh remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IInstancedMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IInstancedMesh rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IInstancedMesh rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IInstancedMesh rotateX](  [param:number angle] ) <br />
			[method:IInstancedMesh rotateY](  [param:number angle] ) <br />
			[method:IInstancedMesh rotateZ](  [param:number angle] ) <br />
			[method:void setColorAt](  [param:number index],  [param:IColor color] ) <br />
			[method:void setMatrixAt](  [param:number index],  [param:IMatrix4 matrix] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IInstancedMesh translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IInstancedMesh translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IInstancedMesh translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IInstancedMesh translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IInt16BufferAttribute">IInt16BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInt16BufferAttribute IInt16BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IInt16BufferAttribute IInt16BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IInt16BufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IInt16BufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IInt16BufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IInt16BufferAttribute clone](  ) <br />
			[method:IInt16BufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IInt16BufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IInt16BufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IInt16BufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IInt16BufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IInt16BufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IInt16BufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IInt16BufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IInt16BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IInt16BufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IInt16BufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IInt16BufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IInt16BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IInt16BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IInt16BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IInt16BufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IInt16BufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IInt16BufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IInt32BufferAttribute">IInt32BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInt32BufferAttribute IInt32BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IInt32BufferAttribute IInt32BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IInt32BufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IInt32BufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IInt32BufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IInt32BufferAttribute clone](  ) <br />
			[method:IInt32BufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IInt32BufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IInt32BufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IInt32BufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IInt32BufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IInt32BufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IInt32BufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IInt32BufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IInt32BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IInt32BufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IInt32BufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IInt32BufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IInt32BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IInt32BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IInt32BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IInt32BufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IInt32BufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IInt32BufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IInt8BufferAttribute">IInt8BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInt8BufferAttribute IInt8BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IInt8BufferAttribute IInt8BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IInt8BufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IInt8BufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IInt8BufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IInt8BufferAttribute clone](  ) <br />
			[method:IInt8BufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IInt8BufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IInt8BufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IInt8BufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IInt8BufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IInt8BufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IInt8BufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IInt8BufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IInt8BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IInt8BufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IInt8BufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IInt8BufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IInt8BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IInt8BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IInt8BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IInt8BufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IInt8BufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IInt8BufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IIntNode">IIntNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IIntNode IIntNode](  [param:number value]? ) <br />
			[constructor:IIntNode IIntNode](  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IIntNode IIntNode](  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IIntNode IIntNode](  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IIntNode copy](  [param:IIntNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IIntNode setLabel](  [param:string name] ) <br />
			[method:IIntNode setName](  [param:string name] ) <br />
			[method:IIntNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IGroup] &rarr;

		<h3 id="IInteractiveGroup">IInteractiveGroup <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInteractiveGroup IInteractiveGroup](  [param:IWebGLRenderer renderer],  [param:ICamera camera] ) <br />
			[constructor:IInteractiveGroup IInteractiveGroup](  [param:IWebGLRenderer renderer],  [param:ICamera camera] ) <br />
			[constructor:IInteractiveGroup IInteractiveGroup](  [param:IWebGLRenderer renderer],  [param:ICamera camera] ) <br />
			[constructor:IInteractiveGroup IInteractiveGroup](  [param:IWebGLRenderer renderer],  [param:ICamera camera] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isGroup] -  The is group.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IInteractiveGroup add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IInteractiveGroup applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IInteractiveGroup attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IInteractiveGroup clear](  ) - Removes all child objects.<br />
			[method:IInteractiveGroup clone](  [param:boolean recursive]? ) <br />
			[method:IInteractiveGroup copy](  [param:IInteractiveGroup source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IInteractiveGroup remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IInteractiveGroup removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IInteractiveGroup rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IInteractiveGroup rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IInteractiveGroup rotateX](  [param:number angle] ) <br />
			[method:IInteractiveGroup rotateY](  [param:number angle] ) <br />
			[method:IInteractiveGroup rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IInteractiveGroup translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IInteractiveGroup translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IInteractiveGroup translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IInteractiveGroup translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IInterleavedBuffer">IInterleavedBuffer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInterleavedBuffer IInterleavedBuffer](  [param:ArrayLike array],  [param:number stride] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:number length] -  The length.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number stride] -  The stride.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IInterleavedBuffer clone](  [param:object data] ) <br />
			[method:IInterleavedBuffer copy](  [param:IInterleavedBuffer source] ) <br />
			[method:IInterleavedBuffer copyAt](  [param:number index1],  [param:IInterleavedBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IInterleavedBuffer set](  [param:ArrayLike value],  [param:number index] ) <br />
			[method:IInterleavedBuffer setUsage](  [param:Usage usage] ) <br />
			[method:void toJSON](  [param:object data] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IInterleavedBufferAttribute">IInterleavedBufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInterleavedBufferAttribute IInterleavedBufferAttribute](  [param:IInterleavedBuffer interleavedBuffer],  [param:number itemSize],  [param:number offset],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IInterleavedBuffer data] -  The data.<br />
			[property:any isInterleavedBufferAttribute] -  The is interleaved buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:number offset] -  The offset.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IInterleavedBufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IInterleavedBufferAttribute applyNormalMatrix](  [param:IMatrix matrix] ) <br />
			[method:IBufferAttribute clone](  [param:object data]? ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IInterleavedBufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IInterleavedBufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IInterleavedBufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IInterleavedBufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IInterleavedBufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IInterleavedBufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IInterleavedBufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  [param:object data]? ) <br />
			[method:IInterleavedBufferAttribute transformDirection](  [param:IMatrix matrix] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IInterpolant">IInterpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IInterpolant IInterpolant](  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] -  The parameter positions.<br />
			[property:any resultBuffer] -  The result buffer.<br />
			[property:any sampleValues] -  The sample values.<br />
			[property:number valueSize] -  The value size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any evaluate](  [param:number time] ) <br />
			[method:any evaluate](  [param:number time],  [param:number time] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IIntersection">IIntersection <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number distance] -  The distance.<br />
			[property:number distanceToRay]? -  The distance to ray.<br />
			[property:IFace face]? -  The face.<br />
			[property:number faceIndex]? -  The face index.<br />
			[property:number index]? -  The index.<br />
			[property:number instanceId]? -  The instance id.<br />
			[property:TIntersected object] -  The object.<br />
			[property:IVector3 point] -  The point.<br />
			[property:IVector2 uv]? -  The uv.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IJoinNode">IJoinNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IJoinNode IJoinNode](  [param:INode x],  [param:INode y],  [param:INode z]?,  [param:INode w]? ) <br />
			[constructor:IJoinNode IJoinNode](  [param:INode x],  [param:INode y],  [param:INode z]?,  [param:INode w]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IJoinNode IJoinNode](  [param:INode x],  [param:INode y],  [param:INode z]?,  [param:INode w]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:INode w] -  The w.<br />
			[property:INode x] -  The x.<br />
			[property:INode y] -  The y.<br />
			[property:INode z] -  The z.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IJoinNode copy](  [param:IJoinNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:number getNumElements](  ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IJoinNode setLabel](  [param:string name] ) <br />
			[method:IJoinNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IKMZLoader">IKMZLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IKMZLoader IKMZLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ICollada parse](  [param:ArrayBuffer data] ) <br />
			[method:IKMZLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IKMZLoader setPath](  [param:string path] ) <br />
			[method:IKMZLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IKMZLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IKMZLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IKTX">IKTX <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:PixelFormat|CompressedPixelFormat format] -  The format.<br />
			[property:number height] -  The height.<br />
			[property:boolean isCubemap] -  The is cubemap.<br />
			[property:number mipmapCount] -  The mipmap count.<br />
			[property:object[] mipmaps] -  The mipmaps.<br />
			[property:number width] -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr; [page:ICompressedTextureLoader] &rarr;

		<h3 id="IKTX2Loader">IKTX2Loader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IKTX2Loader IKTX2Loader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IKTX2Loader detectSupport](  [param:IWebGLRenderer renderer] ) <br />
			[method:IKTX2Loader dispose](  ) <br />
			[method:ICompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IKTX2Loader parse](  [param:ArrayBuffer buffer],  [param:any onLoad],  [param:any onError]? ) <br />
			[method:IKTX2Loader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IKTX2Loader setPath](  [param:string path] ) <br />
			[method:IKTX2Loader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IKTX2Loader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IKTX2Loader setTranscoderPath](  [param:string path] ) <br />
			[method:IKTX2Loader setWithCredentials](  [param:boolean value] ) <br />
			[method:IKTX2Loader setWorkerLimit](  [param:number limit] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr; [page:ICompressedTextureLoader] &rarr;

		<h3 id="IKTXLoader">IKTXLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IKTXLoader IKTXLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IKTX parse](  [param:ArrayBuffer buffer],  [param:boolean loadMipmaps] ) <br />
			[method:IKTXLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IKTXLoader setPath](  [param:string path] ) <br />
			[method:IKTXLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IKTXLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IKTXLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IKeyframeTrack">IKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:ILinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:ICubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:IKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:IKeyframeTrack optimize](  ) <br />
			[method:IKeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:IKeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:IKeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:IKeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ILDrawLoader">ILDrawLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILDrawLoader ILDrawLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addMaterial](  [param:IMaterial material] ) <br />
			[method:IMaterial getMaterial](  [param:string colourCode] ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void parse](  [param:string text],  [param:string path],  [param:any onLoad] ) <br />
			[method:ILDrawLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:void setFileMap](  [param:Record fileMap] ) <br />
			[method:void setMaterials](  [param:IMaterial[] materials] ) <br />
			[method:ILDrawLoader setPath](  [param:string path] ) <br />
			[method:ILDrawLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ILDrawLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ILDrawLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ILOD">ILOD <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILOD ILOD](  ) <br />
			[constructor:ILOD ILOD](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLOD] -  The is l o d.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:any levels] -  The levels.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:any[] objects] -  The objects.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILOD add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ILOD addLevel](  [param:IObject3D object],  [param:number distance]? ) <br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILOD applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILOD attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILOD clear](  ) - Removes all child objects.<br />
			[method:ILOD clone](  [param:boolean recursive]? ) <br />
			[method:ILOD copy](  [param:ILOD source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:number getCurrentLevel](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IObject3D getObjectForDistance](  [param:number distance] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILOD remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILOD removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILOD rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILOD rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILOD rotateX](  [param:number angle] ) <br />
			[method:ILOD rotateY](  [param:number angle] ) <br />
			[method:ILOD rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:ILOD translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILOD translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILOD translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILOD translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  [param:ICamera camera] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ILUT3dlLoader">ILUT3dlLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILUT3dlLoader ILUT3dlLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ILUT3dlResult parse](  [param:string data] ) <br />
			[method:ILUT3dlLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ILUT3dlLoader setPath](  [param:string path] ) <br />
			[method:ILUT3dlLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ILUT3dlLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ILUT3dlLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILUT3dlResult">ILUT3dlResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number size] -  The size.<br />
			[property:IDataTexture texture] -  The texture.<br />
			[property:IDataTexture3D texture3D] -  The texture3 d.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ILUTCubeLoader">ILUTCubeLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILUTCubeLoader ILUTCubeLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ILUTCubeResult parse](  [param:string data] ) <br />
			[method:ILUTCubeLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ILUTCubeLoader setPath](  [param:string path] ) <br />
			[method:ILUTCubeLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ILUTCubeLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ILUTCubeLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILUTCubeResult">ILUTCubeResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IVector3 domainMax] -  The domain max.<br />
			[property:IVector3 domainMin] -  The domain min.<br />
			[property:number size] -  The size.<br />
			[property:IDataTexture texture] -  The texture.<br />
			[property:IDataTexture3D texture3D] -  The texture3 d.<br />
			[property:string title] -  The title.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ILUTPass">ILUTPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILUTPass ILUTPass](  [param:ILUTPassParameters params] ) - Creates an instance of ngx lutpass.<br />
			[constructor:ILUTPass ILUTPass](  [param:ILUTPassParameters params] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:number intensity]? -  The intensity.<br />
			[property:IDataTexture|IDataTexture3D lut]? -  The lut.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			LUT pass<br />
			See the [page:NgxLUTPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/LUTPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="ILUTPassParameters">ILUTPassParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number intensity]? -  The intensity.<br />
			[property:IDataTexture|IDataTexture3D lut]? -  The lut.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILWO">ILWO <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IMaterial[] materials] -  The materials.<br />
			[property:IObject3D[] meshes] -  The meshes.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ILWOLoader">ILWOLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILWOLoader ILWOLoader](  [param:ILoadingManager manager]?,  [param:ILWOLoaderParameters parameters]? ) <br />
			[constructor:ILWOLoader ILWOLoader](  [param:ILoadingManager manager]?,  [param:ILWOLoaderParameters parameters]?,  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ILWO parse](  [param:ArrayBuffer data],  [param:string path],  [param:string modelName] ) <br />
			[method:ILWOLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ILWOLoader setPath](  [param:string path] ) <br />
			[method:ILWOLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ILWOLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ILWOLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILWOLoaderParameters">ILWOLoaderParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string resourcePath]? - Base content delivery folder path, use when it differs from Lightwave default structure
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ILatheGeometry">ILatheGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILatheGeometry ILatheGeometry](  [param:any points]?,  [param:number segments]?,  [param:number phiStart]?,  [param:number phiLength]? ) <br />
			[constructor:ILatheGeometry ILatheGeometry](  [param:any points]?,  [param:number segments]?,  [param:number phiStart]?,  [param:number phiLength]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ILatheGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILayers">ILayers <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILayers ILayers](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number mask] -  The mask.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void disable](  [param:number channel] ) <br />
			[method:void disableAll](  ) <br />
			[method:void enable](  [param:number channel] ) <br />
			[method:void enableAll](  ) <br />
			[method:void set](  [param:number channel] ) <br />
			[method:boolean test](  [param:ILayers layers] ) <br />
			[method:void toggle](  [param:number channel] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="ILensflare">ILensflare <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILensflare ILensflare](  ) <br />
			[constructor:ILensflare ILensflare](  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:ILensflare ILensflare](  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLensflare] -  The is lensflare.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILensflare add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addElement](  [param:ILensflareElement element] ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILensflare applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILensflare attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILensflare clear](  ) - Removes all child objects.<br />
			[method:ILensflare clone](  [param:boolean recursive]? ) <br />
			[method:ILensflare copy](  [param:ILensflare source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILensflare remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILensflare removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILensflare rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILensflare rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILensflare rotateX](  [param:number angle] ) <br />
			[method:ILensflare rotateY](  [param:number angle] ) <br />
			[method:ILensflare rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ILensflare translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILensflare translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILensflare translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILensflare translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILensflareElement">ILensflareElement <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILensflareElement ILensflareElement](  [param:ITexture texture],  [param:number size]?,  [param:number distance]?,  [param:IColor color]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IColor color] -  The color.<br />
			[property:number distance] -  The distance.<br />
			[property:number size] -  The size.<br />
			[property:ITexture texture] -  The texture.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ILight">ILight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILight ILight](  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:ILight ILight](  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ILightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILight add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILight applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILight attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILight clear](  ) - Removes all child objects.<br />
			[method:ILight clone](  [param:boolean recursive]? ) <br />
			[method:ILight copy](  [param:ILight source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILight remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILight rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILight rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILight rotateX](  [param:number angle] ) <br />
			[method:ILight rotateY](  [param:number angle] ) <br />
			[method:ILight rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ILight translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILight translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILight translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILight translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			Abstract base class for lights.
		</p>

		<hr class="interface-line"/>
		<h3 id="ILightMapContainers">ILightMapContainers <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IMaterial|IMaterial[] basicMat] -  The basic mat.<br />
			[property:IObject3D object] -  The object.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="ILightNode">ILightNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILightNode ILightNode](  [param:string scope]? ) <br />
			[constructor:ILightNode ILightNode](  [param:string scope]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ILightNode ILightNode](  [param:string scope]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string TOTAL] -  The t o t a l.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ILightNode copy](  [param:ILightNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ILightNode setLabel](  [param:string name] ) <br />
			[method:ILightNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILight] &rarr;

		<h3 id="ILightProbe">ILightProbe <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILightProbe ILightProbe](  [param:ISphericalHarmonics3 sh]?,  [param:number intensity]? ) <br />
			[constructor:ILightProbe ILightProbe](  [param:ISphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:ILightProbe ILightProbe](  [param:ISphericalHarmonics3 sh]?,  [param:number intensity]?,  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isLightProbe] -  The is light probe.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ISphericalHarmonics3 sh] -  The sh.<br />
			[property:ILightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILightProbe add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILightProbe applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILightProbe attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILightProbe clear](  ) - Removes all child objects.<br />
			[method:ILightProbe clone](  [param:boolean recursive]? ) <br />
			[method:ILightProbe copy](  [param:ILightProbe source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILightProbe remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILightProbe removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILightProbe rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILightProbe rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILightProbe rotateX](  [param:number angle] ) <br />
			[method:ILightProbe rotateY](  [param:number angle] ) <br />
			[method:ILightProbe rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ILightProbe translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILightProbe translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILightProbe translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILightProbe translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILightProbeGenerator">ILightProbeGenerator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:ILightProbe fromCubeRenderTarget](  [param:IWebGLRenderer renderer],  [param:IWebGLCubeRenderTarget cubeRenderTarget] ) <br />
			[method:ILightProbe fromCubeTexture](  [param:ICubeTexture cubeTexture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="ILightProbeHelper">ILightProbeHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILightProbeHelper ILightProbeHelper](  [param:ILightProbe lightProbe],  [param:number size] ) <br />
			[constructor:ILightProbeHelper ILightProbeHelper](  [param:ILightProbe lightProbe],  [param:number size],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:ILightProbeHelper ILightProbeHelper](  [param:ILightProbe lightProbe],  [param:number size],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:ILightProbe lightProbe] -  The light probe.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:number size] -  The size.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILightProbeHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILightProbeHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILightProbeHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILightProbeHelper clear](  ) - Removes all child objects.<br />
			[method:ILightProbeHelper clone](  [param:boolean recursive]? ) <br />
			[method:ILightProbeHelper copy](  [param:ILightProbeHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILightProbeHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILightProbeHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILightProbeHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILightProbeHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILightProbeHelper rotateX](  [param:number angle] ) <br />
			[method:ILightProbeHelper rotateY](  [param:number angle] ) <br />
			[method:ILightProbeHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ILightProbeHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILightProbeHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILightProbeHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILightProbeHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILightShadow">ILightShadow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:number bias] -  The bias.<br />
			[property:number blurSamples] -  The blur samples.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:IWebGLRenderTarget map] -  The map.<br />
			[property:IWebGLRenderTarget mapPass] -  The map pass.<br />
			[property:IVector2|Vector2 mapSize] -  The map size.<br />
			[property:IMatrix4 matrix] -  The matrix.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number normalBias] -  The normal bias.<br />
			[property:number radius] -  The radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILightShadow clone](  [param:boolean recursive]? ) <br />
			[method:ILightShadow copy](  [param:ILightShadow source] ) <br />
			[method:void dispose](  ) <br />
			[method:IVector2 getFrameExtents](  ) <br />
			[method:number getFrustum](  ) <br />
			[method:IVector4 getViewport](  [param:number viewportIndex] ) <br />
			[method:any toJSON](  ) <br />
			[method:void updateMatrices](  [param:ILight light],  [param:number viewportIndex]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILightningSegment">ILightningSegment <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number fraction0] -  The fraction0.<br />
			[property:number fraction1] -  The fraction1.<br />
			[property:number iteration] -  The iteration.<br />
			[property:IVector3 linPos0] -  The lin pos0.<br />
			[property:IVector3 linPos1] -  The lin pos1.<br />
			[property:IVector3 pos0] -  The pos0.<br />
			[property:IVector3 pos1] -  The pos1.<br />
			[property:number positionVariationFactor] -  The position variation factor.<br />
			[property:number radius0] -  The radius0.<br />
			[property:number radius1] -  The radius1.<br />
			[property:IVector3 up0] -  The up0.<br />
			[property:IVector3 up1] -  The up1.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILightningStorm">ILightningStorm <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILightningStorm ILightningStorm](  [param:IStormParams stormParams]? ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILightningStorm clone](  ) <br />
			[method:ILightningStorm copy](  [param:ILightningStorm source] ) <br />
			[method:void update](  [param:number time] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILightningStrike">ILightningStrike <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILightningStrike ILightningStrike](  [param:IRayParameters rayParameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number state] -  The state.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILightningStrike clone](  ) <br />
			[method:ILightningStrike copy](  [param:ILightningStrike source] ) <br />
			[method:IRayParameters copyParameters](  [param:IRayParameters dest]?,  [param:IRayParameters source]? ) <br />
			[method:void update](  [param:number time] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILightningSubray">ILightningSubray <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number beginVanishingTime] -  The begin vanishing time.<br />
			[property:number birthTime] -  The birth time.<br />
			[property:number deathTime] -  The death time.<br />
			[property:number endPropagationTime] -  The end propagation time.<br />
			[property:IVector3 linPos0] -  The lin pos0.<br />
			[property:IVector3 linPos1] -  The lin pos1.<br />
			[property:number maxIterations] -  The max iterations.<br />
			[property:IVector3 pos0] -  The pos0.<br />
			[property:IVector3 pos1] -  The pos1.<br />
			[property:number propagationTimeFactor] -  The propagation time factor.<br />
			[property:number radius0] -  The radius0.<br />
			[property:number radius1] -  The radius1.<br />
			[property:number recursion] -  The recursion.<br />
			[property:number roughness] -  The roughness.<br />
			[property:number seed] -  The seed.<br />
			[property:number straightness] -  The straightness.<br />
			[property:number timeScale] -  The time scale.<br />
			[property:IVector3 up0] -  The up0.<br />
			[property:IVector3 up1] -  The up1.<br />
			[property:number vanishingTimeFactor] -  The vanishing time factor.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ILine">ILine <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILine ILine](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:ILine ILine](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:TGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:TMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILine add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILine applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILine attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILine clear](  ) - Removes all child objects.<br />
			[method:ILine clone](  [param:boolean recursive]? ) <br />
			[method:ILine computeLineDistances](  ) <br />
			[method:ILine copy](  [param:ILine source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILine remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILine removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILine rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILine rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILine rotateX](  [param:number angle] ) <br />
			[method:ILine rotateY](  [param:number angle] ) <br />
			[method:ILine rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ILine translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILine translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILine translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILine translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr; [page:ILineSegments2] &rarr;

		<h3 id="ILine2">ILine2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILine2 ILine2](  [param:ILineGeometry geometry]?,  [param:ILineMaterial material]? ) <br />
			[constructor:ILine2 ILine2](  [param:ILineGeometry geometry]?,  [param:ILineMaterial material]?,  [param:ILineSegmentsGeometry geometry]?,  [param:ILineMaterial material]? ) <br />
			[constructor:ILine2 ILine2](  [param:ILineGeometry geometry]?,  [param:ILineMaterial material]?,  [param:ILineSegmentsGeometry geometry]?,  [param:ILineMaterial material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:ILine2 ILine2](  [param:ILineGeometry geometry]?,  [param:ILineMaterial material]?,  [param:ILineSegmentsGeometry geometry]?,  [param:ILineMaterial material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:ILineGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine2] -  The is line2.<br />
			[property:any isLineSegments2] -  The is line segments2.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:ILineMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILine2 add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILine2 applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILine2 attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILine2 clear](  ) - Removes all child objects.<br />
			[method:ILine2 clone](  [param:boolean recursive]? ) <br />
			[method:ILine2 computeLineDistances](  ) <br />
			[method:ILine2 copy](  [param:ILine2 source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILine2 remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILine2 removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILine2 rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILine2 rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILine2 rotateX](  [param:number angle] ) <br />
			[method:ILine2 rotateY](  [param:number angle] ) <br />
			[method:ILine2 rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ILine2 translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILine2 translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILine2 translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILine2 translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILine3">ILine3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILine3 ILine3](  [param:IVector3|Vector3 start]?,  [param:IVector3|Vector3 end]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IVector3 end] -  The end.<br />
			[property:IVector3 start] -  The start.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILine3 applyMatrix4](  [param:IMatrix4 matrix] ) <br />
			[method:IVector3 at](  [param:number t],  [param:IVector3|Vector3 target] ) <br />
			[method:ILine3 clone](  ) <br />
			[method:IVector3 closestPointToPoint](  [param:IVector3|Vector3 point],  [param:boolean clampToLine],  [param:IVector3|Vector3 target] ) <br />
			[method:number closestPointToPointParameter](  [param:IVector3|Vector3 point],  [param:boolean clampToLine]? ) <br />
			[method:ILine3 copy](  [param:ILine3 line] ) <br />
			[method:IVector3 delta](  [param:IVector3|Vector3 target] ) <br />
			[method:number distance](  ) <br />
			[method:number distanceSq](  ) <br />
			[method:boolean equals](  [param:ILine3 line] ) <br />
			[method:IVector3 getCenter](  [param:IVector3|Vector3 target] ) <br />
			[method:ILine3 set](  [param:IVector3|Vector3 start]?,  [param:IVector3|Vector3 end]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="ILineBasicMaterial">ILineBasicMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineBasicMaterial ILineBasicMaterial](  [param:ILineBasicMaterialParameters parameters]? ) <br />
			[constructor:ILineBasicMaterial ILineBasicMaterial](  [param:ILineBasicMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string linecap] -  The linecap.<br />
			[property:string linejoin] -  The linejoin.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ILineBasicMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:ILineBasicMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ILineBasicMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="ILineBasicMaterialParameters">ILineBasicMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string linecap]? -  The linecap.<br />
			[property:string linejoin]? -  The linejoin.<br />
			[property:number linewidth]? -  The linewidth.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="ILineCurve">ILineCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineCurve ILineCurve](  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2] ) <br />
			[constructor:ILineCurve ILineCurve](  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:IVector2|Vector2 v1] -  The v1.<br />
			[property:IVector2|Vector2 v2] -  The v2.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILineCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ILineCurve copy](  [param:ICurve source] ) <br />
			[method:ILineCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector2|Vector2 getPoint](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getPointAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:void getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:void getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector2|Vector2 getTangent](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getTangentAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="ILineCurve3">ILineCurve3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineCurve3 ILineCurve3](  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2] ) <br />
			[constructor:ILineCurve3 ILineCurve3](  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:IVector3|Vector3 v1] -  The v1.<br />
			[property:IVector3|Vector3 v2] -  The v2.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILineCurve3 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ILineCurve3 copy](  [param:ICurve source] ) <br />
			[method:ILineCurve3 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector3 getPoint](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getPointAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:IVector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:IVector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector3 getTangent](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getTangentAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:ILineBasicMaterial] &rarr;

		<h3 id="ILineDashedMaterial">ILineDashedMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineDashedMaterial ILineDashedMaterial](  [param:ILineDashedMaterialParameters parameters]? ) <br />
			[constructor:ILineDashedMaterial ILineDashedMaterial](  [param:ILineDashedMaterialParameters parameters]?,  [param:ILineBasicMaterialParameters parameters]? ) <br />
			[constructor:ILineDashedMaterial ILineDashedMaterial](  [param:ILineDashedMaterialParameters parameters]?,  [param:ILineBasicMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:number dashSize] -  The dash size.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number gapSize] -  The gap size.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isLineDashedMaterial] -  The is line dashed material.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string linecap] -  The linecap.<br />
			[property:string linejoin] -  The linejoin.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number scale] -  The scale.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ILineDashedMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:ILineDashedMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ILineDashedMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr; [page:ILineBasicMaterialParameters] &rarr;

		<h3 id="ILineDashedMaterialParameters">ILineDashedMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:number dashSize]? -  The dash size.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:number gapSize]? -  The gap size.<br />
			[property:string linecap]? -  The linecap.<br />
			[property:string linejoin]? -  The linejoin.<br />
			[property:number linewidth]? -  The linewidth.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number scale]? -  The scale.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IInstancedBufferGeometry] &rarr; [page:ILineSegmentsGeometry] &rarr;

		<h3 id="ILineGeometry">ILineGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineGeometry ILineGeometry](  ) <br />
			[constructor:ILineGeometry ILineGeometry](  ) <br />
			[constructor:ILineGeometry ILineGeometry](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:number instanceCount] -  The instance count.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:boolean isInstancedBufferGeometry] -  The is instanced buffer geometry.<br />
			[property:any isLineGeometry] -  The is line geometry.<br />
			[property:any isLineSegmentsGeometry] -  The is line segments geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number instances] ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:ILineGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ILineGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:ILineGeometry fromEdgesGeometry](  [param:IEdgesGeometry geometry] ) <br />
			[method:ILineGeometry fromLine](  [param:ILine line] ) <br />
			[method:ILineGeometry fromLineSegments](  [param:ILineSegments lineSegments] ) <br />
			[method:ILineGeometry fromMesh](  [param:IMesh mesh] ) <br />
			[method:ILineGeometry fromWireframeGeometry](  [param:IWireframeGeometry geometry] ) <br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:ILineGeometry setColors](  [param:Float32Array|number[] array] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:ILineGeometry setPositions](  [param:Float32Array|number[] array] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr;

		<h3 id="ILineLoop">ILineLoop <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineLoop ILineLoop](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:ILineLoop ILineLoop](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:ILineLoop ILineLoop](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:TGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineLoop] -  The is line loop.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:TMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILineLoop add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILineLoop applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILineLoop attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILineLoop clear](  ) - Removes all child objects.<br />
			[method:ILineLoop clone](  [param:boolean recursive]? ) <br />
			[method:ILineLoop computeLineDistances](  ) <br />
			[method:ILineLoop copy](  [param:ILineLoop source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILineLoop remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILineLoop removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILineLoop rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILineLoop rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILineLoop rotateX](  [param:number angle] ) <br />
			[method:ILineLoop rotateY](  [param:number angle] ) <br />
			[method:ILineLoop rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ILineLoop translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILineLoop translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILineLoop translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILineLoop translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr;

		<h3 id="ILineMaterial">ILineMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineMaterial ILineMaterial](  [param:ILineMaterialParameters parameters]? ) <br />
			[constructor:ILineMaterial ILineMaterial](  [param:ILineMaterialParameters parameters]?,  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:ILineMaterial ILineMaterial](  [param:ILineMaterialParameters parameters]?,  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:number dashOffset] -  The dash offset.<br />
			[property:number dashScale] -  The dash scale.<br />
			[property:number dashSize] -  The dash size.<br />
			[property:boolean dashed] -  The dashed.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:number gapSize] -  The gap size.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isLineMaterial] -  The is line material.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:IVector2 resolution] -  The resolution.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.<br />
			[property:boolean worldUnits] -  The world units.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ILineMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:ILineMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="ILineMaterialParameters">ILineMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:number color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:number dashOffset]? -  The dash offset.<br />
			[property:number dashScale]? -  The dash scale.<br />
			[property:number dashSize]? -  The dash size.<br />
			[property:boolean dashed]? -  The dashed.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:number gapSize]? -  The gap size.<br />
			[property:number linewidth]? -  The linewidth.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:IVector2 resolution]? -  The resolution.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:boolean worldUnits]? -  The world units.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr;

		<h3 id="ILineSegments">ILineSegments <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineSegments ILineSegments](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:ILineSegments ILineSegments](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:ILineSegments ILineSegments](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:TGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:TMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILineSegments add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILineSegments applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILineSegments attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILineSegments clear](  ) - Removes all child objects.<br />
			[method:ILineSegments clone](  [param:boolean recursive]? ) <br />
			[method:ILineSegments computeLineDistances](  ) <br />
			[method:ILineSegments copy](  [param:ILineSegments source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILineSegments remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILineSegments removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILineSegments rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILineSegments rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILineSegments rotateX](  [param:number angle] ) <br />
			[method:ILineSegments rotateY](  [param:number angle] ) <br />
			[method:ILineSegments rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ILineSegments translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILineSegments translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILineSegments translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILineSegments translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="ILineSegments2">ILineSegments2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineSegments2 ILineSegments2](  [param:ILineSegmentsGeometry geometry]?,  [param:ILineMaterial material]? ) <br />
			[constructor:ILineSegments2 ILineSegments2](  [param:ILineSegmentsGeometry geometry]?,  [param:ILineMaterial material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:ILineSegments2 ILineSegments2](  [param:ILineSegmentsGeometry geometry]?,  [param:ILineMaterial material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:ILineSegmentsGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLineSegments2] -  The is line segments2.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:ILineMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILineSegments2 add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ILineSegments2 applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ILineSegments2 attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ILineSegments2 clear](  ) - Removes all child objects.<br />
			[method:ILineSegments2 clone](  [param:boolean recursive]? ) <br />
			[method:ILineSegments2 computeLineDistances](  ) <br />
			[method:ILineSegments2 copy](  [param:ILineSegments2 source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ILineSegments2 remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ILineSegments2 removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ILineSegments2 rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ILineSegments2 rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ILineSegments2 rotateX](  [param:number angle] ) <br />
			[method:ILineSegments2 rotateY](  [param:number angle] ) <br />
			[method:ILineSegments2 rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ILineSegments2 translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ILineSegments2 translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ILineSegments2 translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ILineSegments2 translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IInstancedBufferGeometry] &rarr;

		<h3 id="ILineSegmentsGeometry">ILineSegmentsGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILineSegmentsGeometry ILineSegmentsGeometry](  ) <br />
			[constructor:ILineSegmentsGeometry ILineSegmentsGeometry](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:number instanceCount] -  The instance count.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:boolean isInstancedBufferGeometry] -  The is instanced buffer geometry.<br />
			[property:any isLineSegmentsGeometry] -  The is line segments geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number instances] ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:ILineSegmentsGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ILineSegmentsGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:ILineSegmentsGeometry fromEdgesGeometry](  [param:IEdgesGeometry geometry] ) <br />
			[method:ILineSegmentsGeometry fromLineSegments](  [param:ILineSegments lineSegments] ) <br />
			[method:ILineSegmentsGeometry fromMesh](  [param:IMesh mesh] ) <br />
			[method:ILineSegmentsGeometry fromWireframeGeometry](  [param:IWireframeGeometry geometry] ) <br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:ILineSegmentsGeometry setColors](  [param:Float32Array|number[] array] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:ILineSegmentsGeometry setPositions](  [param:Float32Array|number[] array] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IInterpolant] &rarr;

		<h3 id="ILinearInterpolant">ILinearInterpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILinearInterpolant ILinearInterpolant](  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] -  The parameter positions.<br />
			[property:any resultBuffer] -  The result buffer.<br />
			[property:any sampleValues] -  The sample values.<br />
			[property:number valueSize] -  The value size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any evaluate](  [param:number time] ) <br />
			[method:any evaluate](  [param:number time],  [param:number time] ) <br />
			[method:any interpolate_](  [param:number i1],  [param:number t0],  [param:number t],  [param:number t1] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILoader">ILoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILoader ILoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ILoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ILoader setPath](  [param:string path] ) <br />
			[method:ILoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ILoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ILoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILoaderUtils">ILoaderUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:string decodeText](  [param:BufferSource array] ) <br />
			[method:string extractUrlBase](  [param:string url] ) <br />
			[method:string resolveURL](  [param:string url],  [param:string path] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILoadingManager">ILoadingManager <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILoadingManager ILoadingManager](  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any onStart]? -  The on start.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ILoadingManager addHandler](  [param:RegExp regex],  [param:ILoader loader] ) <br />
			[method:ILoader getHandler](  [param:string file] ) <br />
			[method:void itemEnd](  [param:string url] ) <br />
			[method:void itemError](  [param:string url] ) <br />
			[method:void itemStart](  [param:string url] ) <br />
			[method:void onError](  [param:string url] ) - Will be called when item loading fails.<br />
			The default is a function with empty body.<br />
			[method:void onLoad](  ) - Will be called when all items finish loading.<br />
			The default is a function with empty body.<br />
			[method:void onProgress](  [param:string url],  [param:number loaded],  [param:number total] ) - Will be called for each loaded item.<br />
			The default is a function with empty body.<br />
			[method:ILoadingManager removeHandler](  [param:RegExp regex] ) <br />
			[method:string resolveURL](  [param:string url] ) - Given a URL, uses the URL modifier callback (if any) and returns a resolved URL.<br />
			If no URL modifier is set, returns the original URL.<br />
			[method:ILoadingManager setURLModifier](  [param:any callback]? ) - If provided, the callback will be passed each resource URL before a request is sent.<br />
			The callback may return the original URL, or a new URL to override loading behavior.<br />
			This behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs.
		</p>

		<p class="desc">
			Handles and keeps track of loaded and pending data.
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ILottieLoader">ILottieLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILottieLoader ILottieLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ILottieLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ILottieLoader setPath](  [param:string path] ) <br />
			[method:void setQuality](  [param:number value] ) <br />
			[method:ILottieLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ILottieLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ILottieLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="ILuminanceNode">ILuminanceNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILuminanceNode ILuminanceNode](  [param:INode rgb] ) <br />
			[constructor:ILuminanceNode ILuminanceNode](  [param:INode rgb],  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ILuminanceNode ILuminanceNode](  [param:INode rgb],  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:INode rgb] -  The rgb.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ILuminanceNode copy](  [param:ILuminanceNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ILuminanceNode setLabel](  [param:string name] ) <br />
			[method:ILuminanceNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ILut">ILut <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ILut ILut](  [param:string colormap]?,  [param:number numberofcolors]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IColor[] lut] -  The lut.<br />
			[property:object[] map] -  The map.<br />
			[property:number maxV] -  The max v.<br />
			[property:number minV] -  The min v.<br />
			[property:number n] -  The n.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addColorMap](  [param:string colormapName],  [param:any arrayOfColors] ) <br />
			[method:ILut copy](  [param:ILut lut] ) <br />
			[method:HTMLCanvasElement createCanvas](  ) <br />
			[method:IColor getColor](  [param:number alpha] ) <br />
			[method:ILut set](  [param:ILut value] ) <br />
			[method:ILut setColorMap](  [param:string colormap]?,  [param:number numberofcolors]? ) <br />
			[method:ILut setMax](  [param:number max] ) <br />
			[method:ILut setMin](  [param:number min] ) <br />
			[method:HTMLCanvasElement updateCanvas](  [param:HTMLCanvasElement canvas] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMD2Character">IMD2Character <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMD2Character IMD2Character](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string activeAnimation] -  The active animation.<br />
			[property:number animationFPS] -  The animation f p s.<br />
			[property:number loadCounter] -  The load counter.<br />
			[property:IMesh meshBody] -  The mesh body.<br />
			[property:IMesh meshWeapon] -  The mesh weapon.<br />
			[property:IAnimationMixer mixer] -  The mixer.<br />
			[property:IObject3D root] -  The root.<br />
			[property:number scale] -  The scale.<br />
			[property:ITexture[] skinsBody] -  The skins body.<br />
			[property:ITexture[] skinsWeapon] -  The skins weapon.<br />
			[property:IMesh[] weapons] -  The weapons.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void loadParts](  [param:IMD2PartsConfig config] ) <br />
			[method:void onLoadComplete](  ) <br />
			[method:void setAnimation](  [param:string clipName] ) <br />
			[method:void setPlaybackRate](  [param:number rate] ) <br />
			[method:void setSkin](  [param:number index] ) <br />
			[method:void setWeapon](  [param:number index] ) <br />
			[method:void setWireframe](  [param:boolean wireframeEnabled] ) <br />
			[method:void syncWeaponAnimation](  ) <br />
			[method:void update](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMD2CharacterComplex">IMD2CharacterComplex <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMD2CharacterComplex IMD2CharacterComplex](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string activeAnimation] -  The active animation.<br />
			[property:number angularSpeed] -  The angular speed.<br />
			[property:number animationFPS] -  The animation f p s.<br />
			[property:object[] animations] -  The animations.<br />
			[property:number backAcceleration] -  The back acceleration.<br />
			[property:number bodyOrientation] -  The body orientation.<br />
			[property:any controls] -  The controls.<br />
			[property:number crouchSpeed] -  The crouch speed.<br />
			[property:number currentSkin] -  The current skin.<br />
			[property:number frontAcceleration] -  The front acceleration.<br />
			[property:number frontDecceleration] -  The front decceleration.<br />
			[property:number loadCounter] -  The load counter.<br />
			[property:number maxReverseSpeed] -  The max reverse speed.<br />
			[property:number maxSpeed] -  The max speed.<br />
			[property:IMesh meshBody] -  The mesh body.<br />
			[property:IMesh meshWeapon] -  The mesh weapon.<br />
			[property:IMesh[] meshes] -  The meshes.<br />
			[property:string oldAnimation] -  The old animation.<br />
			[property:IObject3D root] -  The root.<br />
			[property:number scale] -  The scale.<br />
			[property:ITexture[] skinsBody] -  The skins body.<br />
			[property:ITexture[] skinsWeapon] -  The skins weapon.<br />
			[property:number speed] -  The speed.<br />
			[property:number transitionFrames] -  The transition frames.<br />
			[property:number walkSpeed] -  The walk speed.<br />
			[property:IMesh[] weapons] -  The weapons.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void enableShadows](  [param:boolean enable] ) <br />
			[method:void loadParts](  [param:object config] ) <br />
			[method:void onLoadComplete](  ) <br />
			[method:void setAnimation](  [param:string animationName] ) <br />
			[method:void setPlaybackRate](  [param:number rate] ) <br />
			[method:void setSkin](  [param:number index] ) <br />
			[method:void setVisible](  [param:boolean enable] ) <br />
			[method:void setWeapon](  [param:number index] ) <br />
			[method:void setWireframe](  [param:boolean wireframeEnabled] ) <br />
			[method:void shareParts](  [param:IMD2CharacterComplex original] ) <br />
			[method:void update](  [param:number delta] ) <br />
			[method:void updateAnimations](  [param:number delta] ) <br />
			[method:void updateBehaviors](  ) <br />
			[method:void updateMovementModel](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IMD2Loader">IMD2Loader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMD2Loader IMD2Loader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IBufferGeometry parse](  [param:ArrayBuffer data] ) <br />
			[method:IMD2Loader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IMD2Loader setPath](  [param:string path] ) <br />
			[method:IMD2Loader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IMD2Loader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IMD2Loader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMD2PartsConfig">IMD2PartsConfig <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string baseUrl] -  The base url.<br />
			[property:string body] -  The body.<br />
			[property:string[] skins] -  The skins.<br />
			[property:any weapons] -  The weapons.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMDD">IMDD <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip clip] -  The clip.<br />
			[property:IBufferAttribute[] morphTargets] -  The morph targets.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IMDDLoader">IMDDLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMDDLoader IMDDLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IMDD parse](  [param:ArrayBuffer data] ) <br />
			[method:IMDDLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IMDDLoader setPath](  [param:string path] ) <br />
			[method:IMDDLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IMDDLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IMDDLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMMDAnimationHelper">IMMDAnimationHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMMDAnimationHelper IMMDAnimationHelper](  [param:IMMDAnimationHelperParameter params]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAudio audio] -  The audio.<br />
			[property:IAudioManager audioManager] -  The audio manager.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:IObject3D cameraTarget] -  The camera target.<br />
			[property:any configuration] -  The configuration.<br />
			[property:any enabled] -  The enabled.<br />
			[property:any masterPhysics] -  The master physics.<br />
			[property:ISkinnedMesh[] meshes] -  The meshes.<br />
			[property:WeakMap objects] -  The objects.<br />
			[property:boolean sharedPhysics] -  The shared physics.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IMMDAnimationHelper add](  [param:ICamera|IAudio|ISkinnedMesh object],  [param:IMMDAnimationHelperAddParameter params]? ) <br />
			[method:IGrantSolver createGrantSolver](  [param:ISkinnedMesh mesh] ) <br />
			[method:IMMDAnimationHelper enable](  [param:string key],  [param:boolean enabled] ) <br />
			[method:void onBeforePhysics](  [param:ISkinnedMesh mesh] ) <br />
			[method:IMMDAnimationHelper pose](  [param:ISkinnedMesh mesh],  [param:object vpd],  [param:IMMDAnimationHelperPoseParameter params]? ) <br />
			[method:IMMDAnimationHelper remove](  [param:ICamera|IAudio|ISkinnedMesh object] ) <br />
			[method:IMMDAnimationHelper update](  [param:number delta] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMMDAnimationHelperAddParameter">IMMDAnimationHelperAddParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip|IAnimationClip[] animation]? -  The animation.<br />
			[property:number delayTime]? -  The delay time.<br />
			[property:number gravity]? -  The gravity.<br />
			[property:number maxStepNum]? -  The max step num.<br />
			[property:boolean physics]? -  The physics.<br />
			[property:number unitStep]? -  The unit step.<br />
			[property:number warmup]? -  The warmup.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMMDAnimationHelperMixer">IMMDAnimationHelperMixer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number duration]? -  The duration.<br />
			[property:IGrantSolver grantSolver] -  The grant solver.<br />
			[property:ICCDIKSolver ikSolver] -  The ik solver.<br />
			[property:boolean looped] -  The looped.<br />
			[property:IAnimationMixer mixer]? -  The mixer.<br />
			[property:IMMDPhysics physics]? -  The physics.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMMDAnimationHelperParameter">IMMDAnimationHelperParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number afterglow]? -  The afterglow.<br />
			[property:boolean resetPhysicsOnLoop]? -  The reset physics on loop.<br />
			[property:boolean sync]? -  The sync.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMMDAnimationHelperPoseParameter">IMMDAnimationHelperPoseParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean grant]? -  The grant.<br />
			[property:boolean ik]? -  The ik.<br />
			[property:boolean resetPose]? -  The reset pose.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMMDExporter">IMMDExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMMDExporter IMMDExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:Uint8Array parseVpd](  [param:IObject3D skin],  [param:boolean outputShiftJis],  [param:boolean useOriginalBones] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IMMDLoader">IMMDLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMMDLoader IMMDLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object animationBuilder] -  The animation builder.<br />
			[property:string animationPath] -  The animation path.<br />
			[property:string crossOrigin] -  The cross origin.<br />
			[property:IFileLoader loader] -  The loader.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:object meshBuilder] -  The mesh builder.<br />
			[property:object parser] -  The parser.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadAnimation](  [param:string url],  [param:ICamera|ISkinnedMesh object],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void loadPMD](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadPMX](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadVMD](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadVPD](  [param:string url],  [param:boolean isUnicode],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:void loadWithAnimation](  [param:string url],  [param:string|string[] vmdUrl],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:IMMDLoader setAnimationPath](  [param:string animationPath] ) <br />
			[method:IMMDLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IMMDLoader setPath](  [param:string path] ) <br />
			[method:IMMDLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IMMDLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IMMDLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMMDLoaderAnimationObject">IMMDLoaderAnimationObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip animation] -  The animation.<br />
			[property:ISkinnedMesh mesh] -  The mesh.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMMDPhysics">IMMDPhysics <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMMDPhysics IMMDPhysics](  [param:ISkinnedMesh mesh],  [param:object[] rigidBodyParams],  [param:object[] constraintParams]?,  [param:IMMDPhysicsParameter params]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any[] bodies] -  The bodies.<br />
			[property:any[] constraints] -  The constraints.<br />
			[property:IVector3 gravity] -  The gravity.<br />
			[property:any manager] -  The manager.<br />
			[property:number maxStepNum] -  The max step num.<br />
			[property:ISkinnedMesh mesh] -  The mesh.<br />
			[property:number unitStep] -  The unit step.<br />
			[property:any world] -  The world.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IMMDPhysicsHelper createHelper](  ) <br />
			[method:IMMDPhysics reset](  ) <br />
			[method:IMMDPhysics setGravity](  [param:IVector3 gravity] ) <br />
			[method:IMMDPhysics update](  [param:number delta] ) <br />
			[method:IMMDPhysics warmup](  [param:number cycles] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IMMDPhysicsHelper">IMMDPhysicsHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMMDPhysicsHelper IMMDPhysicsHelper](  ) <br />
			[constructor:IMMDPhysicsHelper IMMDPhysicsHelper](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IMMDPhysicsHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IMMDPhysicsHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IMMDPhysicsHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IMMDPhysicsHelper clear](  ) - Removes all child objects.<br />
			[method:IMMDPhysicsHelper clone](  [param:boolean recursive]? ) <br />
			[method:IMMDPhysicsHelper copy](  [param:IMMDPhysicsHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IMMDPhysicsHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IMMDPhysicsHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IMMDPhysicsHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IMMDPhysicsHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IMMDPhysicsHelper rotateX](  [param:number angle] ) <br />
			[method:IMMDPhysicsHelper rotateY](  [param:number angle] ) <br />
			[method:IMMDPhysicsHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IMMDPhysicsHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IMMDPhysicsHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IMMDPhysicsHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IMMDPhysicsHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMMDPhysicsParameter">IMMDPhysicsParameter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IVector3 gravity]? -  The gravity.<br />
			[property:number maxStepNum]? -  The max step num.<br />
			[property:number unitStep]? -  The unit step.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IMTLLoader">IMTLLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMTLLoader IMTLLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:any materialOptions] -  The material options.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:any parse](  [param:string text],  [param:string path] ) <br />
			[method:IMTLLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:void setMaterialOptions](  [param:any value] ) <br />
			[method:IMTLLoader setPath](  [param:string path] ) <br />
			[method:IMTLLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IMTLLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IMTLLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IOrbitControls] &rarr;

		<h3 id="IMapControls">IMapControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMapControls IMapControls](  [param:ICamera object],  [param:HTMLElement domElement]? ) <br />
			[constructor:IMapControls IMapControls](  [param:ICamera object],  [param:HTMLElement domElement]?,  [param:ICamera object],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoRotate] -  The auto rotate.<br />
			[property:number autoRotateSpeed] -  The auto rotate speed.<br />
			[property:IVector3 center] -  The center.<br />
			[property:number dampingFactor] -  The damping factor.<br />
			[property:HTMLElement|HTMLDocument domElement] -  The dom element.<br />
			[property:boolean enableDamping] -  The enable damping.<br />
			[property:boolean enableKeys] -  The enable keys.<br />
			[property:boolean enablePan] -  The enable pan.<br />
			[property:boolean enableRotate] -  The enable rotate.<br />
			[property:boolean enableZoom] -  The enable zoom.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:number keyPanSpeed] -  The key pan speed.<br />
			[property:any keys] -  The keys.<br />
			[property:number maxAzimuthAngle] -  The max azimuth angle.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number maxPolarAngle] -  The max polar angle.<br />
			[property:number maxZoom] -  The max zoom.<br />
			[property:number minAzimuthAngle] -  The min azimuth angle.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:number minPolarAngle] -  The min polar angle.<br />
			[property:number minZoom] -  The min zoom.<br />
			[property:any mouseButtons] -  The mouse buttons.<br />
			[property:ICamera object] -  The object.<br />
			[property:number panSpeed] -  The pan speed.<br />
			[property:number rotateSpeed] -  The rotate speed.<br />
			[property:boolean screenSpacePanning] -  The screen space panning.<br />
			[property:IVector3 target] -  The target.<br />
			[property:any touches] -  The touches.<br />
			[property:number zoomSpeed] -  The zoom speed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void dispatchEvent](  [param:any event] ) <br />
			[method:void dispose](  ) <br />
			[method:number getAzimuthalAngle](  ) <br />
			[method:number getDistance](  ) <br />
			[method:number getPolarAngle](  ) <br />
			[method:boolean hasEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void listenToKeyEvents](  [param:HTMLElement domElement] ) <br />
			[method:void removeEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void reset](  ) <br />
			[method:void saveState](  ) <br />
			[method:boolean update](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IMarchingCubes">IMarchingCubes <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMarchingCubes IMarchingCubes](  [param:number resolution],  [param:IMaterial material],  [param:boolean enableUvs]?,  [param:boolean enableColors]?,  [param:number maxPolyCount]? ) <br />
			[constructor:IMarchingCubes IMarchingCubes](  [param:number resolution],  [param:IMaterial material],  [param:boolean enableUvs]?,  [param:boolean enableColors]?,  [param:number maxPolyCount]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IMarchingCubes IMarchingCubes](  [param:number resolution],  [param:IMaterial material],  [param:boolean enableUvs]?,  [param:boolean enableColors]?,  [param:number maxPolyCount]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:Float32Array colorArray] -  The color array.<br />
			[property:number count] -  The count.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number delta] -  The delta.<br />
			[property:boolean enableColors] -  The enable colors.<br />
			[property:boolean enableUvs] -  The enable uvs.<br />
			[property:Float32Array field] -  The field.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number halfsize] -  The halfsize.<br />
			[property:boolean hasColors] -  The has colors.<br />
			[property:boolean hasNormals] -  The has normals.<br />
			[property:boolean hasPositions] -  The has positions.<br />
			[property:boolean hasUvs] -  The has uvs.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:number isolation] -  The isolation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:number maxCount] -  The max count.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:Float32Array normalArray] -  The normal array.<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:Float32Array normal_cache] -  The normal_cache.<br />
			[property:Float32Array palette] -  The palette.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:Float32Array positionArray] -  The position array.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:number resolution] -  The resolution.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:number size] -  The size.<br />
			[property:number size2] -  The size2.<br />
			[property:number size3] -  The size3.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:Float32Array uvArray] -  The uv array.<br />
			[property:boolean visible] - Object gets rendered if true.<br />
			[property:number yd] -  The yd.<br />
			[property:number zd] -  The zd.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IMarchingCubes add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addBall](  [param:number ballx],  [param:number bally],  [param:number ballz],  [param:number strength],  [param:number subtract],  [param:IColor colors]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addPlaneX](  [param:number strength],  [param:number subtract] ) <br />
			[method:void addPlaneY](  [param:number strength],  [param:number subtract] ) <br />
			[method:void addPlaneZ](  [param:number strength],  [param:number subtract] ) <br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IMarchingCubes applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IMarchingCubes attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:void begin](  ) <br />
			[method:void blur](  [param:number intensity] ) <br />
			[method:IMarchingCubes clear](  ) - Removes all child objects.<br />
			[method:IMarchingCubes clone](  [param:boolean recursive]? ) <br />
			[method:IMarchingCubes copy](  [param:IMarchingCubes source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void end](  ) <br />
			[method:IBufferGeometry generateGeometry](  ) <br />
			[method:IBufferGeometry generateIBufferGeometry](  ) <br />
			[method:number getCell](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void init](  [param:number resolution] ) <br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IMarchingCubes remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IMarchingCubes removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:void render](  [param:any renderCallback] ) <br />
			[method:void reset](  ) <br />
			[method:IMarchingCubes rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IMarchingCubes rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IMarchingCubes rotateX](  [param:number angle] ) <br />
			[method:IMarchingCubes rotateY](  [param:number angle] ) <br />
			[method:IMarchingCubes rotateZ](  [param:number angle] ) <br />
			[method:void setCell](  [param:number x],  [param:number y],  [param:number z],  [param:number value] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IMarchingCubes translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IMarchingCubes translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IMarchingCubes translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IMarchingCubes translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IMaskPass">IMaskPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMaskPass IMaskPass](  [param:IScene scene],  [param:ICamera camera] ) - Creates an instance of ngx mask pass.<br />
			[constructor:IMaskPass IMaskPass](  [param:IScene scene],  [param:ICamera camera] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ICamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean inverse] -  The inverse.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IScene scene] -  The scene.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Mask pass<br />
			See the [page:NgxMaskPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/MaskPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IMaterial">IMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMaterial IMaterial](  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] - Value is the string 'Material'. This shouldn't be changed, and can be used to find all objects of this type in a scene.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMaterialParameters values] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			Materials describe the appearance of objects. They are defined in a (mostly) renderer-independent way, so you don't have to rewrite materials if you decide to use a different renderer.
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IMaterialLoader">IMaterialLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMaterialLoader IMaterialLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:any textures] -  The textures.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IMaterial parse](  [param:any json] ) <br />
			[method:IMaterialLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IMaterialLoader setPath](  [param:string path] ) <br />
			[method:IMaterialLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IMaterialLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IMaterialLoader setTextures](  [param:any textures] ) <br />
			[method:IMaterialLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMaterialParameters">IMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IMathNode">IMathNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMathNode IMathNode](  [param:INode a],  [param:string|INode bOrMethod],  [param:string|INode cOrMethod]?,  [param:string method]? ) <br />
			[constructor:IMathNode IMathNode](  [param:INode a],  [param:string|INode bOrMethod],  [param:string|INode cOrMethod]?,  [param:string method]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IMathNode IMathNode](  [param:INode a],  [param:string|INode bOrMethod],  [param:string|INode cOrMethod]?,  [param:string method]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string ABS] -  The a b s.<br />
			[property:string ACOS] -  The a c o s.<br />
			[property:string ARCTAN] -  The a r c t a n.<br />
			[property:string ASIN] -  The a s i n.<br />
			[property:string CEIL] -  The c e i l.<br />
			[property:string CLAMP] -  The c l a m p.<br />
			[property:string COS] -  The c o s.<br />
			[property:string CROSS] -  The c r o s s.<br />
			[property:string DEG] -  The d e g.<br />
			[property:string DISTANCE] -  The d i s t a n c e.<br />
			[property:string DOT] -  The d o t.<br />
			[property:string EXP] -  The e x p.<br />
			[property:string EXP2] -  The e x p2.<br />
			[property:string FACEFORWARD] -  The f a c e f o r w a r d.<br />
			[property:string FLOOR] -  The f l o o r.<br />
			[property:string INVERT] -  The i n v e r t.<br />
			[property:string INV_SQRT] -  The i n v_ s q r t.<br />
			[property:string LENGTH] -  The l e n g t h.<br />
			[property:string LOG] -  The l o g.<br />
			[property:string LOG2] -  The l o g2.<br />
			[property:string MAX] -  The m a x.<br />
			[property:string MIN] -  The m i n.<br />
			[property:string MIX] -  The m i x.<br />
			[property:string MOD] -  The m o d.<br />
			[property:string NEGATE] -  The n e g a t e.<br />
			[property:string NORMALIZE] -  The n o r m a l i z e.<br />
			[property:string POW] -  The p o w.<br />
			[property:string RAD] -  The r a d.<br />
			[property:string REFLECT] -  The r e f l e c t.<br />
			[property:string REFRACT] -  The r e f r a c t.<br />
			[property:string SATURATE] -  The s a t u r a t e.<br />
			[property:string SIGN] -  The s i g n.<br />
			[property:string SIN] -  The s i n.<br />
			[property:string SMOOTHSTEP] -  The s m o o t h s t e p.<br />
			[property:string SQRT] -  The s q r t.<br />
			[property:string STEP] -  The s t e p.<br />
			[property:string TAN] -  The t a n.<br />
			[property:INode a] -  The a.<br />
			[property:string|INode b] -  The b.<br />
			[property:string|INode c] -  The c.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string method] -  The method.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IMathNode copy](  [param:IMathNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:string getInputType](  [param:INodeBuilder builder] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:number getNumInputs](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IMathNode setLabel](  [param:string name] ) <br />
			[method:IMathNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMathUtils">IMathUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:number ceilPowerOfTwo](  [param:number value] ) <br />
			[method:number clamp](  [param:number value],  [param:number min],  [param:number max] ) - Clamps the x to be between a and b.<br />
			[method:number damp](  [param:number x],  [param:number y],  [param:number lambda],  [param:number dt] ) - Smoothly interpolate a number from x toward y in a spring-like<br />
			manner using the dt to maintain frame rate independent movement.<br />
			[method:number degToRad](  [param:number degrees] ) <br />
			[method:number euclideanModulo](  [param:number n],  [param:number m] ) <br />
			[method:number floorPowerOfTwo](  [param:number value] ) <br />
			[method:string generateUUID](  ) <br />
			[method:number inverseLerp](  [param:number x],  [param:number y],  [param:number t] ) <br />
			[method:boolean isPowerOfTwo](  [param:number value] ) <br />
			[method:number lerp](  [param:number x],  [param:number y],  [param:number t] ) - Returns a value linearly interpolated from two known points based<br />
			on the given interval - t = 0 will return x and t = 1 will return y.<br />
			[method:number mapLinear](  [param:number x],  [param:number a1],  [param:number a2],  [param:number b1],  [param:number b2] ) - Linear mapping of x from range [a1, a2] to range [b1, b2].<br />
			[method:number nearestPowerOfTwo](  [param:number value] ) <br />
			[method:number nextPowerOfTwo](  [param:number value] ) <br />
			[method:number pingpong](  [param:number x],  [param:number length]? ) - Returns a value that alternates between 0 and length.<br />
			[method:number radToDeg](  [param:number radians] ) <br />
			[method:number randFloat](  [param:number low],  [param:number high] ) - Random float from low to high interval.<br />
			[method:number randFloatSpread](  [param:number range] ) - Random float from - range / 2 to range / 2 interval.<br />
			[method:number randInt](  [param:number low],  [param:number high] ) - Random integer from low to high interval.<br />
			[method:number random16](  ) - Random float from 0 to 1 with 16 bits of randomness.<br />
			Standard Math.random() creates repetitive patterns when applied over larger space.<br />
			[method:number seededRandom](  [param:number seed]? ) - Deterministic pseudo-random float in the interval [ 0, 1 ].<br />
			[method:void setQuaternionFromProperEuler](  [param:IQuaternion|Quaternion q],  [param:number a],  [param:number b],  [param:number c],  [param:string order] ) <br />
			[method:number smootherstep](  [param:number x],  [param:number min],  [param:number max] ) <br />
			[method:number smoothstep](  [param:number x],  [param:number min],  [param:number max] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMatrix">IMatrix <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] - Array with matrix values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IMatrix clone](  ) - clone():T;<br />
			[method:IMatrix clone](  ) - clone():T;<br />
			[method:IMatrix copy](  [param:IMatrix m] ) - copy(m:T):T;<br />
			[method:IMatrix copy](  [param:IMatrix m],  [param:IMatrix m] ) - copy(m:T):T;<br />
			[method:number determinant](  ) <br />
			[method:number determinant](  ) <br />
			[method:IMatrix identity](  ) - identity():T;<br />
			[method:IMatrix identity](  ) - identity():T;<br />
			[method:IMatrix invert](  ) - invert():T;<br />
			[method:IMatrix invert](  ) - invert():T;<br />
			[method:IMatrix multiplyScalar](  [param:number s] ) - multiplyScalar(s:number):T;<br />
			[method:IMatrix multiplyScalar](  [param:number s],  [param:number s] ) - multiplyScalar(s:number):T;<br />
			[method:IMatrix transpose](  ) - transpose():T;<br />
			[method:IMatrix transpose](  ) - transpose():T;
		</p>

		<p class="desc">
			( interface Matrix&lt;T&gt; )
		</p>

		<hr class="interface-line"/>
		[page:IMatrix] &rarr;

		<h3 id="IMatrix3">IMatrix3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMatrix3 IMatrix3](  ) - Creates an identity matrix.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] - Array with matrix values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IMatrix3 clone](  ) - clone():T;<br />
			[method:IMatrix3 copy](  [param:IMatrix3|Matrix3 m] ) - copy(m:T):T;<br />
			[method:number determinant](  ) <br />
			[method:boolean equals](  [param:IMatrix3|Matrix3 matrix] ) <br />
			[method:IMatrix3 extractBasis](  [param:IVector3|Vector3 xAxis],  [param:IVector3|Vector3 yAxis],  [param:IVector3|Vector3 zAxis] ) <br />
			[method:number[] flattenToArrayOffset](  [param:number[] array],  [param:number offset] ) <br />
			[method:IMatrix3 fromArray](  [param:number[]|ArrayLike array],  [param:number offset]? ) - Sets the values of this matrix from the provided array or array-like.<br />
			[method:IMatrix3 getInverse](  [param:IMatrix4 matrix],  [param:boolean throwOnDegenerate]? ) <br />
			[method:IMatrix getInverse](  [param:IMatrix4 matrix],  [param:boolean throwOnDegenerate]?,  [param:IMatrix matrix] ) <br />
			[method:IMatrix3 getNormalIMatrix](  [param:IMatrix4|Matrix4 matrix4] ) <br />
			[method:IMatrix3 identity](  ) - identity():T;<br />
			[method:IMatrix3 invert](  ) - Inverts this matrix in place.<br />
			[method:IMatrix3 multiply](  [param:IMatrix3|Matrix3 m] ) - Multiplies this matrix by m.<br />
			[method:any multiplyIVector3](  [param:IVector3|Vector3 vector] ) <br />
			[method:any multiplyIVector3Array](  [param:any a] ) <br />
			[method:IMatrix3 multiplyMatrices](  [param:IMatrix3|Matrix3 a],  [param:IMatrix3|Matrix3 b] ) - Sets this matrix to a x b.<br />
			[method:IMatrix3 multiplyScalar](  [param:number s] ) - multiplyScalar(s:number):T;<br />
			[method:IMatrix3 premultiply](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IMatrix3 rotate](  [param:number theta] ) <br />
			[method:IMatrix3 scale](  [param:number sx],  [param:number sy] ) <br />
			[method:IMatrix3 set](  [param:number n11],  [param:number n12],  [param:number n13],  [param:number n21],  [param:number n22],  [param:number n23],  [param:number n31],  [param:number n32],  [param:number n33] ) <br />
			[method:IMatrix3 setFromIMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IMatrix3 setUvTransform](  [param:number tx],  [param:number ty],  [param:number sx],  [param:number sy],  [param:number rotation],  [param:number cx],  [param:number cy] ) <br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns an array with the values of this matrix, or copies them into the provided array.<br />
			<br />
			Returns : The created or provided array.<br />
			[method:Matrix3Tuple toArray](  [param:number[] array]?,  [param:number offset]?,  [param:IMatrix3|Matrix3Tuple array]?,  [param:any offset]? ) <br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:IMatrix3|Matrix3Tuple array]?,  [param:any offset]?,  [param:ArrayLike array]?,  [param:number offset]? ) - Copies he values of this matrix into the provided array-like.<br />
			<br />
			Returns : The provided array-like.<br />
			[method:IMatrix3 translate](  [param:number tx],  [param:number ty] ) <br />
			[method:IMatrix3 transpose](  ) - Transposes this matrix in place.<br />
			[method:IMatrix3 transposeIntoArray](  [param:number[] r] ) - Transposes this matrix into the supplied array r, and returns itself.
		</p>

		<p class="desc">
			( class IMatrix3 implements IMatrix&lt;IMatrix3&gt; )
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IMatrix3Node">IMatrix3Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMatrix3Node IMatrix3Node](  [param:IMatrix3 matrix]? ) <br />
			[constructor:IMatrix3Node IMatrix3Node](  [param:IMatrix3 matrix]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IMatrix3Node IMatrix3Node](  [param:IMatrix3 matrix]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IMatrix3Node IMatrix3Node](  [param:IMatrix3 matrix]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] -  The elements.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IMatrix3 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IMatrix3Node copy](  [param:IMatrix3Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IMatrix3Node setLabel](  [param:string name] ) <br />
			[method:IMatrix3Node setName](  [param:string name] ) <br />
			[method:IMatrix3Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMatrix] &rarr;

		<h3 id="IMatrix4">IMatrix4 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMatrix4 IMatrix4](  ) <br />
			[constructor:IMatrix4 IMatrix4](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] - Array with matrix values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IMatrix4 clone](  ) - clone():T;<br />
			[method:IMatrix4 clone](  ) - clone():T;<br />
			[method:IMatrix4 compose](  [param:IVector3|Vector3 translation],  [param:IQuaternion|Quaternion rotation],  [param:IVector3|Vector3 scale] ) - Sets this matrix to the transformation composed of translation, rotation and scale.<br />
			[method:IMatrix4 compose](  [param:IVector3|Vector3 translation],  [param:IQuaternion|Quaternion rotation],  [param:IVector3|Vector3 scale],  [param:IVector3|Vector3 translation],  [param:IQuaternion|Quaternion rotation],  [param:IVector3|Vector3 scale] ) - Sets this matrix to the transformation composed of translation, rotation and scale.<br />
			[method:IMatrix4 copy](  [param:IMatrix4|Matrix4 m] ) - copy(m:T):T;<br />
			[method:IMatrix4 copy](  [param:IMatrix4|Matrix4 m],  [param:IMatrix4|Matrix4 m] ) - copy(m:T):T;<br />
			[method:IMatrix4 copyPosition](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IMatrix4 copyPosition](  [param:IMatrix4|Matrix4 m],  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void crossIVector](  [param:any v] ) <br />
			[method:void crossVector](  [param:any v] ) <br />
			[method:IMatrix4 decompose](  [param:IVector3|Vector3 translation],  [param:IQuaternion|Quaternion rotation],  [param:IVector3|Vector3 scale] ) - Decomposes this matrix into it's position, quaternion and scale components.<br />
			[method:IMatrix4 decompose](  [param:IVector3|Vector3 translation],  [param:IQuaternion|Quaternion rotation],  [param:IVector3|Vector3 scale],  [param:IVector3|Vector3 translation],  [param:IQuaternion|Quaternion rotation],  [param:IVector3|Vector3 scale] ) - Decomposes this matrix into it's position, quaternion and scale components.<br />
			[method:number determinant](  ) - Computes determinant of this matrix.<br />
			Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm<br />
			[method:number determinant](  ) - Computes determinant of this matrix.<br />
			Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm<br />
			[method:boolean equals](  [param:IMatrix4 matrix] ) <br />
			[method:boolean equals](  [param:IMatrix4 matrix],  [param:IMatrix4 matrix] ) <br />
			[method:IMatrix4 extractBasis](  [param:IVector3|Vector3 xAxis],  [param:IVector3|Vector3 yAxis],  [param:IVector3|Vector3 zAxis] ) <br />
			[method:IMatrix4 extractBasis](  [param:IVector3|Vector3 xAxis],  [param:IVector3|Vector3 yAxis],  [param:IVector3|Vector3 zAxis],  [param:IVector3|Vector3 xAxis],  [param:IVector3|Vector3 yAxis],  [param:IVector3|Vector3 zAxis] ) <br />
			[method:IMatrix4 extractPosition](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IMatrix4 extractPosition](  [param:IMatrix4|Matrix4 m],  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IMatrix4 extractRotation](  [param:IMatrix4|Matrix4 m] ) - Copies the rotation component of the supplied matrix m into this matrix rotation component.<br />
			[method:IMatrix4 extractRotation](  [param:IMatrix4|Matrix4 m],  [param:IMatrix4|Matrix4 m] ) - Copies the rotation component of the supplied matrix m into this matrix rotation component.<br />
			[method:number[] flattenToArrayOffset](  [param:number[] array],  [param:number offset] ) <br />
			[method:number[] flattenToArrayOffset](  [param:number[] array],  [param:number offset],  [param:number[] array],  [param:number offset] ) <br />
			[method:IMatrix4 fromArray](  [param:number[]|ArrayLike array],  [param:number offset]? ) - Sets the values of this matrix from the provided array or array-like.<br />
			[method:IMatrix4 fromArray](  [param:number[]|ArrayLike array],  [param:number offset]?,  [param:number[]|ArrayLike array],  [param:number offset]? ) - Sets the values of this matrix from the provided array or array-like.<br />
			[method:IMatrix getInverse](  [param:IMatrix matrix] ) <br />
			[method:IMatrix getInverse](  [param:IMatrix matrix],  [param:IMatrix matrix] ) <br />
			[method:number getMaxScaleOnAxis](  ) <br />
			[method:number getMaxScaleOnAxis](  ) <br />
			[method:IMatrix4 identity](  ) - Resets this matrix to identity.<br />
			[method:IMatrix4 identity](  ) - Resets this matrix to identity.<br />
			[method:IMatrix4 invert](  ) - Inverts this matrix.<br />
			[method:IMatrix4 invert](  ) - Inverts this matrix.<br />
			[method:IMatrix4 lookAt](  [param:IVector3|Vector3 eye],  [param:IVector3|Vector3 target],  [param:IVector3|Vector3 up] ) - Constructs a rotation matrix, looking from eye towards center with defined up vector.<br />
			[method:IMatrix4 lookAt](  [param:IVector3|Vector3 eye],  [param:IVector3|Vector3 target],  [param:IVector3|Vector3 up],  [param:IVector3|Vector3 eye],  [param:IVector3|Vector3 target],  [param:IVector3|Vector3 up] ) - Constructs a rotation matrix, looking from eye towards center with defined up vector.<br />
			[method:IMatrix4 makeBasis](  [param:IVector3|Vector3 xAxis],  [param:IVector3|Vector3 yAxis],  [param:IVector3|Vector3 zAxis] ) <br />
			[method:IMatrix4 makeBasis](  [param:IVector3|Vector3 xAxis],  [param:IVector3|Vector3 yAxis],  [param:IVector3|Vector3 zAxis],  [param:IVector3|Vector3 xAxis],  [param:IVector3|Vector3 yAxis],  [param:IVector3|Vector3 zAxis] ) <br />
			[method:IMatrix4 makeOrthographic](  [param:number left],  [param:number right],  [param:number top],  [param:number bottom],  [param:number near],  [param:number far] ) - Creates an orthographic projection matrix.<br />
			[method:IMatrix4 makeOrthographic](  [param:number left],  [param:number right],  [param:number top],  [param:number bottom],  [param:number near],  [param:number far],  [param:number left],  [param:number right],  [param:number top],  [param:number bottom],  [param:number near],  [param:number far] ) - Creates an orthographic projection matrix.<br />
			[method:IMatrix4 makePerspective](  [param:number left],  [param:number right],  [param:number bottom],  [param:number top],  [param:number near],  [param:number far] ) - Creates a frustum matrix.<br />
			[method:IMatrix4 makePerspective](  [param:number left],  [param:number right],  [param:number bottom],  [param:number top],  [param:number near],  [param:number far],  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far] ) - Creates a perspective projection matrix.<br />
			[method:IMatrix4 makePerspective](  [param:number left],  [param:number right],  [param:number bottom],  [param:number top],  [param:number near],  [param:number far],  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far],  [param:number left],  [param:number right],  [param:number bottom],  [param:number top],  [param:number near],  [param:number far] ) - Creates a frustum matrix.<br />
			[method:IMatrix4 makePerspective](  [param:number left],  [param:number right],  [param:number bottom],  [param:number top],  [param:number near],  [param:number far],  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far],  [param:number left],  [param:number right],  [param:number bottom],  [param:number top],  [param:number near],  [param:number far],  [param:number fov],  [param:number aspect],  [param:number near],  [param:number far] ) - Creates a perspective projection matrix.<br />
			[method:IMatrix4 makeRotationAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Sets this matrix as rotation transform around axis by angle radians.<br />
			Based on http://www.gamedev.net/reference/articles/article1199.asp.<br />
			[method:IMatrix4 makeRotationAxis](  [param:IVector3|Vector3 axis],  [param:number angle],  [param:IVector3|Vector3 axis],  [param:number angle] ) - Sets this matrix as rotation transform around axis by angle radians.<br />
			Based on http://www.gamedev.net/reference/articles/article1199.asp.<br />
			[method:IMatrix4 makeRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:IMatrix4 makeRotationFromIEuler](  [param:IEuler|Euler euler] ) <br />
			[method:IMatrix4 makeRotationFromIQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IMatrix4 makeRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IMatrix4 makeRotationX](  [param:number theta] ) - Sets this matrix as rotation transform around x axis by theta radians.<br />
			[method:IMatrix4 makeRotationX](  [param:number theta],  [param:number theta] ) - Sets this matrix as rotation transform around x axis by theta radians.<br />
			[method:IMatrix4 makeRotationY](  [param:number theta] ) - Sets this matrix as rotation transform around y axis by theta radians.<br />
			[method:IMatrix4 makeRotationY](  [param:number theta],  [param:number theta] ) - Sets this matrix as rotation transform around y axis by theta radians.<br />
			[method:IMatrix4 makeRotationZ](  [param:number theta] ) - Sets this matrix as rotation transform around z axis by theta radians.<br />
			[method:IMatrix4 makeRotationZ](  [param:number theta],  [param:number theta] ) - Sets this matrix as rotation transform around z axis by theta radians.<br />
			[method:IMatrix4 makeScale](  [param:number x],  [param:number y],  [param:number z] ) - Sets this matrix as scale transform.<br />
			[method:IMatrix4 makeScale](  [param:number x],  [param:number y],  [param:number z],  [param:number x],  [param:number y],  [param:number z] ) - Sets this matrix as scale transform.<br />
			[method:IMatrix4 makeShear](  [param:number xy],  [param:number xz],  [param:number yx],  [param:number yz],  [param:number zx],  [param:number zy] ) - Sets this matrix as shear transform.<br />
			[method:IMatrix4 makeShear](  [param:number xy],  [param:number xz],  [param:number yx],  [param:number yz],  [param:number zx],  [param:number zy],  [param:number xy],  [param:number xz],  [param:number yx],  [param:number yz],  [param:number zx],  [param:number zy] ) - Sets this matrix as shear transform.<br />
			[method:IMatrix4 makeTranslation](  [param:number x],  [param:number y],  [param:number z] ) - Sets this matrix as translation transform.<br />
			[method:IMatrix4 makeTranslation](  [param:number x],  [param:number y],  [param:number z],  [param:number x],  [param:number y],  [param:number z] ) - Sets this matrix as translation transform.<br />
			[method:IMatrix4 multiply](  [param:IMatrix4|Matrix4 m] ) - Multiplies this matrix by m.<br />
			[method:IMatrix4 multiply](  [param:IMatrix4|Matrix4 m],  [param:IMatrix4|Matrix4 m] ) - Multiplies this matrix by m.<br />
			[method:any multiplyIVector3](  [param:any v] ) <br />
			[method:number[] multiplyIVector3Array](  [param:number[] array] ) <br />
			[method:any multiplyIVector4](  [param:any v] ) <br />
			[method:IMatrix4 multiplyMatrices](  [param:IMatrix4|Matrix4 a],  [param:IMatrix4|Matrix4 b] ) - Sets this matrix to a x b.<br />
			[method:IMatrix4 multiplyMatrices](  [param:IMatrix4|Matrix4 a],  [param:IMatrix4|Matrix4 b],  [param:IMatrix4|Matrix4 a],  [param:IMatrix4|Matrix4 b] ) - Sets this matrix to a x b.<br />
			[method:IMatrix4 multiplyScalar](  [param:number s] ) - Multiplies this matrix by s.<br />
			[method:IMatrix4 multiplyScalar](  [param:number s],  [param:number s] ) - Multiplies this matrix by s.<br />
			[method:IMatrix4 multiplyToArray](  [param:IMatrix4|Matrix4 a],  [param:IMatrix4|Matrix4 b],  [param:number[] r] ) - Sets this matrix to a x b and stores the result into the flat array r.<br />
			r can be either a regular Array or a TypedArray.<br />
			[method:IMatrix4 multiplyToArray](  [param:IMatrix4|Matrix4 a],  [param:IMatrix4|Matrix4 b],  [param:number[] r],  [param:IMatrix4|Matrix4 a],  [param:IMatrix4|Matrix4 b],  [param:number[] r] ) - Sets this matrix to a x b and stores the result into the flat array r.<br />
			r can be either a regular Array or a TypedArray.<br />
			[method:any multiplyVector3](  [param:any v] ) <br />
			[method:number[] multiplyVector3Array](  [param:number[] array] ) <br />
			[method:any multiplyVector4](  [param:any v] ) <br />
			[method:IMatrix4 premultiply](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IMatrix4 premultiply](  [param:IMatrix4|Matrix4 m],  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void rotateAxis](  [param:any v] ) <br />
			[method:void rotateAxis](  [param:any v],  [param:any v] ) <br />
			[method:IMatrix4 scale](  [param:IVector3|Vector3 v] ) - Multiplies the columns of this matrix by vector v.<br />
			[method:IMatrix4 scale](  [param:IVector3|Vector3 v],  [param:IVector3|Vector3 v] ) - Multiplies the columns of this matrix by vector v.<br />
			[method:IMatrix4 set](  [param:number n11],  [param:number n12],  [param:number n13],  [param:number n14],  [param:number n21],  [param:number n22],  [param:number n23],  [param:number n24],  [param:number n31],  [param:number n32],  [param:number n33],  [param:number n34],  [param:number n41],  [param:number n42],  [param:number n43],  [param:number n44] ) - Sets all fields of this matrix.<br />
			[method:IMatrix4 set](  [param:number n11],  [param:number n12],  [param:number n13],  [param:number n14],  [param:number n21],  [param:number n22],  [param:number n23],  [param:number n24],  [param:number n31],  [param:number n32],  [param:number n33],  [param:number n34],  [param:number n41],  [param:number n42],  [param:number n43],  [param:number n44],  [param:number n11],  [param:number n12],  [param:number n13],  [param:number n14],  [param:number n21],  [param:number n22],  [param:number n23],  [param:number n24],  [param:number n31],  [param:number n32],  [param:number n33],  [param:number n34],  [param:number n41],  [param:number n42],  [param:number n43],  [param:number n44] ) - Sets all fields of this matrix.<br />
			[method:IMatrix4 setFromIMatrix3](  [param:IMatrix3|Matrix3 m] ) - Set the upper 3x3 elements of this matrix to the values of the IMatrix3 m.<br />
			[method:IMatrix4 setFromMatrix3](  [param:IMatrix3|Matrix3 m] ) - Set the upper 3x3 elements of this matrix to the values of the Matrix3 m.<br />
			[method:IMatrix4 setPosition](  [param:number|IVector3|Vector3 v],  [param:number y]?,  [param:number z]? ) - Sets the position component for this matrix from vector v.<br />
			[method:IMatrix4 setPosition](  [param:number|IVector3|Vector3 v],  [param:number y]?,  [param:number z]?,  [param:number|IVector3|Vector3 v],  [param:number y]?,  [param:number z]? ) - Sets the position component for this matrix from vector v.<br />
			[method:IMatrix4 setRotationFromIQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IMatrix4 setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns an array with the values of this matrix, or copies them into the provided array.<br />
			<br />
			Returns : The created or provided array.<br />
			[method:TMatrix4Tuple toArray](  [param:number[] array]?,  [param:number offset]?,  [param:TMatrix4Tuple array]?,  [param:any offset]? ) <br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:TMatrix4Tuple array]?,  [param:any offset]?,  [param:ArrayLike array]?,  [param:number offset]? ) - Copies he values of this matrix into the provided array-like.<br />
			<br />
			Returns : The provided array-like.<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]?,  [param:TMatrix4Tuple array]?,  [param:any offset]?,  [param:ArrayLike array]?,  [param:number offset]?,  [param:number[] array]?,  [param:number offset]? ) - Returns an array with the values of this matrix, or copies them into the provided array.<br />
			<br />
			Returns : The created or provided array.<br />
			[method:IMatrix4Tuple toArray](  [param:number[] array]?,  [param:number offset]?,  [param:TMatrix4Tuple array]?,  [param:any offset]?,  [param:ArrayLike array]?,  [param:number offset]?,  [param:number[] array]?,  [param:number offset]?,  [param:IMatrix4|Matrix4Tuple array]?,  [param:any offset]? ) <br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:TMatrix4Tuple array]?,  [param:any offset]?,  [param:ArrayLike array]?,  [param:number offset]?,  [param:number[] array]?,  [param:number offset]?,  [param:IMatrix4|Matrix4Tuple array]?,  [param:any offset]?,  [param:ArrayLike array]?,  [param:number offset]? ) - Copies he values of this matrix into the provided array-like.<br />
			<br />
			Returns : The provided array-like.<br />
			[method:IMatrix4 transpose](  ) - Transposes this matrix.<br />
			[method:IMatrix4 transpose](  ) - Transposes this matrix.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IMatrix4Node">IMatrix4Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMatrix4Node IMatrix4Node](  [param:IMatrix4 matrix]? ) <br />
			[constructor:IMatrix4Node IMatrix4Node](  [param:IMatrix4 matrix]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IMatrix4Node IMatrix4Node](  [param:IMatrix4 matrix]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IMatrix4Node IMatrix4Node](  [param:IMatrix4 matrix]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] elements] -  The elements.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IMatrix4 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IMatrix4Node copy](  [param:IMatrix4Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IMatrix4Node setLabel](  [param:string name] ) <br />
			[method:IMatrix4Node setName](  [param:string name] ) <br />
			[method:IMatrix4Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr; [page:IFloatNode] &rarr;

		<h3 id="IMaxMIPLevelNode">IMaxMIPLevelNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMaxMIPLevelNode IMaxMIPLevelNode](  [param:INode texture] ) <br />
			[constructor:IMaxMIPLevelNode IMaxMIPLevelNode](  [param:INode texture],  [param:number value]? ) <br />
			[constructor:IMaxMIPLevelNode IMaxMIPLevelNode](  [param:INode texture],  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IMaxMIPLevelNode IMaxMIPLevelNode](  [param:INode texture],  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IMaxMIPLevelNode IMaxMIPLevelNode](  [param:INode texture],  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:number maxMIPLevel] -  The max m i p level.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:INode texture] -  The texture.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IMaxMIPLevelNode copy](  [param:IFloatNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IMaxMIPLevelNode setLabel](  [param:string name] ) <br />
			[method:IMaxMIPLevelNode setName](  [param:string name] ) <br />
			[method:IMaxMIPLevelNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IMesh">IMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMesh IMesh](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:IMesh IMesh](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:TGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:TMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IMesh add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IMesh applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IMesh attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IMesh clear](  ) - Removes all child objects.<br />
			[method:IMesh clone](  [param:boolean recursive]? ) <br />
			[method:IMesh copy](  [param:IMesh source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IMesh remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IMesh rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IMesh rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IMesh rotateX](  [param:number angle] ) <br />
			[method:IMesh rotateY](  [param:number angle] ) <br />
			[method:IMesh rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IMesh translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IMesh translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IMesh translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IMesh translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IMeshBasicMaterial">IMeshBasicMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshBasicMaterial IMeshBasicMaterial](  [param:IMeshBasicMaterialParameters parameters]? ) <br />
			[constructor:IMeshBasicMaterial IMeshBasicMaterial](  [param:IMeshBasicMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:ITexture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:Combine combine] -  The combine.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:ITexture envMap] -  The env map.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:ITexture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:ITexture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number reflectivity] -  The reflectivity.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:ITexture specularMap] -  The specular map.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshBasicMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshBasicMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshBasicMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IMeshBasicMaterialParameters">IMeshBasicMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:ITexture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:Combine combine]? -  The combine.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:ITexture envMap]? -  The env map.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:ITexture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:ITexture specularMap]? -  The specular map.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:string wireframeLinecap]? -  The wireframe linecap.<br />
			[property:string wireframeLinejoin]? -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IMeshDepthMaterial">IMeshDepthMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshDepthMaterial IMeshDepthMaterial](  [param:IMeshDepthMaterialParameters parameters]? ) <br />
			[constructor:IMeshDepthMaterial IMeshDepthMaterial](  [param:IMeshDepthMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:DepthPackingStrategies depthPacking] -  The depth packing.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:ITexture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:ITexture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshDepthMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshDepthMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshDepthMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IMeshDepthMaterialParameters">IMeshDepthMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:DepthPackingStrategies depthPacking]? -  The depth packing.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:ITexture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IMeshDistanceMaterial">IMeshDistanceMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshDistanceMaterial IMeshDistanceMaterial](  [param:IMeshDistanceMaterialParameters parameters]? ) <br />
			[constructor:IMeshDistanceMaterial IMeshDistanceMaterial](  [param:IMeshDistanceMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:ITexture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:number farDistance] -  The far distance.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:ITexture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:number nearDistance] -  The near distance.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:IVector3|Vector3 referencePosition] -  The reference position.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshDistanceMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshDistanceMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshDistanceMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IMeshDistanceMaterialParameters">IMeshDistanceMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:ITexture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:number farDistance]? -  The far distance.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number nearDistance]? -  The near distance.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:IVector3|Vector3 referencePosition]? -  The reference position.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IMeshLambertMaterial">IMeshLambertMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshLambertMaterial IMeshLambertMaterial](  [param:IMeshLambertMaterialParameters parameters]? ) <br />
			[constructor:IMeshLambertMaterial IMeshLambertMaterial](  [param:IMeshLambertMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:ITexture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:Combine combine] -  The combine.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:IColor emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:ITexture emissiveMap] -  The emissive map.<br />
			[property:ITexture envMap] -  The env map.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:ITexture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:ITexture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number reflectivity] -  The reflectivity.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:ITexture specularMap] -  The specular map.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshLambertMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshLambertMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshLambertMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IMeshLambertMaterialParameters">IMeshLambertMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:ITexture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:Combine combine]? -  The combine.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:any emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:ITexture emissiveMap]? -  The emissive map.<br />
			[property:ITexture envMap]? -  The env map.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:ITexture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:ITexture specularMap]? -  The specular map.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:string wireframeLinecap]? -  The wireframe linecap.<br />
			[property:string wireframeLinejoin]? -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IMeshMatcapMaterial">IMeshMatcapMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshMatcapMaterial IMeshMatcapMaterial](  [param:IMeshMatcapMaterialParameters parameters]? ) <br />
			[constructor:IMeshMatcapMaterial IMeshMatcapMaterial](  [param:IMeshMatcapMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:ITexture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:ITexture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:ITexture map] -  The map.<br />
			[property:ITexture matcap] -  The matcap.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:ITexture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshMatcapMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshMatcapMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshMatcapMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IMeshMatcapMaterialParameters">IMeshMatcapMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:ITexture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:ITexture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture map]? -  The map.<br />
			[property:ITexture matcap]? -  The matcap.<br />
			[property:string name]? -  The name.<br />
			[property:ITexture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IMeshNormalMaterial">IMeshNormalMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshNormalMaterial IMeshNormalMaterial](  [param:IMeshNormalMaterialParameters parameters]? ) <br />
			[constructor:IMeshNormalMaterial IMeshNormalMaterial](  [param:IMeshNormalMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:ITexture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:ITexture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:ITexture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshNormalMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshNormalMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshNormalMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IMeshNormalMaterialParameters">IMeshNormalMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:ITexture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:ITexture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string name]? -  The name.<br />
			[property:ITexture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IMeshPhongMaterial">IMeshPhongMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshPhongMaterial IMeshPhongMaterial](  [param:IMeshPhongMaterialParameters parameters]? ) <br />
			[constructor:IMeshPhongMaterial IMeshPhongMaterial](  [param:IMeshPhongMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:ITexture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:ITexture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:Combine combine] -  The combine.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:ITexture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:IColor emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:ITexture emissiveMap] -  The emissive map.<br />
			[property:ITexture envMap] -  The env map.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:ITexture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:ITexture map] -  The map.<br />
			[property:boolean metal] -  The metal.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:ITexture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number reflectivity] -  The reflectivity.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:number shininess] -  The shininess.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:IColor specular] -  The specular.<br />
			[property:ITexture specularMap] -  The specular map.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshPhongMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshPhongMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshPhongMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IMeshPhongMaterialParameters">IMeshPhongMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:ITexture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:ITexture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? - geometry color in hexadecimal. Default is 0xffffff.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:Combine combine]? -  The combine.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:ITexture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:any emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:ITexture emissiveMap]? -  The emissive map.<br />
			[property:ITexture envMap]? -  The env map.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:ITexture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:ITexture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:number shininess]? -  The shininess.<br />
			[property:Side side]? -  The side.<br />
			[property:any specular]? -  The specular.<br />
			[property:ITexture specularMap]? -  The specular map.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:string wireframeLinecap]? -  The wireframe linecap.<br />
			[property:string wireframeLinejoin]? -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IMeshStandardMaterial] &rarr;

		<h3 id="IMeshPhysicalMaterial">IMeshPhysicalMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshPhysicalMaterial IMeshPhysicalMaterial](  [param:IMeshPhysicalMaterialParameters parameters]? ) <br />
			[constructor:IMeshPhysicalMaterial IMeshPhysicalMaterial](  [param:IMeshPhysicalMaterialParameters parameters]?,  [param:IMeshStandardMaterialParameters parameters]? ) <br />
			[constructor:IMeshPhysicalMaterial IMeshPhysicalMaterial](  [param:IMeshPhysicalMaterialParameters parameters]?,  [param:IMeshStandardMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:ITexture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:IColor attenuationColor] -  The attenuation color.<br />
			[property:number attenuationDistance] -  The attenuation distance.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:ITexture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:number clearcoat] -  The clearcoat.<br />
			[property:ITexture clearcoatMap] -  The clearcoat map.<br />
			[property:ITexture clearcoatNormalMap] -  The clearcoat normal map.<br />
			[property:IVector2|Vector2 clearcoatNormalScale] -  The clearcoat normal scale.<br />
			[property:number clearcoatRoughness] -  The clearcoat roughness.<br />
			[property:ITexture clearcoatRoughnessMap] -  The clearcoat roughness map.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:ITexture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:IColor emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:ITexture emissiveMap] -  The emissive map.<br />
			[property:ITexture envMap] -  The env map.<br />
			[property:number envMapIntensity] -  The env map intensity.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:number ior] -  The ior.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isMeshStandardMaterial] -  The is mesh standard material.<br />
			[property:ITexture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:ITexture map] -  The map.<br />
			[property:number metalness] -  The metalness.<br />
			[property:ITexture metalnessMap] -  The metalness map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:ITexture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number reflectivity] -  The reflectivity.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:number roughness] -  The roughness.<br />
			[property:ITexture roughnessMap] -  The roughness map.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:number sheen] -  The sheen.<br />
			[property:IColor sheenColor] -  The sheen color.<br />
			[property:ITexture sheenColorMap] -  The sheen color map.<br />
			[property:number sheenRoughness] -  The sheen roughness.<br />
			[property:ITexture sheenRoughnessMap] -  The sheen roughness map.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:IColor specularColor] -  The specular color.<br />
			[property:ITexture specularColorMap] -  The specular color map.<br />
			[property:number specularIntensity] -  The specular intensity.<br />
			[property:ITexture specularIntensityMap] -  The specular intensity map.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:number thickness] -  The thickness.<br />
			[property:ITexture thicknessMap] -  The thickness map.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:number transmission] -  The transmission.<br />
			[property:ITexture transmissionMap] -  The transmission map.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshPhysicalMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshPhysicalMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshStandardMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr; [page:IMeshStandardMaterialParameters] &rarr;

		<h3 id="IMeshPhysicalMaterialParameters">IMeshPhysicalMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:ITexture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:IColor attenuationColor]? -  The attenuation color.<br />
			[property:number attenuationDistance]? -  The attenuation distance.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:ITexture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:number clearcoat]? -  The clearcoat.<br />
			[property:ITexture clearcoatMap]? -  The clearcoat map.<br />
			[property:ITexture clearcoatNormalMap]? -  The clearcoat normal map.<br />
			[property:IVector2|Vector2 clearcoatNormalScale]? -  The clearcoat normal scale.<br />
			[property:number clearcoatRoughness]? -  The clearcoat roughness.<br />
			[property:ITexture clearcoatRoughnessMap]? -  The clearcoat roughness map.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:ITexture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:any emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:ITexture emissiveMap]? -  The emissive map.<br />
			[property:ITexture envMap]? -  The env map.<br />
			[property:number envMapIntensity]? -  The env map intensity.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:number ior]? -  The ior.<br />
			[property:ITexture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:ITexture map]? -  The map.<br />
			[property:number metalness]? -  The metalness.<br />
			[property:ITexture metalnessMap]? -  The metalness map.<br />
			[property:string name]? -  The name.<br />
			[property:ITexture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:number roughness]? -  The roughness.<br />
			[property:ITexture roughnessMap]? -  The roughness map.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:number sheen]? -  The sheen.<br />
			[property:IColor sheenColor]? -  The sheen color.<br />
			[property:number sheenRoughness]? -  The sheen roughness.<br />
			[property:Side side]? -  The side.<br />
			[property:IColor specularColor]? -  The specular color.<br />
			[property:ITexture specularColorMap]? -  The specular color map.<br />
			[property:number specularIntensity]? -  The specular intensity.<br />
			[property:ITexture specularIntensityMap]? -  The specular intensity map.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:number transmission]? -  The transmission.<br />
			[property:ITexture transmissionMap]? -  The transmission map.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IMeshStandardMaterial">IMeshStandardMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshStandardMaterial IMeshStandardMaterial](  [param:IMeshStandardMaterialParameters parameters]? ) <br />
			[constructor:IMeshStandardMaterial IMeshStandardMaterial](  [param:IMeshStandardMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:ITexture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:ITexture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:ITexture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:IColor emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:ITexture emissiveMap] -  The emissive map.<br />
			[property:ITexture envMap] -  The env map.<br />
			[property:number envMapIntensity] -  The env map intensity.<br />
			[property:boolean flatShading] - Define whether the material is rendered with flat shading. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isMeshStandardMaterial] -  The is mesh standard material.<br />
			[property:ITexture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:ITexture map] -  The map.<br />
			[property:number metalness] -  The metalness.<br />
			[property:ITexture metalnessMap] -  The metalness map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:ITexture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number refractionRatio] -  The refraction ratio.<br />
			[property:number roughness] -  The roughness.<br />
			[property:ITexture roughnessMap] -  The roughness map.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshStandardMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshStandardMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshStandardMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IMeshStandardMaterialParameters">IMeshStandardMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:ITexture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:ITexture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:ITexture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:any emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:ITexture emissiveMap]? -  The emissive map.<br />
			[property:ITexture envMap]? -  The env map.<br />
			[property:number envMapIntensity]? -  The env map intensity.<br />
			[property:boolean flatShading]? -  The flat shading.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:ITexture map]? -  The map.<br />
			[property:number metalness]? -  The metalness.<br />
			[property:ITexture metalnessMap]? -  The metalness map.<br />
			[property:string name]? -  The name.<br />
			[property:ITexture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number refractionRatio]? -  The refraction ratio.<br />
			[property:number roughness]? -  The roughness.<br />
			[property:ITexture roughnessMap]? -  The roughness map.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:IStandardNode] &rarr;

		<h3 id="IMeshStandardNode">IMeshStandardNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshStandardNode IMeshStandardNode](  ) <br />
			[constructor:IMeshStandardNode IMeshStandardNode](  ) <br />
			[constructor:IMeshStandardNode IMeshStandardNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any inputs] -  The inputs.<br />
			[property:any isNode] -  The is node.<br />
			[property:INode metalness] -  The metalness.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:any properties] -  The properties.<br />
			[property:INode roughness] -  The roughness.<br />
			[property:INode sheenColor] -  The sheen color.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder] ) <br />
			[method:IMeshStandardNode copy](  [param:IStandardNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:IMeshStandardNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr; [page:INodeMaterial] &rarr;

		<h3 id="IMeshStandardNodeMaterial">IMeshStandardNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshStandardNodeMaterial IMeshStandardNodeMaterial](  ) <br />
			[constructor:IMeshStandardNodeMaterial IMeshStandardNodeMaterial](  [param:INode vertex],  [param:INode fragment] ) <br />
			[constructor:IMeshStandardNodeMaterial IMeshStandardNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:IMeshStandardNodeMaterial IMeshStandardNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor|INode color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:INode|ICubeTexture envMap] -  The env map.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:INode|IRawNode fragment] -  The fragment.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:ITexture|INode map] -  The map.<br />
			[property:number|INode metalness] -  The metalness.<br />
			[property:ITexture|INode metalnessMap] -  The metalness map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:ITexture|INode normalMap] -  The normal map.<br />
			[property:IVector2|INode normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:object properties] -  The properties.<br />
			[property:number|INode roughness] -  The roughness.<br />
			[property:ITexture|INode roughnessMap] -  The roughness map.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:INode|IRawNode vertex] -  The vertex.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshStandardNodeMaterial build](  [param:INodeMaterialBuildParams params]? ) <br />
			[method:IMeshStandardNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshStandardNodeMaterial copy](  [param:INodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IMeshSurfaceSampler">IMeshSurfaceSampler <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshSurfaceSampler IMeshSurfaceSampler](  [param:IMesh mesh] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:Float32Array distribution] -  The distribution.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:Float32Array positionAttribute] -  The position attribute.<br />
			[property:string weightAttribute] -  The weight attribute.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number binarySearch](  [param:number x] ) <br />
			[method:IMeshSurfaceSampler build](  ) <br />
			[method:IMeshSurfaceSampler sample](  [param:IVector3 targetPosition],  [param:IVector3 targetNormal]?,  [param:IColor targetColor]? ) <br />
			[method:IMeshSurfaceSampler sampleFace](  [param:number faceIndex],  [param:IVector3 targetPosition],  [param:IVector3 targetNormal]?,  [param:IColor targetColor]? ) <br />
			[method:IMeshSurfaceSampler setWeightAttribute](  [param:string name] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IMeshToonMaterial">IMeshToonMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMeshToonMaterial IMeshToonMaterial](  [param:IMeshToonMaterialParameters parameters]? ) <br />
			[constructor:IMeshToonMaterial IMeshToonMaterial](  [param:IMeshToonMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:ITexture aoMap] -  The ao map.<br />
			[property:number aoMapIntensity] -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:ITexture bumpMap] -  The bump map.<br />
			[property:number bumpScale] -  The bump scale.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:number displacementBias] -  The displacement bias.<br />
			[property:ITexture displacementMap] -  The displacement map.<br />
			[property:number displacementScale] -  The displacement scale.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:IColor emissive] -  The emissive.<br />
			[property:number emissiveIntensity] -  The emissive intensity.<br />
			[property:ITexture emissiveMap] -  The emissive map.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:ITexture gradientMap] -  The gradient map.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:ITexture lightMap] -  The light map.<br />
			[property:number lightMapIntensity] -  The light map intensity.<br />
			[property:ITexture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:ITexture normalMap] -  The normal map.<br />
			[property:NormalMapTypes normalMapType] -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale] -  The normal scale.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:string wireframeLinecap] -  The wireframe linecap.<br />
			[property:string wireframeLinejoin] -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IMeshToonMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IMeshToonMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMeshToonMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IMeshToonMaterialParameters">IMeshToonMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:ITexture aoMap]? -  The ao map.<br />
			[property:number aoMapIntensity]? -  The ao map intensity.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:ITexture bumpMap]? -  The bump map.<br />
			[property:number bumpScale]? -  The bump scale.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? - geometry color in hexadecimal. Default is 0xffffff.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:number displacementBias]? -  The displacement bias.<br />
			[property:ITexture displacementMap]? -  The displacement map.<br />
			[property:number displacementScale]? -  The displacement scale.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:any emissive]? -  The emissive.<br />
			[property:number emissiveIntensity]? -  The emissive intensity.<br />
			[property:ITexture emissiveMap]? -  The emissive map.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture gradientMap]? -  The gradient map.<br />
			[property:ITexture lightMap]? -  The light map.<br />
			[property:number lightMapIntensity]? -  The light map intensity.<br />
			[property:ITexture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:ITexture normalMap]? -  The normal map.<br />
			[property:NormalMapTypes normalMapType]? -  The normal map type.<br />
			[property:IVector2|Vector2 normalScale]? -  The normal scale.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:string wireframeLinecap]? -  The wireframe linecap.<br />
			[property:string wireframeLinejoin]? -  The wireframe linejoin.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IMorphAnimMesh">IMorphAnimMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IMorphAnimMesh IMorphAnimMesh](  [param:IBufferGeometry geometry],  [param:IMaterial material] ) <br />
			[constructor:IMorphAnimMesh IMorphAnimMesh](  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IMorphAnimMesh IMorphAnimMesh](  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationAction activeAction] -  The active action.<br />
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IAnimationMixer mixer] -  The mixer.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IMorphAnimMesh add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IMorphAnimMesh applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IMorphAnimMesh attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IMorphAnimMesh clear](  ) - Removes all child objects.<br />
			[method:IMorphAnimMesh clone](  [param:boolean recursive]? ) <br />
			[method:IMorphAnimMesh copy](  [param:IMorphAnimMesh source] ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void playAnimation](  [param:string label],  [param:number fps] ) <br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IMorphAnimMesh remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IMorphAnimMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IMorphAnimMesh rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IMorphAnimMesh rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IMorphAnimMesh rotateX](  [param:number angle] ) <br />
			[method:IMorphAnimMesh rotateY](  [param:number angle] ) <br />
			[method:IMorphAnimMesh rotateZ](  [param:number angle] ) <br />
			[method:void setDirectionBackward](  ) <br />
			[method:void setDirectionForward](  ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IMorphAnimMesh translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IMorphAnimMesh translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IMorphAnimMesh translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IMorphAnimMesh translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateAnimation](  [param:number delta] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			Imorph anim mesh
		</p>

		<hr class="interface-line"/>
		<h3 id="IMorphTarget">IMorphTarget <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string name] -  The name.<br />
			[property:any vertices] -  The vertices.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="INRRDLoader">INRRDLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INRRDLoader INRRDLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:object fieldFunctions] -  The field functions.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IVolume parse](  [param:string data] ) <br />
			[method:string parseChars](  [param:number[] array],  [param:number start]?,  [param:number end]? ) <br />
			[method:INRRDLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:INRRDLoader setPath](  [param:string value] ) <br />
			[method:INRRDLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:INRRDLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:INRRDLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="INURBSCurve">INURBSCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INURBSCurve INURBSCurve](  [param:number degree],  [param:number[] knots],  [param:IVector3[]|IVector2[]|IVector4[] controlPoints],  [param:number startKnot],  [param:number endKnot] ) <br />
			[constructor:INURBSCurve INURBSCurve](  [param:number degree],  [param:number[] knots],  [param:IVector3[]|IVector2[]|IVector4[] controlPoints],  [param:number startKnot],  [param:number endKnot] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:INURBSCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:INURBSCurve copy](  [param:ICurve source] ) <br />
			[method:INURBSCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector3 getPoint](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getPointAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:IVector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:IVector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector3 getTangent](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getTangentAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INURBSSurface">INURBSSurface <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INURBSSurface INURBSSurface](  [param:number degree1],  [param:number degree2],  [param:number[] knots1],  [param:number[] knots2],  [param: controlPoints] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void getPoint](  [param:number t1],  [param:number t2],  [param:IVector3 target] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr; [page:IRawShaderMaterial] &rarr;

		<h3 id="INgxRawShaderMaterial">INgxRawShaderMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INgxRawShaderMaterial INgxRawShaderMaterial](  [param:IShaderMaterialParameters parameters]?,  [param:string shaderId]?,  [param:GLSLVersion glslVersion]? ) <br />
			[constructor:INgxRawShaderMaterial INgxRawShaderMaterial](  [param:IShaderMaterialParameters parameters]?,  [param:string shaderId]?,  [param:GLSLVersion glslVersion]?,  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:INgxRawShaderMaterial INgxRawShaderMaterial](  [param:IShaderMaterialParameters parameters]?,  [param:string shaderId]?,  [param:GLSLVersion glslVersion]?,  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:INgxRawShaderMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:INgxRawShaderMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr;

		<h3 id="INgxShaderMaterial">INgxShaderMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INgxShaderMaterial INgxShaderMaterial](  [param:IShaderMaterialParameters parameters]?,  [param:string shaderId]?,  [param:GLSLVersion glslVersion]? ) <br />
			[constructor:INgxShaderMaterial INgxShaderMaterial](  [param:IShaderMaterialParameters parameters]?,  [param:string shaderId]?,  [param:GLSLVersion glslVersion]?,  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:INgxShaderMaterial INgxShaderMaterial](  [param:IShaderMaterialParameters parameters]?,  [param:string shaderId]?,  [param:GLSLVersion glslVersion]?,  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:INgxShaderMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:INgxShaderMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INode">INode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INode INode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:INode copy](  [param:INode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:INode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodeBuilder">INodeBuilder <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INodeBuilder INodeBuilder](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean analyzing] -  The analyzing.<br />
			[property:object attributes] -  The attributes.<br />
			[property:string[] caches] -  The caches.<br />
			[property:any code] -  The code.<br />
			[property:object[] contexts] -  The contexts.<br />
			[property:object defines] -  The defines.<br />
			[property:object extensions] -  The extensions.<br />
			[property:any finalCode] -  The final code.<br />
			[property:any includes] -  The includes.<br />
			[property:any inputs] -  The inputs.<br />
			[property:object keywords] -  The keywords.<br />
			[property:any nodeCode] -  The node code.<br />
			[property:object nodeData] -  The node data.<br />
			[property:object[] nodes] -  The nodes.<br />
			[property:any parsCode] -  The pars code.<br />
			[property:string prefixCode] -  The prefix code.<br />
			[property:any requires] -  The requires.<br />
			[property:any resultCode] -  The result code.<br />
			[property:string[] slots] -  The slots.<br />
			[property:object uniforms] -  The uniforms.<br />
			[property:object[] updaters] -  The updaters.
		</p>
		<h4>Methods</h4>
		<p>
			[method:INodeBuilder addCache](  [param:string name] ) <br />
			[method:void addCode](  [param:string code],  [param:string shader]? ) <br />
			[method:INodeBuilder addContext](  [param:object context] ) <br />
			[method:void addFinalCode](  [param:string code],  [param:string shader]? ) <br />
			[method:INodeBuilder addFlow](  [param:string slot],  [param:string cache]?,  [param:object context]? ) <br />
			[method:void addFragmentCode](  [param:string code] ) <br />
			[method:void addFragmentFinalCode](  [param:string code] ) <br />
			[method:void addFragmentNodeCode](  [param:string code] ) <br />
			[method:void addFragmentParsCode](  [param:string code] ) <br />
			[method:void addNodeCode](  [param:string code],  [param:string shader]? ) <br />
			[method:void addParsCode](  [param:string code],  [param:string shader]? ) <br />
			[method:INodeBuilder addSlot](  [param:string name] ) <br />
			[method:void addVaryCode](  [param:string code] ) <br />
			[method:void addVertexCode](  [param:string code] ) <br />
			[method:void addVertexFinalCode](  [param:string code] ) <br />
			[method:void addVertexNodeCode](  [param:string code] ) <br />
			[method:void addVertexParsCode](  [param:string code] ) <br />
			[method:INodeBuilder build](  [param:INode vertex],  [param:INode fragment] ) <br />
			[method:void buildShader](  [param:string shader],  [param:INode node] ) <br />
			[method:string clearFragmentNodeCode](  ) <br />
			[method:string clearNodeCode](  [param:string shader] ) <br />
			[method:string clearVertexNodeCode](  ) <br />
			[method:string colorToVector](  [param:string color] ) <br />
			[method:string colorToVectorProperties](  [param:string color] ) <br />
			[method:INodeUniform createFragmentUniform](  [param:string type],  [param:INode node],  [param:string ns]?,  [param:boolean needsUpdate]?,  [param:string label]? ) <br />
			[method:INodeUniform createUniform](  [param:string shader],  [param:string type],  [param:INode node],  [param:string ns]?,  [param:boolean needsUpdate]?,  [param:string label]? ) <br />
			[method:INodeUniform createVertexUniform](  [param:string type],  [param:INode node],  [param:string ns]?,  [param:boolean needsUpdate]?,  [param:string label]? ) <br />
			[method:void define](  [param:string name],  [param:any value] ) <br />
			[method:INode findNode](  ) <br />
			[method:string format](  [param:string code],  [param:string from],  [param:string to] ) <br />
			[method:any getAttribute](  [param:string name],  [param:string type] ) <br />
			[method:string getCode](  [param:string shader] ) <br />
			[method:string getConstructorFromLength](  [param:number len] ) <br />
			[method:string getElementByIndex](  [param:number index] ) <br />
			[method:string getFormatByType](  [param:string type] ) <br />
			[method:object[] getIncludes](  [param:string type],  [param:string shader] ) <br />
			[method:string getIncludesCode](  [param:string type],  [param:string shader] ) <br />
			[method:number getIndexByElement](  [param:string elm] ) <br />
			[method:object getNodeData](  [param:INode node] ) <br />
			[method:TextureEncoding getTextureEncodingFromMap](  [param:ITexture map] ) <br />
			[method:string getTypeByFormat](  [param:string format] ) <br />
			[method:string getTypeFromLength](  [param:number len] ) <br />
			[method:number getTypeLength](  [param:string type] ) <br />
			[method:string getUuid](  [param:string uuid],  [param:boolean useCache]? ) <br />
			[method:object getVar](  [param:string uuid],  [param:string type],  [param:string ns],  [param:string labelOrShader]?,  [param:string prefix]?,  [param:string label]? ) <br />
			[method:string getVarListCode](  [param:object[] vars],  [param:string prefix]? ) <br />
			[method:object[] getVars](  [param:string shader] ) <br />
			[method:void include](  [param:INode node],  [param:boolean parent]?,  [param:string source]? ) <br />
			[method:boolean isCache](  [param:string name] ) <br />
			[method:boolean isDefined](  [param:string name] ) <br />
			[method:boolean isShader](  [param:string shader] ) <br />
			[method:boolean isSlot](  [param:string name] ) <br />
			[method:boolean isTypeMatrix](  [param:string format] ) <br />
			[method:object mergeDefines](  [param:object defines] ) <br />
			[method:object mergeUniform](  [param:object uniforms] ) <br />
			[method:INodeBuilder removeCache](  ) <br />
			[method:INodeBuilder removeContext](  ) <br />
			[method:INodeBuilder removeFlow](  ) <br />
			[method:INodeBuilder removeSlot](  ) <br />
			[method:void resolve](  ) <br />
			[method:INodeBuilder setMaterial](  [param:IMaterial material],  [param:IWebGLRenderer renderer] ) <br />
			[method:INodeBuilder setShader](  [param:string shader] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodeFlow">INodeFlow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string code] -  The code.<br />
			[property:object extra] -  The extra.<br />
			[property:string result] -  The result.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodeFrame">INodeFrame <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INodeFrame INodeFrame](  [param:number time] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number delta] -  The delta.<br />
			[property:number id] -  The id.<br />
			[property:ITexture renderTexture] -  The render texture.<br />
			[property:IWebGLRenderer renderer] -  The renderer.<br />
			[property:number time] -  The time.
		</p>
		<h4>Methods</h4>
		<p>
			[method:INodeFrame setRenderTexture](  [param:ITexture renderTexture] ) <br />
			[method:INodeFrame setRenderer](  [param:IWebGLRenderer renderer] ) <br />
			[method:INodeFrame update](  [param:number delta] ) <br />
			[method:INodeFrame updateNode](  [param:INode node] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodeLib">INodeLib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void add](  [param:INode node] ) <br />
			[method:void addKeyword](  [param:string name],  [param:any callback],  [param:object cache]? ) <br />
			[method:boolean contains](  [param:string name] ) <br />
			[method:boolean containsKeyword](  [param:string name] ) <br />
			[method:INode get](  [param:string name] ) <br />
			[method:any getKeyword](  [param:string name],  [param:INodeBuilder builder] ) <br />
			[method:INodeLibKeyword getKeywordData](  [param:string name] ) <br />
			[method:void remove](  [param:INode node] ) <br />
			[method:void removeKeyword](  [param:string name] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodeLibKeyword">INodeLibKeyword <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:object cache]? -  The cache.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void callback](  [param:INodeBuilder builder] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr;

		<h3 id="INodeMaterial">INodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INodeMaterial INodeMaterial](  [param:INode vertex],  [param:INode fragment] ) <br />
			[constructor:INodeMaterial INodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:INodeMaterial INodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:INode|IRawNode fragment] -  The fragment.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:object properties] -  The properties.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:INode|IRawNode vertex] -  The vertex.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:INodeMaterial build](  [param:INodeMaterialBuildParams params]? ) <br />
			[method:INodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:INodeMaterial copy](  [param:INodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodeMaterialBuildParams">INodeMaterialBuildParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:INodeBuilder builder]? -  The builder.<br />
			[property:IWebGLRenderer renderer]? -  The renderer.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodePostProcessing">INodePostProcessing <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INodePostProcessing INodePostProcessing](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget renderTarget]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IOrthographicCamera camera] -  The camera.<br />
			[property:INodeMaterial material] -  The material.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IScreenNode output] -  The output.<br />
			[property:IMesh quad] -  The quad.<br />
			[property:IWebGLRenderTarget renderTarget] -  The render target.<br />
			[property:IWebGLRenderer renderer] -  The renderer.<br />
			[property:IScene scene] -  The scene.
		</p>
		<h4>Methods</h4>
		<p>
			[method:INodePostProcessing copy](  [param:INodePostProcessing source] ) <br />
			[method:void render](  [param:IScene scene],  [param:ICamera camera],  [param:INodeFrame frame] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodeUniform">INodeUniform <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INodeUniform INodeUniform](  [param:INodeUniformParams params]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:INode node] -  The node.<br />
			[property:string type] -  The type.<br />
			[property:any value] -  The value.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodeUniformParams">INodeUniformParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string name]? -  The name.<br />
			[property:boolean needsUpdate]? -  The needs update.<br />
			[property:INode node]? -  The node.<br />
			[property:string type]? -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="INodeUtils">INodeUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void addShortcuts](  [param:INode proto],  [param:string proxy],  [param:any[] list] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="INormalMapNode">INormalMapNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INormalMapNode INormalMapNode](  [param:ITextureNode value],  [param:IVector2Node scale]? ) <br />
			[constructor:INormalMapNode INormalMapNode](  [param:ITextureNode value],  [param:IVector2Node scale]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:INormalMapNode INormalMapNode](  [param:ITextureNode value],  [param:IVector2Node scale]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:IVector2Node scale] -  The scale.<br />
			[property:boolean shared] -  The shared.<br />
			[property:boolean toNormalMap] -  The to normal map.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:ITextureNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:INormalMapNode copy](  [param:INormalMapNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:INormalMapNode setLabel](  [param:string name] ) <br />
			[method:INormalMapNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="INormalNode">INormalNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INormalNode INormalNode](  [param:string scope]? ) <br />
			[constructor:INormalNode INormalNode](  [param:string scope]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:INormalNode INormalNode](  [param:string scope]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string LOCAL] -  The l o c a l.<br />
			[property:string WORLD] -  The w o r l d.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:INormalNode copy](  [param:INormalNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:INormalNode setLabel](  [param:string name] ) <br />
			[method:INormalNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IKeyframeTrack] &rarr;

		<h3 id="INumberKeyframeTrack">INumberKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:INumberKeyframeTrack INumberKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:ILinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:ICubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:INumberKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:IKeyframeTrack optimize](  ) <br />
			[method:IKeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:IKeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:IKeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:IKeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IOBB">IOBB <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOBB IOBB](  [param:IVector3 center]?,  [param:IVector3 halfSize]?,  [param:IMatrix3 rotation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IVector3 center] -  The center.<br />
			[property:IVector3 halfSize] -  The half size.<br />
			[property:IMatrix3 rotation] -  The rotation.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IOBB applyMatrix4](  [param:IMatrix4 matrix] ) <br />
			[method:IVector3 clampPoint](  [param:IVector3 point],  [param:IVector3 result] ) <br />
			[method:IOBB clone](  ) <br />
			[method:boolean containsPoint](  [param:IVector3 point] ) <br />
			[method:IOBB copy](  [param:IOBB obb] ) <br />
			[method:boolean equals](  [param:IOBB obb] ) <br />
			[method:IOBB fromBox3](  [param:IBox3 box3] ) <br />
			[method:IVector3 getSize](  [param:IVector3 result] ) <br />
			[method:IVector3 intersectRay](  [param:IRay ray],  [param:IVector3 result] ) <br />
			[method:boolean intersectsBox3](  [param:IBox3 box3] ) <br />
			[method:boolean intersectsOBB](  [param:IOBB obb],  [param:number epsilon] ) <br />
			[method:boolean intersectsPlane](  [param:IPlane plane] ) <br />
			[method:boolean intersectsRay](  [param:IRay ray] ) <br />
			[method:boolean intersectsSphere](  [param:ISphere sphere] ) <br />
			[method:IOBB set](  [param:IVector3 center],  [param:IVector3 halfSize],  [param:IMatrix3 rotation] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IOBJExporter">IOBJExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOBJExporter IOBJExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:string parse](  [param:IObject3D object] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IOBJLoader">IOBJLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOBJLoader IOBJLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:any materials] -  The materials.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IGroup parse](  [param:string data] ) <br />
			[method:IOBJLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IOBJLoader setMaterials](  [param:any materials] ) <br />
			[method:IOBJLoader setPath](  [param:string path] ) <br />
			[method:IOBJLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IOBJLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IOBJLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IObject3D">IObject3D <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IObject3D IObject3D](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IObject3D add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IObject3D applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IObject3D attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IObject3D clear](  ) - Removes all child objects.<br />
			[method:IObject3D clone](  [param:boolean recursive]? ) <br />
			[method:IObject3D copy](  [param:IObject3D source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IObject3D remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IObject3D removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IObject3D rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IObject3D rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IObject3D rotateX](  [param:number angle] ) <br />
			[method:IObject3D rotateY](  [param:number angle] ) <br />
			[method:IObject3D rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IObject3D translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IObject3D translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IObject3D translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IObject3D translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			Object3D
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IObjectLoader">IObjectLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IObjectLoader IObjectLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:T parse](  [param:any json],  [param:any onLoad]? ) <br />
			[method:IAnimationClip[] parseAnimations](  [param:any json] ) <br />
			[method:Promise parseAsync](  [param:any json] ) <br />
			[method:void parseGeometries](  [param:any json] ) <br />
			[method:void parseImages](  [param:any json],  [param:any onLoad] ) <br />
			[method:Promise parseImagesAsync](  [param:any json] ) <br />
			[method:IMaterial[] parseMaterials](  [param:any json],  [param:ITexture[] textures] ) <br />
			[method:T parseObject](  [param:any data],  [param:any[] geometries],  [param:IMaterial[] materials],  [param:IAnimationClip[] animations] ) <br />
			[method:ITexture[] parseTextures](  [param:any json],  [param:any images] ) <br />
			[method:IObjectLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IObjectLoader setPath](  [param:string path] ) <br />
			[method:IObjectLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IObjectLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IObjectLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IPolyhedronGeometry] &rarr;

		<h3 id="IOctahedronGeometry">IOctahedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOctahedronGeometry IOctahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IOctahedronGeometry IOctahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IOctahedronGeometry IOctahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IOctahedronGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IOctree">IOctree <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOctree IOctree](  [param:IBox3 box]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IBox3 box] -  The box.<br />
			[property:IOctree[] subTrees] -  The sub trees.<br />
			[property:ITriangle[] triangles] -  The triangles.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IOctree addTriangle](  [param:ITriangle triangle] ) <br />
			[method:IOctree build](  ) <br />
			[method:IOctree calcBox](  ) <br />
			[method:any capsuleIntersect](  [param:ICapsule capsule] ) <br />
			[method:IOctree fromGraphNode](  [param:IObject3D group] ) <br />
			[method:ITriangle[] getCapsuleTriangles](  [param:ICapsule capsule],  [param:ITriangle[] triangles] ) <br />
			[method:ITriangle[] getRayTriangles](  [param:IRay ray],  [param:ITriangle[] triangles] ) <br />
			[method:ITriangle[] getSphereTriangles](  [param:ISphere sphere],  [param:ITriangle[] triangles] ) <br />
			[method:any rayIntersect](  [param:IRay ray] ) <br />
			[method:any sphereIntersect](  [param:ISphere sphere] ) <br />
			[method:IOctree split](  [param:number level] ) <br />
			[method:any triangleCapsuleIntersect](  [param:ICapsule capsule],  [param:ITriangle triangle] ) <br />
			[method:any triangleSphereIntersect](  [param:ISphere sphere],  [param:ITriangle triangle] ) 
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			This is only available in worker JS contexts, not the DOM.
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IOperatorNode">IOperatorNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOperatorNode IOperatorNode](  [param:INode a],  [param:INode b],  [param:string op] ) <br />
			[constructor:IOperatorNode IOperatorNode](  [param:INode a],  [param:INode b],  [param:string op],  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IOperatorNode IOperatorNode](  [param:INode a],  [param:INode b],  [param:string op],  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string ADD] -  The a d d.<br />
			[property:string DIV] -  The d i v.<br />
			[property:string MUL] -  The m u l.<br />
			[property:string SUB] -  The s u b.<br />
			[property:INode a] -  The a.<br />
			[property:INode b] -  The b.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string op] -  The op.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IOperatorNode copy](  [param:IOperatorNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IOperatorNode setLabel](  [param:string name] ) <br />
			[method:IOperatorNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IOrbitControls">IOrbitControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOrbitControls IOrbitControls](  [param:ICamera object],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoRotate] -  The auto rotate.<br />
			[property:number autoRotateSpeed] -  The auto rotate speed.<br />
			[property:IVector3 center] -  The center.<br />
			[property:number dampingFactor] -  The damping factor.<br />
			[property:HTMLElement|HTMLDocument domElement] -  The dom element.<br />
			[property:boolean enableDamping] -  The enable damping.<br />
			[property:boolean enableKeys] -  The enable keys.<br />
			[property:boolean enablePan] -  The enable pan.<br />
			[property:boolean enableRotate] -  The enable rotate.<br />
			[property:boolean enableZoom] -  The enable zoom.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:number keyPanSpeed] -  The key pan speed.<br />
			[property:any keys] -  The keys.<br />
			[property:number maxAzimuthAngle] -  The max azimuth angle.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number maxPolarAngle] -  The max polar angle.<br />
			[property:number maxZoom] -  The max zoom.<br />
			[property:number minAzimuthAngle] -  The min azimuth angle.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:number minPolarAngle] -  The min polar angle.<br />
			[property:number minZoom] -  The min zoom.<br />
			[property:any mouseButtons] -  The mouse buttons.<br />
			[property:ICamera object] -  The object.<br />
			[property:number panSpeed] -  The pan speed.<br />
			[property:number rotateSpeed] -  The rotate speed.<br />
			[property:boolean screenSpacePanning] -  The screen space panning.<br />
			[property:IVector3 target] -  The target.<br />
			[property:any touches] -  The touches.<br />
			[property:number zoomSpeed] -  The zoom speed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void dispatchEvent](  [param:any event] ) <br />
			[method:void dispose](  ) <br />
			[method:number getAzimuthalAngle](  ) <br />
			[method:number getDistance](  ) <br />
			[method:number getPolarAngle](  ) <br />
			[method:boolean hasEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void listenToKeyEvents](  [param:HTMLElement domElement] ) <br />
			[method:void removeEventListener](  [param:string type],  [param:any listener] ) <br />
			[method:void reset](  ) <br />
			[method:void saveState](  ) <br />
			[method:boolean update](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ICamera] &rarr;

		<h3 id="IOrthographicCamera">IOrthographicCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOrthographicCamera IOrthographicCamera](  [param:number left],  [param:number right],  [param:number top],  [param:number bottom],  [param:number near]?,  [param:number far]? ) <br />
			[constructor:IOrthographicCamera IOrthographicCamera](  [param:number left],  [param:number right],  [param:number top],  [param:number bottom],  [param:number near]?,  [param:number far]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:number bottom] - Camera frustum bottom plane.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number far] - Camera frustum far plane.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isOrthographicCamera] -  The is orthographic camera.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:number left] - Camera frustum left plane.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:IMatrix4|Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:number near] - Camera frustum near plane.<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IMatrix4|Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:IMatrix4|Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:number right] - Camera frustum right plane.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:number top] - Camera frustum top plane.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:any view] -  The view.<br />
			[property:boolean visible] - Object gets rendered if true.<br />
			[property:number zoom] -  The zoom.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IOrthographicCamera add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IOrthographicCamera applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IOrthographicCamera attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IOrthographicCamera clear](  ) - Removes all child objects.<br />
			[method:void clearViewOffset](  ) <br />
			[method:IOrthographicCamera clone](  [param:boolean recursive]? ) <br />
			[method:IOrthographicCamera copy](  [param:IOrthographicCamera source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IOrthographicCamera remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IOrthographicCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IOrthographicCamera rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IOrthographicCamera rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IOrthographicCamera rotateX](  [param:number angle] ) <br />
			[method:IOrthographicCamera rotateY](  [param:number angle] ) <br />
			[method:IOrthographicCamera rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:void setViewOffset](  [param:number fullWidth],  [param:number fullHeight],  [param:number offsetX],  [param:number offsetY],  [param:number width],  [param:number height] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IOrthographicCamera translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IOrthographicCamera translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IOrthographicCamera translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IOrthographicCamera translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateProjectionMatrix](  ) - Updates the camera projection matrix. Must be called after change of parameters.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			Camera with orthographic projection<br />
			see {@link https://github.com/mrdoob/three.js/blob/master/src/cameras/OrthographicCamera.js|src/cameras/OrthographicCamera.js}
		</p>

		<hr class="interface-line"/>
		<h3 id="IOutlineEffect">IOutlineEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOutlineEffect IOutlineEffect](  [param:IWebGLRenderer renderer],  [param:IOutlineEffectParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoClear] -  The auto clear.<br />
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:IWebGLShadowMap shadowMap] -  The shadow map.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void clear](  [param:boolean color]?,  [param:boolean depth]?,  [param:boolean stencil]? ) <br />
			[method:number getPixelRatio](  ) <br />
			[method:IVector2 getSize](  [param:IVector2 target] ) <br />
			[method:void render](  [param:IScene scene],  [param:ICamera camera] ) <br />
			[method:void renderOutline](  [param:IScene scene],  [param:ICamera camera] ) <br />
			[method:void setPixelRatio](  [param:number value] ) <br />
			[method:void setRenderTarget](  [param:IWebGLRenderTarget renderTarget] ) <br />
			[method:void setScissor](  [param:number|IVector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) <br />
			[method:void setScissorTest](  [param:boolean enable] ) <br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:boolean updateStyle]? ) <br />
			[method:void setViewport](  [param:number|IVector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IOutlineEffectParameters">IOutlineEffectParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number defaultAlpha]? -  The default alpha.<br />
			[property:number[] defaultColor]? -  The default color.<br />
			[property:boolean defaultKeepAlive]? -  The default keep alive.<br />
			[property:number defaultThickness]? -  The default thickness.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IWireframeGeometry] &rarr;

		<h3 id="IOutlineGeometry">IOutlineGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOutlineGeometry IOutlineGeometry](  [param:IBufferGeometry geometry],  [param:number scale]? ) <br />
			[constructor:IOutlineGeometry IOutlineGeometry](  [param:IBufferGeometry geometry],  [param:number scale]?,  [param:IBufferGeometry geometry]? ) <br />
			[constructor:IOutlineGeometry IOutlineGeometry](  [param:IBufferGeometry geometry],  [param:number scale]?,  [param:IBufferGeometry geometry]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IOutlineGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			The Outline geometry.<br />
			See the [page:NgxOutlineGeometry ngx3js docs] page for details.<br />
			See the [example:ngx_geometry/OutlineGeometry ngx geometey] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IOutlinePass">IOutlinePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IOutlinePass IOutlinePass](  [param:IVector2 resolution],  [param:IScene scene],  [param:ICamera camera],  [param:IObject3D[] selectedObjects]? ) - Creates an instance of ngx outline pass.<br />
			[constructor:IOutlinePass IOutlinePass](  [param:IVector2 resolution],  [param:IScene scene],  [param:ICamera camera],  [param:IObject3D[] selectedObjects]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:IMeshDepthMaterial depthMaterial] -  The depth material.<br />
			[property:number downSampleRatio] -  The down sample ratio.<br />
			[property:IShaderMaterial edgeDetectionMaterial] -  The edge detection material.<br />
			[property:number edgeGlow] -  The edge glow.<br />
			[property:number edgeStrength] -  The edge strength.<br />
			[property:number edgeThickness] -  The edge thickness.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IColor hiddenEdgeColor] -  The hidden edge color.<br />
			[property:IMeshBasicMaterial maskBufferMaterial] -  The mask buffer material.<br />
			[property:IShaderMaterial materialCopy] -  The material copy.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number oldClearAlpha] -  The old clear alpha.<br />
			[property:IColor oldClearColor] -  The old clear color.<br />
			[property:IShaderMaterial overlayMaterial] -  The overlay material.<br />
			[property:ITexture patternTexture] -  The pattern texture.<br />
			[property:IShaderMaterial prepareMaskMaterial] -  The prepare mask material.<br />
			[property:number pulsePeriod] -  The pulse period.<br />
			[property:ICamera renderCamera] -  The render camera.<br />
			[property:IScene renderScene] -  The render scene.<br />
			[property:IWebGLRenderTarget renderTargetBlurBuffer1] -  The render target blur buffer1.<br />
			[property:IWebGLRenderTarget renderTargetBlurBuffer2] -  The render target blur buffer2.<br />
			[property:IWebGLRenderTarget renderTargetDepthBuffer] -  The render target depth buffer.<br />
			[property:IWebGLRenderTarget renderTargetEdgeBuffer1] -  The render target edge buffer1.<br />
			[property:IWebGLRenderTarget renderTargetEdgeBuffer2] -  The render target edge buffer2.<br />
			[property:IWebGLRenderTarget renderTargetMaskBuffer] -  The render target mask buffer.<br />
			[property:IWebGLRenderTarget renderTargetMaskDownSampleBuffer] -  The render target mask down sample buffer.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IVector2 resolution] -  The resolution.<br />
			[property:IObject3D[] selectedObjects] -  The selected objects.<br />
			[property:IShaderMaterial separableBlurMaterial1] -  The separable blur material1.<br />
			[property:IShaderMaterial separableBlurMaterial2] -  The separable blur material2.<br />
			[property:IColor tempPulseColor1] -  The temp pulse color1.<br />
			[property:IColor tempPulseColor2] -  The temp pulse color2.<br />
			[property:IMatrix4 textureMatrix] -  The texture matrix.<br />
			[property:boolean usePatternTexture] -  The use pattern texture.<br />
			[property:IColor visibleEdgeColor] -  The visible edge color.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void changeVisibilityOfNonSelectedObjects](  [param:boolean bVisible] ) <br />
			[method:void changeVisibilityOfSelectedObjects](  [param:boolean bVisible] ) <br />
			[method:void dispose](  ) <br />
			[method:IShaderMaterial getEdgeDetectionMaterial](  ) <br />
			[method:IShaderMaterial getOverlayMaterial](  ) <br />
			[method:IShaderMaterial getPrepareMaskMaterial](  ) <br />
			[method:IShaderMaterial getSeperableBlurMaterial](  ) <br />
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) <br />
			[method:void updateTextureMatrix](  ) 
		</p>

		<p class="desc">
			OutlinePass pass<br />
			See the [page:NgxOutlinePass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/OutlinePass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IPCDLoader">IPCDLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPCDLoader IPCDLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:boolean littleEndian] -  The little endian.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IPoints parse](  [param:string|ArrayBuffer data],  [param:string url] ) <br />
			[method:IPCDLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IPCDLoader setPath](  [param:string path] ) <br />
			[method:IPCDLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IPCDLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IPCDLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPDB">IPDB <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IBufferGeometry geometryAtoms] -  The geometry atoms.<br />
			[property:IBufferGeometry geometryBonds] -  The geometry bonds.<br />
			[property:any json] -  The json.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IPDBLoader">IPDBLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPDBLoader IPDBLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IPDB parse](  [param:string text] ) <br />
			[method:IPDBLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IPDBLoader setPath](  [param:string path] ) <br />
			[method:IPDBLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IPDBLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IPDBLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPLYExporter">IPLYExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPLYExporter IPLYExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:string parse](  [param:IObject3D object],  [param:any onDone],  [param:IPLYExporterOptions options] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPLYExporterOptions">IPLYExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean binary]? -  The binary.<br />
			[property:string[] excludeAttributes]? -  The exclude attributes.<br />
			[property:boolean littleEndian]? -  The little endian.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IPLYLoader">IPLYLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPLYLoader IPLYLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:object propertyNameMapping] -  The property name mapping.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IBufferGeometry parse](  [param:string|ArrayBuffer data] ) <br />
			[method:IPLYLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IPLYLoader setPath](  [param:string path] ) <br />
			[method:void setPropertyNameMapping](  [param:object mapping] ) <br />
			[method:IPLYLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IPLYLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IPLYLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPMREMGenerator">IPMREMGenerator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPMREMGenerator IPMREMGenerator](  [param:IWebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void compileCubemapShader](  ) <br />
			[method:void compileEquirectangularShader](  ) <br />
			[method:void dispose](  ) <br />
			[method:IWebGLRenderTarget fromCubemap](  [param:ICubeTexture cubemap] ) <br />
			[method:IWebGLRenderTarget fromEquirectangular](  [param:ITexture equirectangular] ) <br />
			[method:IWebGLRenderTarget fromScene](  [param:IScene scene],  [param:number sigma]?,  [param:number near]?,  [param:number far]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IPRWMLoader">IPRWMLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPRWMLoader IPRWMLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:boolean isBigEndianPlatform](  ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IBufferGeometry parse](  [param:ArrayBuffer data] ) <br />
			[method:IPRWMLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IPRWMLoader setPath](  [param:string path] ) <br />
			[method:IPRWMLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IPRWMLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IPRWMLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPVR">IPVR <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:CompressedPixelFormat format] -  The format.<br />
			[property:number height] -  The height.<br />
			[property:boolean isCubemap] -  The is cubemap.<br />
			[property:number mipmapCount] -  The mipmap count.<br />
			[property:object[] mipmaps] -  The mipmaps.<br />
			[property:number width] -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr; [page:ICompressedTextureLoader] &rarr;

		<h3 id="IPVRLoader">IPVRLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPVRLoader IPVRLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ICompressedTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IPVR parse](  [param:ArrayBuffer buffer],  [param:boolean loadMipmaps] ) <br />
			[method:IPVRLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IPVRLoader setPath](  [param:string path] ) <br />
			[method:IPVRLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IPVRLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IPVRLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPanel">IPanel <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPanel IPanel](  [param:string name]?,  [param:string fg]?,  [param:string bg]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLCanvasElement dom] -  The dom.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void update](  [param:number value],  [param:number maxValue] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IParallaxBarrierEffect">IParallaxBarrierEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IParallaxBarrierEffect IParallaxBarrierEffect](  [param:IWebGLRenderer renderer] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IScene scene],  [param:ICamera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IParametricGeometries">IParametricGeometries <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IParametricPlaneGeometry PlaneGeometry] -  The plane geometry.<br />
			[property:IParametricSphereGeometry SphereGeometry] -  The sphere geometry.<br />
			[property:IParametricTorusKnotGeometry TorusKnotGeometry] -  The torus knot geometry.<br />
			[property:IParametricTubeGeometry TubeGeometry] -  The tube geometry.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IVector3 klein](  [param:number v],  [param:number u],  [param:IVector3 target] ) <br />
			[method:IVector3 mobius](  [param:number u],  [param:number t],  [param:IVector3 target] ) <br />
			[method:IVector3 mobius3d](  [param:number u],  [param:number t],  [param:IVector3 target] ) <br />
			[method:void plane](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IParametricGeometry">IParametricGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IParametricGeometry IParametricGeometry](  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) <br />
			[constructor:IParametricGeometry IParametricGeometry](  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IParametricGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IParametricGeometry] &rarr;

		<h3 id="IParametricPlaneGeometry">IParametricPlaneGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IParametricPlaneGeometry IParametricPlaneGeometry](  [param:number width],  [param:number depth],  [param:number segmentsWidth],  [param:number segmentsDepth] ) <br />
			[constructor:IParametricPlaneGeometry IParametricPlaneGeometry](  [param:number width],  [param:number depth],  [param:number segmentsWidth],  [param:number segmentsDepth],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) <br />
			[constructor:IParametricPlaneGeometry IParametricPlaneGeometry](  [param:number width],  [param:number depth],  [param:number segmentsWidth],  [param:number segmentsDepth],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IParametricPlaneGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IParametricGeometry] &rarr;

		<h3 id="IParametricSphereGeometry">IParametricSphereGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IParametricSphereGeometry IParametricSphereGeometry](  [param:number size],  [param:number u],  [param:number v] ) <br />
			[constructor:IParametricSphereGeometry IParametricSphereGeometry](  [param:number size],  [param:number u],  [param:number v],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) <br />
			[constructor:IParametricSphereGeometry IParametricSphereGeometry](  [param:number size],  [param:number u],  [param:number v],  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IParametricSphereGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IParametricGeometry] &rarr; [page:IParametricTubeGeometry] &rarr;

		<h3 id="IParametricTorusKnotGeometry">IParametricTorusKnotGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IParametricTorusKnotGeometry IParametricTorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number segmentsT]?,  [param:number segmentsR]?,  [param:number p]?,  [param:number q]? ) <br />
			[constructor:IParametricTorusKnotGeometry IParametricTorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number segmentsT]?,  [param:number segmentsR]?,  [param:number p]?,  [param:number q]?,  [param:ICurve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]? ) <br />
			[constructor:IParametricTorusKnotGeometry IParametricTorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number segmentsT]?,  [param:number segmentsR]?,  [param:number p]?,  [param:number q]?,  [param:ICurve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) <br />
			[constructor:IParametricTorusKnotGeometry IParametricTorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number segmentsT]?,  [param:number segmentsR]?,  [param:number p]?,  [param:number q]?,  [param:ICurve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IParametricTorusKnotGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IParametricGeometry] &rarr;

		<h3 id="IParametricTubeGeometry">IParametricTubeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IParametricTubeGeometry IParametricTubeGeometry](  [param:ICurve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]? ) <br />
			[constructor:IParametricTubeGeometry IParametricTubeGeometry](  [param:ICurve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) <br />
			[constructor:IParametricTubeGeometry IParametricTubeGeometry](  [param:ICurve path],  [param:number segments]?,  [param:number radius]?,  [param:number segmentsRadius]?,  [param:boolean closed]?,  [param:any func]?,  [param:number slices]?,  [param:number stacks]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IParametricTubeGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPass">IPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPass IPass](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr; [page:ICurvePath] &rarr;

		<h3 id="IPath">IPath <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPath IPath](  [param:any points]? ) <br />
			[constructor:IPath IPath](  [param:any points]? ) <br />
			[constructor:IPath IPath](  [param:any points]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:boolean autoClose] -  The auto close.<br />
			[property:IVector2|Vector2 currentPoint] -  The current point.<br />
			[property:ICurve[] curves] -  The curves.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPath absarc](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[method:IPath absellipse](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[method:void add](  [param:ICurve curve] ) <br />
			[method:IPath arc](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[method:IPath bezierCurveTo](  [param:number aCP1x],  [param:number aCP1y],  [param:number aCP2x],  [param:number aCP2y],  [param:number aX],  [param:number aY] ) <br />
			[method:IPath clone](  ) <br />
			[method:void closePath](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:IPath copy](  [param:ICurve source] ) <br />
			[method:IPath ellipse](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[method:IPath fromJSON](  [param:object json] ) <br />
			[method:IPath fromPoints](  [param:any vectors] ) <br />
			[method:number[] getCurveLengths](  ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector2|Vector2 getPoint](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getPointAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:void getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:void getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector2|Vector2 getTangent](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getTangentAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:IPath lineTo](  [param:number x],  [param:number y] ) <br />
			[method:IPath moveTo](  [param:number x],  [param:number y] ) <br />
			[method:IPath quadraticCurveTo](  [param:number aCPx],  [param:number aCPy],  [param:number aX],  [param:number aY] ) <br />
			[method:IPath setFromPoints](  [param:any vectors] ) <br />
			[method:IPath splineThru](  [param:any pts] ) <br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			a 2d path representation, comprising of points, lines, and cubes, similar to the html5 2d canvas api. It extends CurvePath.
		</p>

		<hr class="interface-line"/>
		<h3 id="IPeppersGhostEffect">IPeppersGhostEffect <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPeppersGhostEffect IPeppersGhostEffect](  [param:IWebGLRenderer renderer] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number cameraDistance] -  The camera distance.<br />
			[property:boolean reflectFromAbove] -  The reflect from above.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IScene scene],  [param:ICamera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ICamera] &rarr;

		<h3 id="IPerspectiveCamera">IPerspectiveCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPerspectiveCamera IPerspectiveCamera](  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) <br />
			[constructor:IPerspectiveCamera IPerspectiveCamera](  [param:number fov]?,  [param:number aspect]?,  [param:number near]?,  [param:number far]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:number aspect] - Camera frustum aspect ratio, window width divided by window height.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number far] - Camera frustum far plane.<br />
			[property:number filmGauge] -  The film gauge.<br />
			[property:number filmOffset] -  The film offset.<br />
			[property:number focus] -  The focus.<br />
			[property:number fov] - Camera frustum vertical field of view, from bottom to top of view, in degrees.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isPerspectiveCamera] -  The is perspective camera.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:IMatrix4|Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:number near] - Camera frustum near plane.<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IMatrix4|Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:IMatrix4|Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:any view] -  The view.<br />
			[property:boolean visible] - Object gets rendered if true.<br />
			[property:number zoom] -  The zoom.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPerspectiveCamera add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IPerspectiveCamera applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IPerspectiveCamera attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IPerspectiveCamera clear](  ) - Removes all child objects.<br />
			[method:void clearViewOffset](  ) <br />
			[method:IPerspectiveCamera clone](  [param:boolean recursive]? ) <br />
			[method:IPerspectiveCamera copy](  [param:IPerspectiveCamera source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:number getEffectiveFOV](  ) <br />
			[method:number getFilmHeight](  ) <br />
			[method:number getFilmWidth](  ) <br />
			[method:number getFocalLength](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IPerspectiveCamera remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IPerspectiveCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IPerspectiveCamera rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IPerspectiveCamera rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IPerspectiveCamera rotateX](  [param:number angle] ) <br />
			[method:IPerspectiveCamera rotateY](  [param:number angle] ) <br />
			[method:IPerspectiveCamera rotateZ](  [param:number angle] ) <br />
			[method:void setFocalLength](  [param:number focalLength] ) <br />
			[method:void setLens](  [param:number focalLength],  [param:number frameHeight]? ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:void setViewOffset](  [param:number fullWidth],  [param:number fullHeight],  [param:number x],  [param:number y],  [param:number width],  [param:number height] ) - Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.<br />
			For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:<br />
			+---+---+---+<br />
			| A | B | C |<br />
			+---+---+---+<br />
			| D | E | F |<br />
			+---+---+---+<br />
			<br />
			then for each monitor you would call it like this:<br />
			<br />
			const w = 1920;<br />
			const h = 1080;<br />
			const fullWidth = w * 3;<br />
			const fullHeight = h * 2;<br />
			<br />
			// A<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );<br />
			// B<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );<br />
			// C<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );<br />
			// D<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );<br />
			// E<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );<br />
			// F<br />
			camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); Note there is no reason monitors have to be the same size or in a grid.<br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IPerspectiveCamera translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IPerspectiveCamera translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IPerspectiveCamera translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IPerspectiveCamera translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateProjectionMatrix](  ) - Updates the camera projection matrix. Must be called after change of parameters.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			Camera with perspective projection.
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr;

		<h3 id="IPhongNode">IPhongNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPhongNode IPhongNode](  ) <br />
			[constructor:IPhongNode IPhongNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:INode shininess] -  The shininess.<br />
			[property:INode specular] -  The specular.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder] ) <br />
			[method:IPhongNode copy](  [param:IPhongNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:IPhongNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr; [page:INodeMaterial] &rarr;

		<h3 id="IPhongNodeMaterial">IPhongNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPhongNodeMaterial IPhongNodeMaterial](  ) <br />
			[constructor:IPhongNodeMaterial IPhongNodeMaterial](  [param:INode vertex],  [param:INode fragment] ) <br />
			[constructor:IPhongNodeMaterial IPhongNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:IPhongNodeMaterial IPhongNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode alpha] -  The alpha.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:INode ambient] -  The ambient.<br />
			[property:INode ao] -  The ao.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:INode color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:INode emissive] -  The emissive.<br />
			[property:INode environment] -  The environment.<br />
			[property:INode environmentAlpha] -  The environment alpha.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:INode|IRawNode fragment] -  The fragment.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:INode light] -  The light.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:INode mask] -  The mask.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:INode normal] -  The normal.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:INode position] -  The position.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:object properties] -  The properties.<br />
			[property:INode shadow] -  The shadow.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:INode shininess] -  The shininess.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:INode specular] -  The specular.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:INode|IRawNode vertex] -  The vertex.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IPhongNodeMaterial build](  [param:INodeMaterialBuildParams params]? ) <br />
			[method:IPhongNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IPhongNodeMaterial copy](  [param:INodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPlane">IPlane <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPlane IPlane](  [param:IVector3|Vector3 normal]?,  [param:number constant]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number constant] -  The constant.<br />
			[property:any isPlane] -  The is plane.<br />
			[property:IVector3 normal] -  The normal.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPlane applyMatrix4](  [param:IMatrix4 matrix],  [param:IMatrix3|Matrix3 optionalNormalMatrix]? ) <br />
			[method:IPlane clone](  ) <br />
			[method:IVector3 coplanarPoint](  [param:IVector3|Vector3 target] ) <br />
			[method:IPlane copy](  [param:IPlane plane] ) <br />
			[method:number distanceToPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:number distanceToSphere](  [param:ISphere sphere] ) <br />
			[method:boolean equals](  [param:IPlane plane] ) <br />
			[method:IVector3 intersectLine](  [param:ILine3 line],  [param:IVector3|Vector3 target] ) <br />
			[method:boolean intersectsBox](  [param:IBox3 box] ) <br />
			[method:boolean intersectsLine](  [param:ILine3 line] ) <br />
			[method:boolean intersectsSphere](  [param:ISphere sphere] ) <br />
			[method:any isIntersectionLine](  [param:any l] ) <br />
			[method:IPlane negate](  ) <br />
			[method:IPlane normalize](  ) <br />
			[method:IVector3 orthoPoint](  [param:IVector3|Vector3 point],  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 projectPoint](  [param:IVector3|Vector3 point],  [param:IVector3|Vector3 target] ) <br />
			[method:IPlane set](  [param:IVector3|Vector3 normal],  [param:number constant] ) <br />
			[method:IPlane setComponents](  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IPlane setFromCoplanarPoints](  [param:IVector3|Vector3 a],  [param:IVector3|Vector3 b],  [param:IVector3|Vector3 c] ) <br />
			[method:IPlane setFromNormalAndCoplanarPoint](  [param:IVector3|Vector3 normal],  [param:IVector3|Vector3 point] ) <br />
			[method:IPlane translate](  [param:IVector3|Vector3 offset] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IPlaneDepthGeometry">IPlaneDepthGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPlaneDepthGeometry IPlaneDepthGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthRate]? ) <br />
			[constructor:IPlaneDepthGeometry IPlaneDepthGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthRate]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] - The Parameters of plane depth geometry<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IPlaneDepthGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IPlaneGeometry">IPlaneGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPlaneGeometry IPlaneGeometry](  [param:number width]?,  [param:number height]?,  [param:number widthSegments]?,  [param:number heightSegments]? ) <br />
			[constructor:IPlaneGeometry IPlaneGeometry](  [param:number width]?,  [param:number height]?,  [param:number widthSegments]?,  [param:number heightSegments]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IPlaneGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="IPlaneHelper">IPlaneHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPlaneHelper IPlaneHelper](  [param:IPlane plane],  [param:number size]?,  [param:number hex]? ) <br />
			[constructor:IPlaneHelper IPlaneHelper](  [param:IPlane plane],  [param:number size]?,  [param:number hex]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IPlaneHelper IPlaneHelper](  [param:IPlane plane],  [param:number size]?,  [param:number hex]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IPlaneHelper IPlaneHelper](  [param:IPlane plane],  [param:number size]?,  [param:number hex]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IPlane plane] -  The plane.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:number size] -  The size.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPlaneHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IPlaneHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IPlaneHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IPlaneHelper clear](  ) - Removes all child objects.<br />
			[method:IPlaneHelper clone](  [param:boolean recursive]? ) <br />
			[method:IPlaneHelper computeLineDistances](  ) <br />
			[method:IPlaneHelper copy](  [param:IPlaneHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IPlaneHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IPlaneHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IPlaneHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IPlaneHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IPlaneHelper rotateX](  [param:number angle] ) <br />
			[method:IPlaneHelper rotateY](  [param:number angle] ) <br />
			[method:IPlaneHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IPlaneHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IPlaneHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IPlaneHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IPlaneHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPlanePerlinGeometry">IPlanePerlinGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPlanePerlinGeometry IPlanePerlinGeometry](  [param:number worldWidth],  [param:number worldDepth],  [param:number quality]? ) - Creates an instance of plane perlin geometry.
		</p>
		<h4>Properties</h4>
		<p>
			[property:number[] data] - The Data of plane perlin geometry
		</p>
		<h4>Methods</h4>
		<p>
			[method:number[] generateHeight](  [param:number width],  [param:number height],  [param:number quality]? ) - Generates height<br />
			<br />
			Returns : height<br />
			[method:IBufferGeometry getGeometry](  [param:IBufferGeometry planeGeometry],  [param:number[] uv],  [param:any rotate],  [param:any translate],  [param:IColor[] colors]? ) - Gets geometry<br />
			<br />
			Returns : geometry<br />
			[method:IBufferGeometry getMinecraft](  [param:number planeWidth],  [param:number planeHeight],  [param:number planeDepth] ) - Gets minecraft<br />
			<br />
			Returns : minecraft<br />
			[method:IBufferGeometry getMinecraftAo](  [param:number planeWidth],  [param:number planeHeight],  [param:number planeDepth],  [param:IColor light],  [param:IColor shadow] ) - Gets minecraft ao<br />
			<br />
			Returns : minecraft ao<br />
			[method:IBufferGeometry getTerrain](  [param:number planeWidth],  [param:number planeHeight],  [param:number planeDepth] ) - Gets terrain<br />
			<br />
			Returns : terrain<br />
			[method:HTMLCanvasElement getTexture](  [param:IVector3 sun],  [param:IColor color],  [param:IColor add] ) - Gets texture<br />
			<br />
			Returns : texture<br />
			[method:number getY](  [param:number x],  [param:number z] ) - Gets y
		</p>

		<p class="desc">
			The Plane Perlin geometry.<br />
			See the [page:NgxPlanePerlinGeometry ngx3js docs] page for details.<br />
			See the [example:ngx_geometry/PlanePerlinGeometry ngx geometey] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILight] &rarr;

		<h3 id="IPointLight">IPointLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPointLight IPointLight](  [param:any color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number decay]? ) <br />
			[constructor:IPointLight IPointLight](  [param:any color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:IPointLight IPointLight](  [param:any color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number decay] -  The decay.<br />
			[property:number distance] - If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] - Light's intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:number power] -  The power.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:IPointLightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPointLight add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IPointLight applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IPointLight attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IPointLight clear](  ) - Removes all child objects.<br />
			[method:IPointLight clone](  [param:boolean recursive]? ) <br />
			[method:IPointLight copy](  [param:IPointLight source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IPointLight remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IPointLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IPointLight rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IPointLight rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IPointLight rotateX](  [param:number angle] ) <br />
			[method:IPointLight rotateY](  [param:number angle] ) <br />
			[method:IPointLight rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IPointLight translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IPointLight translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IPointLight translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IPointLight translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IPointLightHelper">IPointLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPointLightHelper IPointLightHelper](  [param:IPointLight light],  [param:number sphereSize]?,  [param:any color]? ) <br />
			[constructor:IPointLightHelper IPointLightHelper](  [param:IPointLight light],  [param:number sphereSize]?,  [param:any color]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:any color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IPointLight light] -  The light.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPointLightHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IPointLightHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IPointLightHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IPointLightHelper clear](  ) - Removes all child objects.<br />
			[method:IPointLightHelper clone](  [param:boolean recursive]? ) <br />
			[method:IPointLightHelper copy](  [param:IPointLightHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IPointLightHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IPointLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IPointLightHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IPointLightHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IPointLightHelper rotateX](  [param:number angle] ) <br />
			[method:IPointLightHelper rotateY](  [param:number angle] ) <br />
			[method:IPointLightHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IPointLightHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IPointLightHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IPointLightHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IPointLightHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILightShadow] &rarr;

		<h3 id="IPointLightShadow">IPointLightShadow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:number bias] -  The bias.<br />
			[property:number blurSamples] -  The blur samples.<br />
			[property:IPerspectiveCamera camera] -  The camera.<br />
			[property:IWebGLRenderTarget map] -  The map.<br />
			[property:IWebGLRenderTarget mapPass] -  The map pass.<br />
			[property:IVector2|Vector2 mapSize] -  The map size.<br />
			[property:IMatrix4 matrix] -  The matrix.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number normalBias] -  The normal bias.<br />
			[property:number radius] -  The radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPointLightShadow clone](  [param:boolean recursive]? ) <br />
			[method:IPointLightShadow copy](  [param:ILightShadow source] ) <br />
			[method:void dispose](  ) <br />
			[method:IVector2 getFrameExtents](  ) <br />
			[method:number getFrustum](  ) <br />
			[method:IVector4 getViewport](  [param:number viewportIndex] ) <br />
			[method:any toJSON](  ) <br />
			[method:void updateMatrices](  [param:ILight light],  [param:number viewportIndex]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IPointerLockControls">IPointerLockControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPointerLockControls IPointerLockControls](  [param:ICamera camera],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:boolean isLocked] -  The is locked.<br />
			[property:number maxPolarAngle] -  The max polar angle.<br />
			[property:number minPolarAngle] -  The min polar angle.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void connect](  ) <br />
			[method:void disconnect](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IVector3 getDirection](  [param:IVector3 v] ) <br />
			[method:ICamera getObject](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lock](  ) <br />
			[method:void moveForward](  [param:number distance] ) <br />
			[method:void moveRight](  [param:number distance] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void unlock](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IPoints">IPoints <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPoints IPoints](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:IPoints IPoints](  [param:TGeometry geometry]?,  [param:TMaterial material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:TGeometry geometry] - An instance of BufferGeometry, where each vertex designates the position of a particle in the system.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isPoints] -  The is points.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:TMaterial material] - An instance of Material, defining the object's appearance. Default is a PointsMaterial with randomised colour.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPoints add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IPoints applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IPoints attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IPoints clear](  ) - Removes all child objects.<br />
			[method:IPoints clone](  [param:boolean recursive]? ) <br />
			[method:IPoints copy](  [param:IPoints source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IPoints remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IPoints removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IPoints rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IPoints rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IPoints rotateX](  [param:number angle] ) <br />
			[method:IPoints rotateY](  [param:number angle] ) <br />
			[method:IPoints rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IPoints translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IPoints translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IPoints translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IPoints translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			A class for displaying points. The points are rendered by the WebGLRenderer using gl.POINTS.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IPointsMaterial">IPointsMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPointsMaterial IPointsMaterial](  [param:IPointsMaterialParameters parameters]? ) <br />
			[constructor:IPointsMaterial IPointsMaterial](  [param:IPointsMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:ITexture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:number size] -  The size.<br />
			[property:boolean sizeAttenuation] -  The size attenuation.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IPointsMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IPointsMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IPointsMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IPointsMaterialParameters">IPointsMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:number size]? -  The size.<br />
			[property:boolean sizeAttenuation]? -  The size attenuation.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="IPolarGridHelper">IPolarGridHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPolarGridHelper IPolarGridHelper](  [param:number radius]?,  [param:number radials]?,  [param:number circles]?,  [param:number divisions]?,  [param:any color1]?,  [param:any color2]? ) <br />
			[constructor:IPolarGridHelper IPolarGridHelper](  [param:number radius]?,  [param:number radials]?,  [param:number circles]?,  [param:number divisions]?,  [param:any color1]?,  [param:any color2]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IPolarGridHelper IPolarGridHelper](  [param:number radius]?,  [param:number radials]?,  [param:number circles]?,  [param:number divisions]?,  [param:any color1]?,  [param:any color2]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IPolarGridHelper IPolarGridHelper](  [param:number radius]?,  [param:number radials]?,  [param:number circles]?,  [param:number divisions]?,  [param:any color1]?,  [param:any color2]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPolarGridHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IPolarGridHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IPolarGridHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IPolarGridHelper clear](  ) - Removes all child objects.<br />
			[method:IPolarGridHelper clone](  [param:boolean recursive]? ) <br />
			[method:IPolarGridHelper computeLineDistances](  ) <br />
			[method:IPolarGridHelper copy](  [param:IPolarGridHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IPolarGridHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IPolarGridHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IPolarGridHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IPolarGridHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IPolarGridHelper rotateX](  [param:number angle] ) <br />
			[method:IPolarGridHelper rotateY](  [param:number angle] ) <br />
			[method:IPolarGridHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IPolarGridHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IPolarGridHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IPolarGridHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IPolarGridHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IPolyhedronBufferGeometry">IPolyhedronBufferGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPolyhedronBufferGeometry IPolyhedronBufferGeometry](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IPolyhedronBufferGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IPolyhedronGeometry">IPolyhedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPolyhedronGeometry IPolyhedronGeometry](  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:IPolyhedronGeometry IPolyhedronGeometry](  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IPolyhedronGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IPosition">IPosition <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number x] -  The x.<br />
			[property:number y] -  The y.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void set](  [param:number x],  [param:number y] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IPositionNode">IPositionNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPositionNode IPositionNode](  [param:string scope]? ) <br />
			[constructor:IPositionNode IPositionNode](  [param:string scope]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IPositionNode IPositionNode](  [param:string scope]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string LOCAL] -  The l o c a l.<br />
			[property:string PROJECTION] -  The p r o j e c t i o n.<br />
			[property:string VIEW] -  The v i e w.<br />
			[property:string WORLD] -  The w o r l d.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IPositionNode copy](  [param:IPositionNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IPositionNode setLabel](  [param:string name] ) <br />
			[method:IPositionNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IAudio] &rarr;

		<h3 id="IPositionalAudio">IPositionalAudio <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPositionalAudio IPositionalAudio](  [param:IAudioListener listener] ) <br />
			[constructor:IPositionalAudio IPositionalAudio](  [param:IAudioListener listener] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean autoplay] -  The autoplay.<br />
			[property:AudioBuffer buffer] -  The buffer.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:AudioContext context] -  The context.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number detune] -  The detune.<br />
			[property:number duration] -  The duration.<br />
			[property:AudioNode[] filters] -  The filters.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:GainNode gain] -  The gain.<br />
			[property:boolean hasPlaybackControl] -  The has playback control.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:boolean isPlaying] -  The is playing.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IAudioListener listener] -  The listener.<br />
			[property:boolean loop] -  The loop.<br />
			[property:number loopEnd] -  The loop end.<br />
			[property:number loopStart] -  The loop start.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:number offset] -  The offset.<br />
			[property:PannerNode panner] -  The panner.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:number playbackRate] -  The playback rate.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:AudioBufferSourceNode source] -  The source.<br />
			[property:string sourceType] -  The source type.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPositionalAudio add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IPositionalAudio applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IPositionalAudio attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IPositionalAudio clear](  ) - Removes all child objects.<br />
			[method:IPositionalAudio clone](  [param:boolean recursive]? ) <br />
			[method:IPositionalAudio connect](  ) <br />
			[method:IPositionalAudio copy](  [param:IPositionalAudio source],  [param:boolean recursive]? ) <br />
			[method:IPositionalAudio disconnect](  ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:number getDetune](  ) <br />
			[method:string getDistanceModel](  ) <br />
			[method:AudioNode getFilter](  ) <br />
			[method:AudioNode[] getFilters](  ) <br />
			[method:boolean getLoop](  ) <br />
			[method:number getMaxDistance](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:PannerNode getOutput](  ) <br />
			[method:number getPlaybackRate](  ) <br />
			[method:number getRefDistance](  ) <br />
			[method:number getRolloffFactor](  ) <br />
			[method:number getVolume](  ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IAudio load](  [param:string file] ) <br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void onEnded](  ) <br />
			[method:IPositionalAudio pause](  ) <br />
			[method:IPositionalAudio play](  [param:number delay]? ) <br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IPositionalAudio remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IPositionalAudio removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IPositionalAudio rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IPositionalAudio rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IPositionalAudio rotateX](  [param:number angle] ) <br />
			[method:IPositionalAudio rotateY](  [param:number angle] ) <br />
			[method:IPositionalAudio rotateZ](  [param:number angle] ) <br />
			[method:IPositionalAudio setBuffer](  [param:AudioBuffer audioBuffer] ) <br />
			[method:IPositionalAudio setDetune](  [param:number value] ) <br />
			[method:IPositionalAudio setDirectionalCone](  [param:number coneInnerAngle],  [param:number coneOuterAngle],  [param:number coneOuterGain] ) <br />
			[method:IPositionalAudio setDistanceModel](  [param:string value] ) <br />
			[method:IPositionalAudio setFilter](  [param:AudioNode filter] ) <br />
			[method:IPositionalAudio setFilters](  [param:AudioNode[] value] ) <br />
			[method:IPositionalAudio setLoop](  [param:boolean value] ) <br />
			[method:IPositionalAudio setLoopEnd](  [param:number value] ) <br />
			[method:IPositionalAudio setLoopStart](  [param:number value] ) <br />
			[method:IPositionalAudio setMaxDistance](  [param:number value] ) <br />
			[method:IPositionalAudio setMediaElementSource](  [param:HTMLMediaElement mediaElement] ) <br />
			[method:IPositionalAudio setMediaStreamSource](  [param:MediaStream mediaStream] ) <br />
			[method:IPositionalAudio setNodeSource](  [param:AudioBufferSourceNode audioNode] ) <br />
			[method:IPositionalAudio setPlaybackRate](  [param:number value] ) <br />
			[method:IPositionalAudio setRefDistance](  [param:number value] ) <br />
			[method:IPositionalAudio setRolloffFactor](  [param:number value] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IPositionalAudio setVolume](  [param:number value] ) <br />
			[method:IPositionalAudio stop](  ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IPositionalAudio translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IPositionalAudio translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IPositionalAudio translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IPositionalAudio translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr;

		<h3 id="IPositionalAudioHelper">IPositionalAudioHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPositionalAudioHelper IPositionalAudioHelper](  [param:IPositionalAudio audio],  [param:number range]?,  [param:number divisionsInnerAngle]?,  [param:number divisionsOuterAngle]? ) <br />
			[constructor:IPositionalAudioHelper IPositionalAudioHelper](  [param:IPositionalAudio audio],  [param:number range]?,  [param:number divisionsInnerAngle]?,  [param:number divisionsOuterAngle]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IPositionalAudioHelper IPositionalAudioHelper](  [param:IPositionalAudio audio],  [param:number range]?,  [param:number divisionsInnerAngle]?,  [param:number divisionsOuterAngle]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:IPositionalAudio audio] -  The audio.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number divisionsInnerAngle] -  The divisions inner angle.<br />
			[property:number divisionsOuterAngle] -  The divisions outer angle.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:number range] -  The range.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPositionalAudioHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IPositionalAudioHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IPositionalAudioHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IPositionalAudioHelper clear](  ) - Removes all child objects.<br />
			[method:IPositionalAudioHelper clone](  [param:boolean recursive]? ) <br />
			[method:IPositionalAudioHelper computeLineDistances](  ) <br />
			[method:IPositionalAudioHelper copy](  [param:IPositionalAudioHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IPositionalAudioHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IPositionalAudioHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IPositionalAudioHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IPositionalAudioHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IPositionalAudioHelper rotateX](  [param:number angle] ) <br />
			[method:IPositionalAudioHelper rotateY](  [param:number angle] ) <br />
			[method:IPositionalAudioHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IPositionalAudioHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IPositionalAudioHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IPositionalAudioHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IPositionalAudioHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IProgressiveLightMap">IProgressiveLightMap <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IProgressiveLightMap IProgressiveLightMap](  [param:IWebGLRenderer renderer],  [param:number res]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IMesh blurringPlane] -  The blurring plane.<br />
			[property:boolean buffer1Active] -  The buffer1 active.<br />
			[property:boolean compiled] -  The compiled.<br />
			[property:boolean firstUpdate] -  The first update.<br />
			[property:IMeshBasicMaterial labelMaterial] -  The label material.<br />
			[property:IMesh labelMesh] -  The label mesh.<br />
			[property:IPlaneGeometry labelPlane] -  The label plane.<br />
			[property:ILightMapContainers[] lightMapContainers] -  The light map containers.<br />
			[property:IWebGLRenderTarget progressiveLightMap1] -  The progressive light map1.<br />
			[property:IWebGLRenderTarget progressiveLightMap2] -  The progressive light map2.<br />
			[property:IWebGLRenderer renderer] -  The renderer.<br />
			[property:number res] -  The res.<br />
			[property:IScene scene] -  The scene.<br />
			[property:IWebGLRenderTarget tinyTarget] -  The tiny target.<br />
			[property:IMeshPhongMaterial uvMat] -  The uv mat.<br />
			[property:IUVBoxes[] uv_boxes] -  The uv_boxes.<br />
			[property:boolean warned] -  The warned.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addObjectsToLightMap](  [param:IObject3D[] objects] ) <br />
			[method:void showDebugLightmap](  [param:boolean visible],  [param:IVector3 position]? ) <br />
			[method:void update](  [param:ICamera camera],  [param:number blendWindow]?,  [param:boolean blurEdges]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IPropertyNode">IPropertyNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IPropertyNode IPropertyNode](  [param:object object],  [param:string property],  [param:string type] ) <br />
			[constructor:IPropertyNode IPropertyNode](  [param:object object],  [param:string property],  [param:string type],  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IPropertyNode IPropertyNode](  [param:object object],  [param:string property],  [param:string type],  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IPropertyNode IPropertyNode](  [param:object object],  [param:string property],  [param:string type],  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:object object] -  The object.<br />
			[property:string property] -  The property.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:any value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IPropertyNode copy](  [param:IInputNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IPropertyNode setLabel](  [param:string name] ) <br />
			[method:IPropertyNode setName](  [param:string name] ) <br />
			[method:IPropertyNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="IQuadraticBezierCurve">IQuadraticBezierCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IQuadraticBezierCurve IQuadraticBezierCurve](  [param:IVector2|Vector2 v0],  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2] ) <br />
			[constructor:IQuadraticBezierCurve IQuadraticBezierCurve](  [param:IVector2|Vector2 v0],  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:IVector2|Vector2 v0] -  The v0.<br />
			[property:IVector2|Vector2 v1] -  The v1.<br />
			[property:IVector2|Vector2 v2] -  The v2.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IQuadraticBezierCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:IQuadraticBezierCurve copy](  [param:ICurve source] ) <br />
			[method:IQuadraticBezierCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector2|Vector2 getPoint](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getPointAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:void getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:void getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector2|Vector2 getTangent](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getTangentAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="IQuadraticBezierCurve3">IQuadraticBezierCurve3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IQuadraticBezierCurve3 IQuadraticBezierCurve3](  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2] ) <br />
			[constructor:IQuadraticBezierCurve3 IQuadraticBezierCurve3](  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:string type] -  The type.<br />
			[property:IVector3|Vector3 v0] -  The v0.<br />
			[property:IVector3|Vector3 v1] -  The v1.<br />
			[property:IVector3|Vector3 v2] -  The v2.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IQuadraticBezierCurve3 clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:IQuadraticBezierCurve3 copy](  [param:ICurve source] ) <br />
			[method:IQuadraticBezierCurve3 fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector3 getPoint](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getPointAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:IVector3[] getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:IVector3[] getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector3 getTangent](  [param:number t],  [param:IVector3 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector3 getTangentAt](  [param:number u],  [param:IVector3 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IQuaternion">IQuaternion <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IQuaternion IQuaternion](  [param:number x]?,  [param:number y]?,  [param:number z]?,  [param:number w]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isQuaternion] -  The is quaternion.<br />
			[property:number w] -  The w.<br />
			[property:number x] -  The x.<br />
			[property:number y] -  The y.<br />
			[property:number z] -  The z.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IQuaternion|Quaternion _onChange](  [param:any callback] ) <br />
			[method:void _onChangeCallback](  ) <br />
			[method:number angleTo](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IQuaternion clone](  ) - Clones this quaternion.<br />
			[method:IQuaternion|Quaternion conjugate](  ) <br />
			[method:IQuaternion copy](  [param:IQuaternion|Quaternion q] ) - Copies values of q to this quaternion.<br />
			[method:number dot](  [param:IQuaternion|Quaternion v] ) <br />
			[method:boolean equals](  [param:IQuaternion|Quaternion v] ) <br />
			[method:IQuaternion fromArray](  [param:number[]|ArrayLike array],  [param:number offset]? ) - Sets this quaternion's x, y, z and w value from the provided array or array-like.<br />
			[method:IQuaternion|Quaternion identity](  ) <br />
			[method:IQuaternion|Quaternion inverse](  ) <br />
			[method:IQuaternion|Quaternion invert](  ) - Inverts this quaternion.<br />
			[method:number length](  ) - Computes length of this quaternion.<br />
			[method:number lengthSq](  ) <br />
			[method:IQuaternion|Quaternion multiply](  [param:IQuaternion|Quaternion q] ) - Multiplies this quaternion by b.<br />
			[method:IQuaternion|Quaternion multiplyQuaternions](  [param:IQuaternion|Quaternion a],  [param:IQuaternion|Quaternion b] ) - Sets this quaternion to a x b<br />
			Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm.<br />
			[method:any multiplyVector3](  [param:any v] ) <br />
			[method:IQuaternion|Quaternion normalize](  ) - Normalizes this quaternion.<br />
			[method:IQuaternion|Quaternion premultiply](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IQuaternion|Quaternion random](  ) <br />
			[method:IQuaternion|Quaternion rotateTowards](  [param:IQuaternion|Quaternion q],  [param:number step] ) <br />
			[method:IQuaternion|Quaternion set](  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets values of this quaternion.<br />
			[method:IQuaternion|Quaternion setFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Sets this quaternion from rotation specified by axis and angle.<br />
			Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.<br />
			Axis have to be normalized, angle is in radians.<br />
			[method:IQuaternion|Quaternion setFromEuler](  [param:IEuler|Euler euler],  [param:boolean update]? ) - Sets this quaternion from rotation specified by Euler angles.<br />
			[method:IQuaternion|Quaternion setFromRotationMatrix](  [param:IMatrix4|Matrix4 m] ) - Sets this quaternion from rotation component of m. Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm.<br />
			[method:IQuaternion|Quaternion setFromUnitVectors](  [param:IVector3|Vector3 vFrom],  [param:IVector3|Vector3 vTo] ) <br />
			[method:IQuaternion|Quaternion slerp](  [param:IQuaternion|Quaternion qb],  [param:number t] ) <br />
			[method:IQuaternion|Quaternion slerpQuaternions](  [param:IQuaternion|Quaternion qa],  [param:IQuaternion|Quaternion qb],  [param:number t] ) <br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.<br />
			<br />
			Returns : The created or provided array.<br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:ArrayLike array],  [param:number offset]? ) - Copies x, y, z and w into the provided array-like.<br />
			<br />
			Returns : The provided array-like.
		</p>

		<p class="desc">
			Implementation of a quaternion. This is used for rotating things without incurring in the dreaded gimbal lock issue, amongst other advantages.
		</p>

		<hr class="interface-line"/>
		[page:IKeyframeTrack] &rarr;

		<h3 id="IQuaternionKeyframeTrack">IQuaternionKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IQuaternionKeyframeTrack IQuaternionKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:ILinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:ICubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:IQuaternionKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:IKeyframeTrack optimize](  ) <br />
			[method:IKeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:IKeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:IKeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:IKeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IInterpolant] &rarr;

		<h3 id="IQuaternionLinearInterpolant">IQuaternionLinearInterpolant <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IQuaternionLinearInterpolant IQuaternionLinearInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]? ) <br />
			[constructor:IQuaternionLinearInterpolant IQuaternionLinearInterpolant](  [param:any parameterPositions],  [param:any samplesValues],  [param:number sampleSize],  [param:any resultBuffer]?,  [param:any parameterPositions],  [param:any sampleValues],  [param:number sampleSize],  [param:any resultBuffer]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any parameterPositions] -  The parameter positions.<br />
			[property:any resultBuffer] -  The result buffer.<br />
			[property:any sampleValues] -  The sample values.<br />
			[property:number valueSize] -  The value size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:any evaluate](  [param:number time] ) <br />
			[method:any evaluate](  [param:number time],  [param:number time] ) <br />
			[method:any interpolate_](  [param:number i1],  [param:number t0],  [param:number t],  [param:number t1] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IRGBE">IRGBE <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Float32Array|Uint8Array data] -  The data.<br />
			[property:number exposure] -  The exposure.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:number gamma] -  The gamma.<br />
			[property:string header] -  The header.<br />
			[property:number height] -  The height.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number width] -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr; [page:IDataTextureLoader] &rarr;

		<h3 id="IRGBELoader">IRGBELoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRGBELoader IRGBELoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDataTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IRGBE parse](  [param:ArrayBuffer buffer] ) <br />
			[method:IRGBELoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IRGBELoader setDataType](  [param:TextureDataType type] ) <br />
			[method:IRGBELoader setPath](  [param:string path] ) <br />
			[method:IRGBELoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IRGBELoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IRGBELoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IRGBM">IRGBM <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:Uint8Array data] -  The data.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:string header] -  The header.<br />
			[property:number height] -  The height.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number width] -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr; [page:IDataTextureLoader] &rarr;

		<h3 id="IRGBMLoader">IRGBMLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRGBMLoader IRGBMLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDataTexture load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ICubeTexture loadCubemap](  [param:string[] urls],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:IRGBM parse](  [param:ArrayBuffer buffer] ) <br />
			[method:IRGBMLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IRGBMLoader setPath](  [param:string path] ) <br />
			[method:IRGBMLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IRGBMLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IRGBMLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr; [page:ITextureNode] &rarr;

		<h3 id="IRTTNode">IRTTNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRTTNode IRTTNode](  [param:number width],  [param:number height],  [param:ITextureNode input],  [param:IRTTNodeOptions options]? ) <br />
			[constructor:IRTTNode IRTTNode](  [param:number width],  [param:number height],  [param:ITextureNode input],  [param:IRTTNodeOptions options]?,  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]? ) <br />
			[constructor:IRTTNode IRTTNode](  [param:number width],  [param:number height],  [param:ITextureNode input],  [param:IRTTNodeOptions options]?,  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IRTTNode IRTTNode](  [param:number width],  [param:number height],  [param:ITextureNode input],  [param:IRTTNodeOptions options]?,  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IRTTNode IRTTNode](  [param:number width],  [param:number height],  [param:ITextureNode input],  [param:IRTTNodeOptions options]?,  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode bias] -  The bias.<br />
			[property:IOrthographicCamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:ITextureNode input] -  The input.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:object material] -  The material.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean project] -  The project.<br />
			[property:IMesh quad] -  The quad.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean render] -  The render.<br />
			[property:IWebGLRenderTarget renderTarget] -  The render target.<br />
			[property:IScene scene] -  The scene.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IUVNode|IUVTransformNode uv] -  The uv.<br />
			[property:ITexture value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:IRTTNode copy](  [param:IRTTNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getTexture](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IRTTNode setLabel](  [param:string name] ) <br />
			[method:IRTTNode setName](  [param:string name] ) <br />
			[method:IRTTNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:INodeFrame frame] ) <br />
			[method:void updateFramesaveTo](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IWebGLRenderTargetOptions] &rarr;

		<h3 id="IRTTNodeOptions">IRTTNodeOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy]? -  The anisotropy.<br />
			[property:boolean clear]? -  The clear.<br />
			[property:boolean depthBuffer]? -  The depth buffer.<br />
			[property:IDepthTexture depthTexture]? -  The depth texture.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:number format]? -  The format.<br />
			[property:boolean generateMipmaps]? -  The generate mipmaps.<br />
			[property:TextureFilter magFilter]? -  The mag filter.<br />
			[property:TextureFilter minFilter]? -  The min filter.<br />
			[property:boolean stencilBuffer]? -  The stencil buffer.<br />
			[property:TextureDataType type]? -  The type.<br />
			[property:Wrapping wrapS]? -  The wrap s.<br />
			[property:Wrapping wrapT]? -  The wrap t.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IRandomGenerator">IRandomGenerator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:number getSeed](  ) <br />
			[method:number random](  ) <br />
			[method:void setSeed](  [param:number seed] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr;

		<h3 id="IRawNode">IRawNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRawNode IRawNode](  [param:INode value] ) <br />
			[constructor:IRawNode IRawNode](  [param:INode value],  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:INode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:IRawNode copy](  [param:IRawNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:IRawNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr;

		<h3 id="IRawShaderMaterial">IRawShaderMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRawShaderMaterial IRawShaderMaterial](  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:IRawShaderMaterial IRawShaderMaterial](  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IRawShaderMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IRawShaderMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IRay">IRay <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRay IRay](  [param:IVector3|Vector3 origin]?,  [param:IVector3|Vector3 direction]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IVector3 direction] -  The direction.<br />
			[property:IVector3 origin] -  The origin.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IRay applyMatrix4](  [param:IMatrix4|Matrix4 matrix4] ) <br />
			[method:IVector3 at](  [param:number t],  [param:IVector3|Vector3 target] ) <br />
			[method:IRay clone](  ) <br />
			[method:IVector3 closestPointToPoint](  [param:IVector3|Vector3 point],  [param:IVector3|Vector3 target] ) <br />
			[method:IRay copy](  [param:IRay ray] ) <br />
			[method:number distanceSqToPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:number distanceSqToSegment](  [param:IVector3|Vector3 v0],  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 optionalPointOnRay]?,  [param:IVector3|Vector3 optionalPointOnSegment]? ) <br />
			[method:number distanceToPlane](  [param:IPlane plane] ) <br />
			[method:number distanceToPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:boolean equals](  [param:IRay ray] ) <br />
			[method:IVector3 intersectBox](  [param:IBox3 box],  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 intersectPlane](  [param:IPlane plane],  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 intersectSphere](  [param:ISphere sphere],  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 intersectTriangle](  [param:IVector3|Vector3 a],  [param:IVector3|Vector3 b],  [param:IVector3|Vector3 c],  [param:boolean backfaceCulling],  [param:IVector3|Vector3 target] ) <br />
			[method:boolean intersectsBox](  [param:IBox3 box] ) <br />
			[method:boolean intersectsPlane](  [param:IPlane plane] ) <br />
			[method:boolean intersectsSphere](  [param:ISphere sphere] ) <br />
			[method:any isIntersectionBox](  [param:any b] ) <br />
			[method:any isIntersectionPlane](  [param:any p] ) <br />
			[method:any isIntersectionSphere](  [param:any s] ) <br />
			[method:IRay lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IRay recast](  [param:number t] ) <br />
			[method:IRay set](  [param:IVector3|Vector3 origin],  [param:IVector3|Vector3 direction] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IRayParameters">IRayParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number birthTime]? -  The birth time.<br />
			[property:number deathTime]? -  The death time.<br />
			[property:IVector3 destOffset]? -  The dest offset.<br />
			[property:boolean generateUVs]? -  The generate u vs.<br />
			[property:boolean isEternal]? -  The is eternal.<br />
			[property:boolean isStatic]? -  The is static.<br />
			[property:number maxIterations]? -  The max iterations.<br />
			[property:number maxSubrayRecursion]? -  The max subray recursion.<br />
			[property:number minRadius]? -  The min radius.<br />
			[property:number noiseSeed]? -  The noise seed.<br />
			[property:number propagationTimeFactor]? -  The propagation time factor.<br />
			[property:number radius0]? -  The radius0.<br />
			[property:number radius0Factor]? -  The radius0 factor.<br />
			[property:number radius1]? -  The radius1.<br />
			[property:number radius1Factor]? -  The radius1 factor.<br />
			[property:number ramification]? -  The ramification.<br />
			[property:IRandomGenerator randomGenerator]? -  The random generator.<br />
			[property:number recursionProbability]? -  The recursion probability.<br />
			[property:number roughness]? -  The roughness.<br />
			[property:IVector3 sourceOffset]? -  The source offset.<br />
			[property:number straightness]? -  The straightness.<br />
			[property:number subrayDutyCycle]? -  The subray duty cycle.<br />
			[property:number subrayPeriod]? -  The subray period.<br />
			[property:number timeScale]? -  The time scale.<br />
			[property:IVector3 up0]? -  The up0.<br />
			[property:IVector3 up1]? -  The up1.<br />
			[property:number vanishingTimeFactor]? -  The vanishing time factor.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void onDecideSubrayCreation](  [param:ILightningSegment segment],  [param:ILightningStrike lightningStrike] ) <br />
			[method:void onSubrayCreation](  [param:ILightningSegment segment],  [param:ILightningSubray parentSubray],  [param:ILightningSubray childSubray],  [param:ILightningStrike lightningStrike] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IRaycaster">IRaycaster <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRaycaster IRaycaster](  [param:IVector3|Vector3 origin]?,  [param:IVector3|Vector3 direction]?,  [param:number near]?,  [param:number far]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ICamera camera] - The camera to use when raycasting against view-dependent objects such as billboarded objects like Sprites. This field<br />
			can be set manually or is set when calling "setFromCamera".<br />
			[property:number far] - The far factor of the raycaster. This value indicates which objects can be discarded based on the<br />
			distance. This value shouldn't be negative and should be larger than the near property.<br />
			[property:ILayers layers] - Used by Raycaster to selectively ignore 3D objects when performing intersection tests.<br />
			[property:number near] - The near factor of the raycaster. This value indicates which objects can be discarded based on the<br />
			distance. This value shouldn't be negative and should be smaller than the far property.<br />
			[property:RaycasterParameters params] -  The params.<br />
			[property:IRay ray] - The Ray used for the raycasting.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IIntersection[] intersectObject](  [param:IObject3D object],  [param:boolean recursive]?,  [param:IIntersection[] optionalTarget]? ) - Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first.<br />
			[method:IIntersection[] intersectObjects](  [param:IObject3D[] objects],  [param:boolean recursive]?,  [param:IIntersection[] optionalTarget]? ) - Checks all intersection between the ray and the objects with or without the descendants.<br />
			Intersections are returned sorted by distance, closest first.<br />
			Intersections are of the same form as those returned by .intersectObject.<br />
			[method:void set](  [param:IVector3|Vector3 origin],  [param:IVector3|Vector3 direction] ) - Updates the ray with a new origin and direction.<br />
			[method:void setFromCamera](  [param:any coords],  [param:ICamera camera] ) - Updates the ray with a new origin and direction.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILight] &rarr;

		<h3 id="IRectAreaLight">IRectAreaLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRectAreaLight IRectAreaLight](  [param:any color]?,  [param:number intensity]?,  [param:number width]?,  [param:number height]? ) <br />
			[constructor:IRectAreaLight IRectAreaLight](  [param:any color]?,  [param:number intensity]?,  [param:number width]?,  [param:number height]?,  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:IRectAreaLight IRectAreaLight](  [param:any color]?,  [param:number intensity]?,  [param:number width]?,  [param:number height]?,  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number height] -  The height.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] -  The intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isRectAreaLight] -  The is rect area light.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:number power] -  The power.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ILightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IRectAreaLight add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IRectAreaLight applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IRectAreaLight attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IRectAreaLight clear](  ) - Removes all child objects.<br />
			[method:IRectAreaLight clone](  [param:boolean recursive]? ) <br />
			[method:IRectAreaLight copy](  [param:IRectAreaLight source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IRectAreaLight remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IRectAreaLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IRectAreaLight rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IRectAreaLight rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IRectAreaLight rotateX](  [param:number angle] ) <br />
			[method:IRectAreaLight rotateY](  [param:number angle] ) <br />
			[method:IRectAreaLight rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IRectAreaLight translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IRectAreaLight translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IRectAreaLight translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IRectAreaLight translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr;

		<h3 id="IRectAreaLightHelper">IRectAreaLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRectAreaLightHelper IRectAreaLightHelper](  [param:IRectAreaLight light],  [param:any color]? ) <br />
			[constructor:IRectAreaLightHelper IRectAreaLightHelper](  [param:IRectAreaLight light],  [param:any color]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IRectAreaLightHelper IRectAreaLightHelper](  [param:IRectAreaLight light],  [param:any color]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:any color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IRectAreaLight light] -  The light.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IRectAreaLightHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IRectAreaLightHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IRectAreaLightHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IRectAreaLightHelper clear](  ) - Removes all child objects.<br />
			[method:IRectAreaLightHelper clone](  [param:boolean recursive]? ) <br />
			[method:IRectAreaLightHelper computeLineDistances](  ) <br />
			[method:IRectAreaLightHelper copy](  [param:IRectAreaLightHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IRectAreaLightHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IRectAreaLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IRectAreaLightHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IRectAreaLightHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IRectAreaLightHelper rotateX](  [param:number angle] ) <br />
			[method:IRectAreaLightHelper rotateY](  [param:number angle] ) <br />
			[method:IRectAreaLightHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IRectAreaLightHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IRectAreaLightHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IRectAreaLightHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IRectAreaLightHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IReflectNode">IReflectNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IReflectNode IReflectNode](  [param:string scope]? ) <br />
			[constructor:IReflectNode IReflectNode](  [param:string scope]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IReflectNode IReflectNode](  [param:string scope]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string CUBE] -  The c u b e.<br />
			[property:string SPHERE] -  The s p h e r e.<br />
			[property:string VECTOR] -  The v e c t o r.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IReflectNode copy](  [param:INode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IReflectNode setLabel](  [param:string name] ) <br />
			[method:IReflectNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IReflector">IReflector <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IReflector IReflector](  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]? ) <br />
			[constructor:IReflector IReflector](  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IReflector IReflector](  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IReflector add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IReflector applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IReflector attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IReflector clear](  ) - Removes all child objects.<br />
			[method:IReflector clone](  [param:boolean recursive]? ) <br />
			[method:IReflector copy](  [param:IReflector source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IWebGLRenderTarget getRenderTarget](  ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IReflector remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IReflector removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IReflector rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IReflector rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IReflector rotateX](  [param:number angle] ) <br />
			[method:IReflector rotateY](  [param:number angle] ) <br />
			[method:IReflector rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IReflector translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IReflector translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IReflector translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IReflector translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IReflectorForSSRPass">IReflectorForSSRPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IReflectorForSSRPass IReflectorForSSRPass](  [param:IBufferGeometry geometry],  [param:IReflectorOptions options] ) - Creates an instance of ngx reflector for ssrpass.<br />
			[constructor:IReflectorForSSRPass IReflectorForSSRPass](  [param:IBufferGeometry geometry],  [param:IReflectorOptions options] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			ReflectorForSSR pass<br />
			See the [page:NgxReflectorForSSRPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/ReflectorForSSRPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IReflectorNode">IReflectorNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IReflectorNode IReflectorNode](  [param:IReflectorRTT mirror]? ) <br />
			[constructor:IReflectorNode IReflectorNode](  [param:IReflectorRTT mirror]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IReflectorNode IReflectorNode](  [param:IReflectorRTT mirror]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:IPositionNode localPosition] -  The local position.<br />
			[property:IReflectorRTT mirror] -  The mirror.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:ITextureNode texture] -  The texture.<br />
			[property:IMatrix4Node textureMatrix] -  The texture matrix.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IOperatorNode uv] -  The uv.<br />
			[property:IOperatorNode uvResult] -  The uv result.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IReflectorNode copy](  [param:IReflectorNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IReflectorNode setLabel](  [param:string name] ) <br />
			[method:IReflectorNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IReflectorOptions">IReflectorOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number clipBias]? -  The clip bias.<br />
			[property:any color]? -  The color.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:object shader]? -  The shader.<br />
			[property:number textureHeight]? -  The texture height.<br />
			[property:number textureWidth]? -  The texture width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr; [page:IReflector] &rarr;

		<h3 id="IReflectorRTT">IReflectorRTT <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IReflectorRTT IReflectorRTT](  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]? ) <br />
			[constructor:IReflectorRTT IReflectorRTT](  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]?,  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]? ) <br />
			[constructor:IReflectorRTT IReflectorRTT](  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]?,  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IReflectorRTT IReflectorRTT](  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]?,  [param:IBufferGeometry geometry]?,  [param:IReflectorOptions options]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IReflectorRTT add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IReflectorRTT applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IReflectorRTT attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IReflectorRTT clear](  ) - Removes all child objects.<br />
			[method:IReflectorRTT clone](  [param:boolean recursive]? ) <br />
			[method:IReflectorRTT copy](  [param:IReflectorRTT source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IWebGLRenderTarget getRenderTarget](  ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IReflectorRTT remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IReflectorRTT removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IReflectorRTT rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IReflectorRTT rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IReflectorRTT rotateX](  [param:number angle] ) <br />
			[method:IReflectorRTT rotateY](  [param:number angle] ) <br />
			[method:IReflectorRTT rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IReflectorRTT translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IReflectorRTT translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IReflectorRTT translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IReflectorRTT translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IReflectorShader">IReflectorShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any defines] -  The defines.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			Reflector shader
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IRefractor">IRefractor <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRefractor IRefractor](  [param:IBufferGeometry geometry]?,  [param:IRefractorOptions options]? ) <br />
			[constructor:IRefractor IRefractor](  [param:IBufferGeometry geometry]?,  [param:IRefractorOptions options]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IRefractor IRefractor](  [param:IBufferGeometry geometry]?,  [param:IRefractorOptions options]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IRefractor add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IRefractor applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IRefractor attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IRefractor clear](  ) - Removes all child objects.<br />
			[method:IRefractor clone](  [param:boolean recursive]? ) <br />
			[method:IRefractor copy](  [param:IRefractor source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IWebGLRenderTarget getRenderTarget](  ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IRefractor remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IRefractor removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IRefractor rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IRefractor rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IRefractor rotateX](  [param:number angle] ) <br />
			[method:IRefractor rotateY](  [param:number angle] ) <br />
			[method:IRefractor rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IRefractor translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IRefractor translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IRefractor translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IRefractor translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IRefractorOptions">IRefractorOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number clipBias]? -  The clip bias.<br />
			[property:any color]? -  The color.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:object shader]? -  The shader.<br />
			[property:number textureHeight]? -  The texture height.<br />
			[property:number textureWidth]? -  The texture width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IRenderPass">IRenderPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRenderPass IRenderPass](  [param:IScene scene],  [param:ICamera camera],  [param:IMaterial overrideMaterial]?,  [param:IColor clearColor]?,  [param:number clearAlpha]? ) - Creates an instance of ngx render pass.<br />
			[constructor:IRenderPass IRenderPass](  [param:IScene scene],  [param:ICamera camera],  [param:IMaterial overrideMaterial]?,  [param:IColor clearColor]?,  [param:number clearAlpha]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ICamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:number clearAlpha] -  The clear alpha.<br />
			[property:IColor clearColor] -  The clear color.<br />
			[property:boolean clearDepth] -  The clear depth.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:IMaterial overrideMaterial] -  The override material.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IScene scene] -  The scene.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Render pass<br />
			See the [page:NgxRenderPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/RenderPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IRenderer">IRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:HTMLCanvasElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IObject3D scene],  [param:ICamera camera] ) <br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:boolean updateStyle]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr; [page:IVector2Node] &rarr;

		<h3 id="IResolutionNode">IResolutionNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IResolutionNode IResolutionNode](  ) <br />
			[constructor:IResolutionNode IResolutionNode](  [param:number|IVector2 x],  [param:number y]? ) <br />
			[constructor:IResolutionNode IResolutionNode](  [param:number|IVector2 x],  [param:number y]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IResolutionNode IResolutionNode](  [param:number|IVector2 x],  [param:number y]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IResolutionNode IResolutionNode](  [param:number|IVector2 x],  [param:number y]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:IVector2 size] -  The size.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IVector2 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IResolutionNode copy](  [param:IResolutionNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IResolutionNode setLabel](  [param:string name] ) <br />
			[method:IResolutionNode setName](  [param:string name] ) <br />
			[method:IResolutionNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IRhino3dmLoader">IRhino3dmLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRhino3dmLoader IRhino3dmLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IRhino3dmLoader dispose](  ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void parse](  [param:ArrayBufferLike data],  [param:any onLoad],  [param:any onError]? ) <br />
			[method:IRhino3dmLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IRhino3dmLoader setLibraryPath](  [param:string path] ) <br />
			[method:IRhino3dmLoader setPath](  [param:string path] ) <br />
			[method:IRhino3dmLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IRhino3dmLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IRhino3dmLoader setWithCredentials](  [param:boolean value] ) <br />
			[method:IRhino3dmLoader setWorkerLimit](  [param:number workerLimit] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IRingDepthGeometry">IRingDepthGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRingDepthGeometry IRingDepthGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number depth]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number depthRate]? ) <br />
			[constructor:IRingDepthGeometry IRingDepthGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number depth]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number depthRate]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] - The Parameters of ring depth geometry<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IRingDepthGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			The RingDepth geometry.<br />
			See the [page:NgxRingDepthGeometry ngx3js docs] page for details.<br />
			See the [example:ngx_geometry/RingDepthGeometry ngx geometey] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IRingGeometry">IRingGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRingGeometry IRingGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:IRingGeometry IRingGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number thetaSegments]?,  [param:number phiSegments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IRingGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IRollerCoasterGeometry">IRollerCoasterGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRollerCoasterGeometry IRollerCoasterGeometry](  [param:ICurve curve],  [param:number divisions] ) <br />
			[constructor:IRollerCoasterGeometry IRollerCoasterGeometry](  [param:ICurve curve],  [param:number divisions] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IRollerCoasterGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IRollerCoasterLiftersGeometry">IRollerCoasterLiftersGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRollerCoasterLiftersGeometry IRollerCoasterLiftersGeometry](  [param:ICurve curve],  [param:number divisions] ) <br />
			[constructor:IRollerCoasterLiftersGeometry IRollerCoasterLiftersGeometry](  [param:ICurve curve],  [param:number divisions] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IRollerCoasterLiftersGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IRollerCoasterShadowGeometry">IRollerCoasterShadowGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRollerCoasterShadowGeometry IRollerCoasterShadowGeometry](  [param:ICurve curve],  [param:number divisions] ) <br />
			[constructor:IRollerCoasterShadowGeometry IRollerCoasterShadowGeometry](  [param:ICurve curve],  [param:number divisions] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IRollerCoasterShadowGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IRollerCoasterSkyGeometry">IRollerCoasterSkyGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRollerCoasterSkyGeometry IRollerCoasterSkyGeometry](  [param:ICurve curve],  [param:number divisions] ) <br />
			[constructor:IRollerCoasterSkyGeometry IRollerCoasterSkyGeometry](  [param:ICurve curve],  [param:number divisions] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IRollerCoasterSkyGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IRollerCoasterTreesGeometry">IRollerCoasterTreesGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRollerCoasterTreesGeometry IRollerCoasterTreesGeometry](  [param:IMesh landscape] ) <br />
			[constructor:IRollerCoasterTreesGeometry IRollerCoasterTreesGeometry](  [param:IMesh landscape] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IRollerCoasterTreesGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IScene] &rarr;

		<h3 id="IRoomEnvironment">IRoomEnvironment <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRoomEnvironment IRoomEnvironment](  ) <br />
			[constructor:IRoomEnvironment IRoomEnvironment](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:ITexture|IColor background] -  The background.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:ITexture environment] -  The environment.<br />
			[property:IFogBase fog] - A fog instance defining the type of fog that affects everything rendered in the scene. Default is null.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isScene] -  The is scene.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IMaterial overrideMaterial] - If not null, it will force everything in the scene to be rendered with that material. Default is null.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IRoomEnvironment add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IRoomEnvironment applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IRoomEnvironment attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IRoomEnvironment clear](  ) - Removes all child objects.<br />
			[method:IRoomEnvironment clone](  [param:boolean recursive]? ) <br />
			[method:IRoomEnvironment copy](  [param:IRoomEnvironment source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera] ) - Calls after rendering scene<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:any renderTarget] ) - Calls before rendering scene<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IRoomEnvironment remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IRoomEnvironment removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IRoomEnvironment rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IRoomEnvironment rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IRoomEnvironment rotateX](  [param:number angle] ) <br />
			[method:IRoomEnvironment rotateY](  [param:number angle] ) <br />
			[method:IRoomEnvironment rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IRoomEnvironment translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IRoomEnvironment translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IRoomEnvironment translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IRoomEnvironment translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IRopeGeometry">IRopeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRopeGeometry IRopeGeometry](  [param:number width]?,  [param:number widthSegments]? ) <br />
			[constructor:IRopeGeometry IRopeGeometry](  [param:number width]?,  [param:number widthSegments]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] - The Parameters of rope geometry<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IRopeGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			The Rope geometry.<br />
			See the [page:NgxRopeGeometry ngx3js docs] page for details.<br />
			See the [example:ngx_geometry/RopeGeometry ngx geometey] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IBoxGeometry] &rarr;

		<h3 id="IRoundedBoxGeometry">IRoundedBoxGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IRoundedBoxGeometry IRoundedBoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number segments]?,  [param:number radius]? ) <br />
			[constructor:IRoundedBoxGeometry IRoundedBoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number segments]?,  [param:number radius]?,  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) <br />
			[constructor:IRoundedBoxGeometry IRoundedBoxGeometry](  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number segments]?,  [param:number radius]?,  [param:number width]?,  [param:number height]?,  [param:number depth]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number depthSegments]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IRoundedBoxGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ISAOPass">ISAOPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISAOPass ISAOPass](  [param:IScene scene],  [param:ICamera camera],  [param:boolean depthTexture]?,  [param:boolean useNormals]?,  [param:IVector2 resolution]? ) <br />
			[constructor:ISAOPass ISAOPass](  [param:IScene scene],  [param:ICamera camera],  [param:boolean depthTexture]?,  [param:boolean useNormals]?,  [param:IVector2 resolution]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IWebGLRenderTarget beautyRenderTarget] -  The beauty render target.<br />
			[property:IWebGLRenderTarget blurIntermediateRenderTarget] -  The blur intermediate render target.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:IShaderMaterial depthCopy] -  The depth copy.<br />
			[property:IMeshDepthMaterial depthMaterial] -  The depth material.<br />
			[property:IWebGLRenderTarget depthRenderTarget] -  The depth render target.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial hBlurMaterial] -  The h blur material.<br />
			[property:IShaderMaterial materialCopy] -  The material copy.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:IMeshNormalMaterial normalMaterial] -  The normal material.<br />
			[property:IWebGLRenderTarget normalRenderTarget] -  The normal render target.<br />
			[property:number oldClearAlpha] -  The old clear alpha.<br />
			[property:IColor oldClearColor] -  The old clear color.<br />
			[property:IColor originalClearColor] -  The original clear color.<br />
			[property:ISAOPassParams params] -  The params.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IVector2 resolution] -  The resolution.<br />
			[property:IShaderMaterial saoMaterial] -  The sao material.<br />
			[property:IWebGLRenderTarget saoRenderTarget] -  The sao render target.<br />
			[property:IScene scene] -  The scene.<br />
			[property:boolean supportsDepthTextureExtension] -  The supports depth texture extension.<br />
			[property:boolean supportsNormalTexture] -  The supports normal texture.<br />
			[property:IShaderMaterial vBlurMaterial] -  The v blur material.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void renderOverride](  [param:IWebGLRenderer renderer],  [param:IMaterial overrideMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor]?,  [param:number clearAlpha]? ) <br />
			[method:void renderPass](  [param:IWebGLRenderer renderer],  [param:IMaterial passMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor]?,  [param:number clearAlpha]? ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			SAO pass<br />
			See the [page:NgxSAOPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/SAOPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="ISAOPassParams">ISAOPassParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ESAO_OUTPUT output] -  The output.<br />
			[property:number saoBias] -  The sao bias.<br />
			[property:boolean saoBlur] -  The sao blur.<br />
			[property:number saoBlurDepthCutoff] -  The sao blur depth cutoff.<br />
			[property:number saoBlurRadius] -  The sao blur radius.<br />
			[property:number saoBlurStdDev] -  The sao blur std dev.<br />
			[property:number saoIntensity] -  The sao intensity.<br />
			[property:number saoKernelRadius] -  The sao kernel radius.<br />
			[property:number saoMinResolution] -  The sao min resolution.<br />
			[property:number saoScale] -  The sao scale.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ISMAAPass">ISMAAPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISMAAPass ISMAAPass](  [param:number width],  [param:number height] ) - Creates an instance of ngx smaapass.<br />
			[constructor:ISMAAPass ISMAAPass](  [param:number width],  [param:number height] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture areaTexture] -  The area texture.<br />
			[property:boolean clear] -  The clear.<br />
			[property:IWebGLRenderTarget edgesRT] -  The edges r t.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial materialBlend] -  The material blend.<br />
			[property:IShaderMaterial materialEdges] -  The material edges.<br />
			[property:IShaderMaterial materialWeights] -  The material weights.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:ITexture searchTexture] -  The search texture.<br />
			[property:object uniformsBlend] -  The uniforms blend.<br />
			[property:object uniformsEdges] -  The uniforms edges.<br />
			[property:object uniformsWeights] -  The uniforms weights.<br />
			[property:IWebGLRenderTarget weightsRT] -  The weights r t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:string getAreaTexture](  ) <br />
			[method:string getSearchTexture](  ) <br />
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			SMAA pass<br />
			See the [page:NgxSMAAPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/SMAAPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ISSAARenderPass">ISSAARenderPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISSAARenderPass ISSAARenderPass](  [param:IScene scene],  [param:ICamera camera],  [param:any clearColor],  [param:number clearAlpha] ) - Creates an instance of ngx ssaarender pass.<br />
			[constructor:ISSAARenderPass ISSAARenderPass](  [param:IScene scene],  [param:ICamera camera],  [param:any clearColor],  [param:number clearAlpha] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ICamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:number clearAlpha] -  The clear alpha.<br />
			[property:any clearColor] -  The clear color.<br />
			[property:IShaderMaterial copyMaterial] -  The copy material.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:number sampleLevel] -  The sample level.<br />
			[property:IWebGLRenderTarget sampleRenderTarget] -  The sample render target.<br />
			[property:IScene scene] -  The scene.<br />
			[property:boolean unbiased] -  The unbiased.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			SSAARender pass<br />
			See the [page:NgxSSAARenderPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/SSAARenderPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ISSAOPass">ISSAOPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISSAOPass ISSAOPass](  [param:IScene scene],  [param:ICamera camera],  [param:number width]?,  [param:number height]? ) - Creates an instance of ngx ssaopass.<br />
			[constructor:ISSAOPass ISSAOPass](  [param:IScene scene],  [param:ICamera camera],  [param:number width]?,  [param:number height]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IWebGLRenderTarget beautyRenderTarget] -  The beauty render target.<br />
			[property:IShaderMaterial blurMaterial] -  The blur material.<br />
			[property:IWebGLRenderTarget blurRenderTarget] -  The blur render target.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:IShaderMaterial copyMaterial] -  The copy material.<br />
			[property:IShaderMaterial depthRenderMaterial] -  The depth render material.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:boolean height] -  The height.<br />
			[property:IVector3[] kernel] -  The kernel.<br />
			[property:number kernelRadius] -  The kernel radius.<br />
			[property:number kernelSize] -  The kernel size.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:IDataTexture noiseTexture] -  The noise texture.<br />
			[property:IMeshNormalMaterial normalMaterial] -  The normal material.<br />
			[property:IWebGLRenderTarget normalRenderTarget] -  The normal render target.<br />
			[property:IColor originalClearColor] -  The original clear color.<br />
			[property:any output] -  The output.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IScene scene] -  The scene.<br />
			[property:IShaderMaterial ssaoMaterial] -  The ssao material.<br />
			[property:IWebGLRenderTarget ssaoRenderTarget] -  The ssao render target.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dipose](  ) <br />
			[method:void generateRandomKernelRotations](  ) <br />
			[method:IVector3[] generateSampleKernel](  ) <br />
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void renderOverride](  [param:IWebGLRenderer renderer],  [param:IMaterial overrideMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor]?,  [param:number clearAlpha]? ) <br />
			[method:void renderPass](  [param:IWebGLRenderer renderer],  [param:IMaterial passMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor]?,  [param:number clearAlpha]? ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			SSAO pass<br />
			See the [page:NgxSSAOPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/SSAOPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ISSRPass">ISSRPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISSRPass ISSRPass](  [param:ISSRPassParams params] ) - Creates an instance of ngx ssrpass.<br />
			[constructor:ISSRPass ISSRPass](  [param:ISSRPassParams params] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IWebGLRenderTarget beautyRenderTarget] -  The beauty render target.<br />
			[property:boolean blur] -  The blur.<br />
			[property:IShaderMaterial blurMaterial] -  The blur material.<br />
			[property:IShaderMaterial blurMaterial2] -  The blur material2.<br />
			[property:IWebGLRenderTarget blurRenderTarget] -  The blur render target.<br />
			[property:IWebGLRenderTarget blurRenderTarget2] -  The blur render target2.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:IShaderMaterial copyMaterial] -  The copy material.<br />
			[property:IShaderMaterial depthRenderMaterial] -  The depth render material.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:IFullScreenQuad fsQuad] -  The fs quad.<br />
			[property:any groundReflector] -  The ground reflector.<br />
			[property:number height] -  The height.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:IMeshBasicMaterial metalnessOffMaterial] -  The metalness off material.<br />
			[property:IMeshBasicMaterial metalnessOnMaterial] -  The metalness on material.<br />
			[property:IWebGLRenderTarget metalnessRenderTarget] -  The metalness render target.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:IMeshNormalMaterial normalMaterial] -  The normal material.<br />
			[property:IWebGLRenderTarget normalRenderTarget] -  The normal render target.<br />
			[property:number opacity] -  The opacity.<br />
			[property:IColor originalClearColor] -  The original clear color.<br />
			[property:number output] -  The output.<br />
			[property:IWebGLRenderTarget prevRenderTarget] -  The prev render target.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IWebGLRenderer renderer] -  The renderer.<br />
			[property:IScene scene] -  The scene.<br />
			[property:boolean selective] -  The selective.<br />
			[property:IShaderMaterial ssrMaterial] -  The ssr material.<br />
			[property:IWebGLRenderTarget ssrRenderTarget] -  The ssr render target.<br />
			[property:IColor tempColor] -  The temp color.<br />
			[property:number thickTolerance] -  The thick tolerance.<br />
			[property:number thickness] -  The thickness.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void renderMetalness](  [param:IWebGLRenderer renderer],  [param:IMaterial passMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor],  [param:any clearAlpha] ) <br />
			[method:void renderOverride](  [param:IWebGLRenderer renderer],  [param:IMaterial passMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor],  [param:any clearAlpha] ) <br />
			[method:void renderPass](  [param:IWebGLRenderer renderer],  [param:IMaterial passMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor],  [param:any clearAlpha] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			SSR pass<br />
			See the [page:NgxSSRPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/SSRPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="ISSRPassParams">ISSRPassParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ICamera camera] -  The camera.<br />
			[property:any groundReflector] -  The ground reflector.<br />
			[property:number height]? -  The height.<br />
			[property:boolean isBouncing]? -  The is bouncing.<br />
			[property:boolean isPerspectiveCamera]? -  The is perspective camera.<br />
			[property:IWebGLRenderer renderer] -  The renderer.<br />
			[property:IScene scene] -  The scene.<br />
			[property:IMesh[] selects] -  The selects.<br />
			[property:number width]? -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ISSRrPass">ISSRrPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISSRrPass ISSRrPass](  [param:ISSRrPassParams params] ) - Creates an instance of ngx ssrr pass.<br />
			[constructor:ISSRrPass ISSRrPass](  [param:ISSRrPassParams params] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean _fillHole] -  The _fill hole.<br />
			[property:boolean _infiniteThick] -  The _infinite thick.<br />
			[property:boolean _specular] -  The _specular.<br />
			[property:IWebGLRenderTarget beautyRenderTarget] -  The beauty render target.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:IColor color] -  The color.<br />
			[property:IShaderMaterial copyMaterial] -  The copy material.<br />
			[property:IShaderMaterial depthRenderMaterial] -  The depth render material.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:IFullScreenQuad fsQuad] -  The fs quad.<br />
			[property:number height] -  The height.<br />
			[property:number ior] -  The ior.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:IMeshNormalMaterial normalMaterial] -  The normal material.<br />
			[property:IWebGLRenderTarget normalSelectsRenderTarget] -  The normal selects render target.<br />
			[property:IColor originalClearColor] -  The original clear color.<br />
			[property:number output] -  The output.<br />
			[property:IMeshBasicMaterial refractiveOffMaterial] -  The refractive off material.<br />
			[property:IMeshBasicMaterial refractiveOnMaterial] -  The refractive on material.<br />
			[property:IWebGLRenderTarget refractiveRenderTarget] -  The refractive render target.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IWebGLRenderer renderer] -  The renderer.<br />
			[property:IScene scene] -  The scene.<br />
			[property:IMesh[] seleects] -  The seleects.<br />
			[property:IMeshStandardMaterial specularMaterial] -  The specular material.<br />
			[property:IWebGLRenderTarget specularRenderTarget] -  The specular render target.<br />
			[property:IShaderMaterial ssrrMaterial] -  The ssrr material.<br />
			[property:IWebGLRenderTarget ssrrRenderTarget] -  The ssrr render target.<br />
			[property:number surfDist] -  The surf dist.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer] ) <br />
			[method:void renderOverride](  [param:IWebGLRenderer renderer],  [param:IMaterial passMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor],  [param:any clearAlpha] ) <br />
			[method:void renderPass](  [param:IWebGLRenderer renderer],  [param:IMaterial passMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor],  [param:any clearAlpha] ) <br />
			[method:void renderRefractive](  [param:IWebGLRenderer renderer],  [param:IMaterial passMaterial],  [param:IWebGLRenderTarget renderTarget],  [param:any clearColor],  [param:any clearAlpha] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			SSRr pass<br />
			See the [page:NgxSSRrPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/SSRrPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="ISSRrPassParams">ISSRrPassParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ICamera camera] -  The camera.<br />
			[property:number height]? -  The height.<br />
			[property:IWebGLRenderer renderer] -  The renderer.<br />
			[property:IScene scene] -  The scene.<br />
			[property:IMesh[] selects] -  The selects.<br />
			[property:number width]? -  The width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISTLExporter">ISTLExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISTLExporter ISTLExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:string parse](  [param:IObject3D scene],  [param:ISTLExporterOptions options]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISTLExporterOptions">ISTLExporterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean binary]? -  The binary.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ISTLLoader">ISTLLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISTLLoader ISTLLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IBufferGeometry parse](  [param:string|ArrayBuffer data] ) <br />
			[method:ISTLLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ISTLLoader setPath](  [param:string path] ) <br />
			[method:ISTLLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ISTLLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ISTLLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ISVGLoader">ISVGLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISVGLoader ISVGLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:number defaultDPI] -  The default d p i.<br />
			[property:string defaultUnit] -  The default unit.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IShape[] createShapes](  [param:IShapePath shapePath] ) <br />
			[method:IStrokeStyle getStrokeStyle](  [param:number width]?,  [param:string color]?,  [param:string lineJoin]?,  [param:string lineCap]?,  [param:number miterLimit]? ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ISVGResult parse](  [param:string text] ) <br />
			[method:IBufferGeometry pointsToStroke](  [param:IVector3[] points],  [param:IStrokeStyle style],  [param:number arcDivisions]?,  [param:number minDistance]? ) <br />
			[method:number pointsToStrokeWithBuffers](  [param:IVector3[] points],  [param:IStrokeStyle style],  [param:number arcDivisions]?,  [param:number minDistance]?,  [param:number[] vertices]?,  [param:number[] normals]?,  [param:number[] uvs]?,  [param:number vertexOffset]? ) <br />
			[method:ISVGLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ISVGLoader setPath](  [param:string path] ) <br />
			[method:ISVGLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ISVGLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ISVGLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ISVGObject">ISVGObject <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISVGObject ISVGObject](  [param:SVGElement node] ) <br />
			[constructor:ISVGObject ISVGObject](  [param:SVGElement node] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:SVGElement node] -  The node.<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISVGObject add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ISVGObject applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ISVGObject attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ISVGObject clear](  ) - Removes all child objects.<br />
			[method:ISVGObject clone](  [param:boolean recursive]? ) <br />
			[method:ISVGObject copy](  [param:ISVGObject source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ISVGObject remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ISVGObject removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ISVGObject rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ISVGObject rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ISVGObject rotateX](  [param:number angle] ) <br />
			[method:ISVGObject rotateY](  [param:number angle] ) <br />
			[method:ISVGObject rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ISVGObject translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ISVGObject translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ISVGObject translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ISVGObject translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISVGRenderer">ISVGRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISVGRenderer ISVGRenderer](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoClear] -  The auto clear.<br />
			[property:SVGElement domElement] -  The dom element.<br />
			[property:any info] -  The info.<br />
			[property:number overdraw] -  The overdraw.<br />
			[property:boolean sortElements] -  The sort elements.<br />
			[property:boolean sortObjects] -  The sort objects.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void clear](  ) <br />
			[method:void getSize](  ) <br />
			[method:void render](  [param:IScene scene],  [param:ICamera camera] ) <br />
			[method:void setClearColor](  [param:IColor color],  [param:number alpha] ) <br />
			[method:void setPixelRatio](  ) <br />
			[method:void setPrecision](  [param:number precision] ) <br />
			[method:void setQuality](  [param:string quality] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISVGResult">ISVGResult <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ISVGResultPaths[] paths] -  The paths.<br />
			[property:XMLDocument xml] -  The xml.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IShapePath] &rarr;

		<h3 id="ISVGResultPaths">ISVGResultPaths <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISVGResultPaths ISVGResultPaths](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IColor color] -  The color.<br />
			[property:any currentPath] -  The current path.<br />
			[property:any[] subPaths] -  The sub paths.<br />
			[property:string type] -  The type.<br />
			[property:any userData]? -  The user data.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISVGResultPaths bezierCurveTo](  [param:number aCP1x],  [param:number aCP1y],  [param:number aCP2x],  [param:number aCP2y],  [param:number aX],  [param:number aY] ) <br />
			[method:ISVGResultPaths lineTo](  [param:number x],  [param:number y] ) <br />
			[method:ISVGResultPaths moveTo](  [param:number x],  [param:number y] ) <br />
			[method:ISVGResultPaths quadraticCurveTo](  [param:number aCPx],  [param:number aCPy],  [param:number aX],  [param:number aY] ) <br />
			[method:ISVGResultPaths splineThru](  [param:any pts] ) <br />
			[method:IShape[] toShapes](  [param:boolean isCCW],  [param:boolean noHoles]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ISavePass">ISavePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISavePass ISavePass](  [param:IWebGLRenderTarget renderTarget] ) - Creates an instance of ngx save pass.<br />
			[constructor:ISavePass ISavePass](  [param:IWebGLRenderTarget renderTarget] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:IWebGLRenderTarget renderTarget] -  The render target.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Save pass<br />
			See the [page:NgxSavePass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/SavePass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="IScene">IScene <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IScene IScene](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:ITexture|IColor background] -  The background.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:ITexture environment] -  The environment.<br />
			[property:IFogBase fog] - A fog instance defining the type of fog that affects everything rendered in the scene. Default is null.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isScene] -  The is scene.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IMaterial overrideMaterial] - If not null, it will force everything in the scene to be rendered with that material. Default is null.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IScene add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IScene applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IScene attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IScene clear](  ) - Removes all child objects.<br />
			[method:IScene clone](  [param:boolean recursive]? ) <br />
			[method:IScene copy](  [param:IScene source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera] ) - Calls after rendering scene<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:any renderTarget] ) - Calls before rendering scene<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IScene remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IScene removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IScene rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IScene rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IScene rotateX](  [param:number angle] ) <br />
			[method:IScene rotateY](  [param:number angle] ) <br />
			[method:IScene rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IScene translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IScene translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IScene translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IScene translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.
		</p>

		<hr class="interface-line"/>
		<h3 id="ISceneUtils">ISceneUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void attach](  [param:IObject3D child],  [param:IScene scene],  [param:IObject3D parent] ) <br />
			[method:IGroup createMeshesFromInstancedMesh](  [param:IInstancedMesh instancedMesh] ) <br />
			[method:IGroup createMultiMaterialObject](  [param:IBufferGeometry geometry],  [param:IMaterial[] materials] ) <br />
			[method:void detach](  [param:IObject3D child],  [param:IObject3D parent],  [param:IScene scene] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr; [page:ITextureNode] &rarr;

		<h3 id="IScreenNode">IScreenNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IScreenNode IScreenNode](  [param:IUVNode uv]? ) <br />
			[constructor:IScreenNode IScreenNode](  [param:IUVNode uv]?,  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]? ) <br />
			[constructor:IScreenNode IScreenNode](  [param:IUVNode uv]?,  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IScreenNode IScreenNode](  [param:IUVNode uv]?,  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IScreenNode IScreenNode](  [param:IUVNode uv]?,  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode bias] -  The bias.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean project] -  The project.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IUVNode|IUVTransformNode uv] -  The uv.<br />
			[property:ITexture value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IScreenNode copy](  [param:ITextureNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getTexture](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IScreenNode setLabel](  [param:string name] ) <br />
			[method:IScreenNode setName](  [param:string name] ) <br />
			[method:IScreenNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IScreenUVNode">IScreenUVNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IScreenUVNode IScreenUVNode](  [param:IResolutionNode resolution]? ) <br />
			[constructor:IScreenUVNode IScreenUVNode](  [param:IResolutionNode resolution]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IScreenUVNode IScreenUVNode](  [param:IResolutionNode resolution]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:IResolutionNode resolution] -  The resolution.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IScreenUVNode copy](  [param:IScreenUVNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IScreenUVNode setLabel](  [param:string name] ) <br />
			[method:IScreenUVNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IShader">IShader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:string vertexShader] -  The vertex shader.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderBleachBypassPass">IShaderBleachBypassPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderBleachBypassPass IShaderBleachBypassPass](  [param:string textureId]? ) - Creates an instance of ngx BleachBypass pass.<br />
			[constructor:IShaderBleachBypassPass IShaderBleachBypassPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderBleachBypassPass IShaderBleachBypassPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			BleachBypass pass<br />
			See the [page:NgxShaderBleachBypassPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/BleachBypassPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IShaderChunk">IShaderChunk <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string alphamap_fragment] -  The alphamap_fragment.<br />
			[property:string alphamap_pars_fragment] -  The alphamap_pars_fragment.<br />
			[property:string alphatest_fragment] -  The alphatest_fragment.<br />
			[property:string aomap_fragment] -  The aomap_fragment.<br />
			[property:string aomap_pars_fragment] -  The aomap_pars_fragment.<br />
			[property:string begin_vertex] -  The begin_vertex.<br />
			[property:string beginnormal_vertex] -  The beginnormal_vertex.<br />
			[property:string bsdfs] -  The bsdfs.<br />
			[property:string bumpmap_pars_fragment] -  The bumpmap_pars_fragment.<br />
			[property:string clearcoat_normal_fragment_begin] -  The clearcoat_normal_fragment_begin.<br />
			[property:string clearcoat_normal_fragment_maps] -  The clearcoat_normal_fragment_maps.<br />
			[property:string clearcoat_pars_fragment] -  The clearcoat_pars_fragment.<br />
			[property:string clipping_planes_fragment] -  The clipping_planes_fragment.<br />
			[property:string clipping_planes_pars_fragment] -  The clipping_planes_pars_fragment.<br />
			[property:string clipping_planes_pars_vertex] -  The clipping_planes_pars_vertex.<br />
			[property:string clipping_planes_vertex] -  The clipping_planes_vertex.<br />
			[property:string color_fragment] -  The color_fragment.<br />
			[property:string color_pars_fragment] -  The color_pars_fragment.<br />
			[property:string color_pars_vertex] -  The color_pars_vertex.<br />
			[property:string color_vertex] -  The color_vertex.<br />
			[property:string common] -  The common.<br />
			[property:string cube_frag] -  The cube_frag.<br />
			[property:string cube_uv_reflection_fragment] -  The cube_uv_reflection_fragment.<br />
			[property:string cube_vert] -  The cube_vert.<br />
			[property:string defaultnormal_vertex] -  The defaultnormal_vertex.<br />
			[property:string depth_frag] -  The depth_frag.<br />
			[property:string depth_vert] -  The depth_vert.<br />
			[property:string displacementmap_pars_vertex] -  The displacementmap_pars_vertex.<br />
			[property:string displacementmap_vertex] -  The displacementmap_vertex.<br />
			[property:string distanceRGBA_frag] -  The distance r g b a_frag.<br />
			[property:string distanceRGBA_vert] -  The distance r g b a_vert.<br />
			[property:string emissivemap_fragment] -  The emissivemap_fragment.<br />
			[property:string emissivemap_pars_fragment] -  The emissivemap_pars_fragment.<br />
			[property:string encodings_fragment] -  The encodings_fragment.<br />
			[property:string encodings_pars_fragment] -  The encodings_pars_fragment.<br />
			[property:string envmap_common_pars_fragment] -  The envmap_common_pars_fragment.<br />
			[property:string envmap_fragment] -  The envmap_fragment.<br />
			[property:string envmap_pars_fragment] -  The envmap_pars_fragment.<br />
			[property:string envmap_pars_vertex] -  The envmap_pars_vertex.<br />
			[property:string envmap_physical_pars_fragment] -  The envmap_physical_pars_fragment.<br />
			[property:string envmap_vertex] -  The envmap_vertex.<br />
			[property:string equirect_frag] -  The equirect_frag.<br />
			[property:string equirect_vert] -  The equirect_vert.<br />
			[property:string fog_fragment] -  The fog_fragment.<br />
			[property:string fog_pars_fragment] -  The fog_pars_fragment.<br />
			[property:string lightmap_fragment] -  The lightmap_fragment.<br />
			[property:string lightmap_pars_fragment] -  The lightmap_pars_fragment.<br />
			[property:string lights_fragment_begin] -  The lights_fragment_begin.<br />
			[property:string lights_fragment_end] -  The lights_fragment_end.<br />
			[property:string lights_fragment_maps] -  The lights_fragment_maps.<br />
			[property:string lights_lambert_vertex] -  The lights_lambert_vertex.<br />
			[property:string lights_pars_begin] -  The lights_pars_begin.<br />
			[property:string lights_pars_map] -  The lights_pars_map.<br />
			[property:string lights_phong_fragment] -  The lights_phong_fragment.<br />
			[property:string lights_phong_pars_fragment] -  The lights_phong_pars_fragment.<br />
			[property:string lights_physical_fragment] -  The lights_physical_fragment.<br />
			[property:string lights_physical_pars_fragment] -  The lights_physical_pars_fragment.<br />
			[property:string linedashed_frag] -  The linedashed_frag.<br />
			[property:string linedashed_vert] -  The linedashed_vert.<br />
			[property:string logdepthbuf_fragment] -  The logdepthbuf_fragment.<br />
			[property:string logdepthbuf_pars_fragment] -  The logdepthbuf_pars_fragment.<br />
			[property:string logdepthbuf_pars_vertex] -  The logdepthbuf_pars_vertex.<br />
			[property:string logdepthbuf_vertex] -  The logdepthbuf_vertex.<br />
			[property:string map_fragment] -  The map_fragment.<br />
			[property:string map_pars_fragment] -  The map_pars_fragment.<br />
			[property:string map_particle_fragment] -  The map_particle_fragment.<br />
			[property:string map_particle_pars_fragment] -  The map_particle_pars_fragment.<br />
			[property:string meshbasic_frag] -  The meshbasic_frag.<br />
			[property:string meshbasic_vert] -  The meshbasic_vert.<br />
			[property:string meshlambert_frag] -  The meshlambert_frag.<br />
			[property:string meshlambert_vert] -  The meshlambert_vert.<br />
			[property:string meshphong_frag] -  The meshphong_frag.<br />
			[property:string meshphong_vert] -  The meshphong_vert.<br />
			[property:string meshphysical_frag] -  The meshphysical_frag.<br />
			[property:string meshphysical_vert] -  The meshphysical_vert.<br />
			[property:string metalnessmap_fragment] -  The metalnessmap_fragment.<br />
			[property:string metalnessmap_pars_fragment] -  The metalnessmap_pars_fragment.<br />
			[property:string morphnormal_vertex] -  The morphnormal_vertex.<br />
			[property:string morphtarget_pars_vertex] -  The morphtarget_pars_vertex.<br />
			[property:string morphtarget_vertex] -  The morphtarget_vertex.<br />
			[property:string normal_flip] -  The normal_flip.<br />
			[property:string normal_frag] -  The normal_frag.<br />
			[property:string normal_fragment_begin] -  The normal_fragment_begin.<br />
			[property:string normal_fragment_maps] -  The normal_fragment_maps.<br />
			[property:string normal_vert] -  The normal_vert.<br />
			[property:string normalmap_pars_fragment] -  The normalmap_pars_fragment.<br />
			[property:string packing] -  The packing.<br />
			[property:string points_frag] -  The points_frag.<br />
			[property:string points_vert] -  The points_vert.<br />
			[property:string premultiplied_alpha_fragment] -  The premultiplied_alpha_fragment.<br />
			[property:string project_vertex] -  The project_vertex.<br />
			[property:string roughnessmap_fragment] -  The roughnessmap_fragment.<br />
			[property:string roughnessmap_pars_fragment] -  The roughnessmap_pars_fragment.<br />
			[property:string shadow_frag] -  The shadow_frag.<br />
			[property:string shadow_vert] -  The shadow_vert.<br />
			[property:string shadowmap_pars_fragment] -  The shadowmap_pars_fragment.<br />
			[property:string shadowmap_pars_vertex] -  The shadowmap_pars_vertex.<br />
			[property:string shadowmap_vertex] -  The shadowmap_vertex.<br />
			[property:string shadowmask_pars_fragment] -  The shadowmask_pars_fragment.<br />
			[property:string skinbase_vertex] -  The skinbase_vertex.<br />
			[property:string skinning_pars_vertex] -  The skinning_pars_vertex.<br />
			[property:string skinning_vertex] -  The skinning_vertex.<br />
			[property:string skinnormal_vertex] -  The skinnormal_vertex.<br />
			[property:string specularmap_fragment] -  The specularmap_fragment.<br />
			[property:string specularmap_pars_fragment] -  The specularmap_pars_fragment.<br />
			[property:string tonemapping_fragment] -  The tonemapping_fragment.<br />
			[property:string tonemapping_pars_fragment] -  The tonemapping_pars_fragment.<br />
			[property:string uv2_pars_fragment] -  The uv2_pars_fragment.<br />
			[property:string uv2_pars_vertex] -  The uv2_pars_vertex.<br />
			[property:string uv2_vertex] -  The uv2_vertex.<br />
			[property:string uv_pars_fragment] -  The uv_pars_fragment.<br />
			[property:string uv_pars_vertex] -  The uv_pars_vertex.<br />
			[property:string uv_vertex] -  The uv_vertex.<br />
			[property:string worldpos_vertex] -  The worldpos_vertex.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderCopyPass">IShaderCopyPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderCopyPass IShaderCopyPass](  [param:string textureId]? ) - Creates an instance of ngx copy pass.<br />
			[constructor:IShaderCopyPass IShaderCopyPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderCopyPass IShaderCopyPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Copy pass<br />
			See the [page:NgxShaderCopyPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/CopyPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderDotScreenPass">IShaderDotScreenPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderDotScreenPass IShaderDotScreenPass](  [param:string textureId]? ) - Creates an instance of ngx Luminosity pass.<br />
			[constructor:IShaderDotScreenPass IShaderDotScreenPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderDotScreenPass IShaderDotScreenPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			DotScreen pass<br />
			See the [page:NgxShaderDotScreenPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/DotScreenPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderFXAAPass">IShaderFXAAPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderFXAAPass IShaderFXAAPass](  [param:string textureId]? ) - Creates an instance of ngx FXAA pass.<br />
			[constructor:IShaderFXAAPass IShaderFXAAPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderFXAAPass IShaderFXAAPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			FXAA pass<br />
			See the [page:NgxShaderFXAAPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/FXAAPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderGammaCorrectionPass">IShaderGammaCorrectionPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderGammaCorrectionPass IShaderGammaCorrectionPass](  [param:string textureId]? ) - Creates an instance of ngx GammaCorrection pass.<br />
			[constructor:IShaderGammaCorrectionPass IShaderGammaCorrectionPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderGammaCorrectionPass IShaderGammaCorrectionPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			GammaCorrection pass<br />
			See the [page:NgxShaderGammaCorrectionPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/GammaCorrectionPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IShaderLib">IShaderLib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IShader background] -  The background.<br />
			[property:IShader basic] -  The basic.<br />
			[property:IShader cube] -  The cube.<br />
			[property:IShader dashed] -  The dashed.<br />
			[property:IShader depth] -  The depth.<br />
			[property:IShader distanceRGBA] -  The distance r g b a.<br />
			[property:IShader equirect] -  The equirect.<br />
			[property:IShader lambert] -  The lambert.<br />
			[property:IShader matcap] -  The matcap.<br />
			[property:IShader normal] -  The normal.<br />
			[property:IShader phong] -  The phong.<br />
			[property:IShader physical] -  The physical.<br />
			[property:IShader points] -  The points.<br />
			[property:IShader shadow] -  The shadow.<br />
			[property:IShader sprite] -  The sprite.<br />
			[property:IShader standard] -  The standard.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderLuminosityPass">IShaderLuminosityPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderLuminosityPass IShaderLuminosityPass](  [param:string textureId]? ) - Creates an instance of ngx Luminosity pass.<br />
			[constructor:IShaderLuminosityPass IShaderLuminosityPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderLuminosityPass IShaderLuminosityPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Luminosity pass<br />
			See the [page:NgxShaderLuminosityPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/LuminosityPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IShaderMaterial">IShaderMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderMaterial IShaderMaterial](  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:IShaderMaterial IShaderMaterial](  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IShaderMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IShaderMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IShaderMaterialParameters">IShaderMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:boolean clipping]? -  The clipping.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:any extensions]? -  The extensions.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string fragmentShader]? -  The fragment shader.<br />
			[property:GLSLVersion glslVersion]? -  The glsl version.<br />
			[property:boolean lights]? -  The lights.<br />
			[property:number linewidth]? -  The linewidth.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any uniforms]? -  The uniforms.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:string vertexShader]? -  The vertex shader.<br />
			[property:boolean visible]? -  The visible.<br />
			[property:boolean wireframe]? -  The wireframe.<br />
			[property:number wireframeLinewidth]? -  The wireframe linewidth.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderMaterialPass">IShaderMaterialPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderMaterialPass IShaderMaterialPass](  [param:string textureId]? ) - Creates an instance of ngx ShaderMaterial pass.<br />
			[constructor:IShaderMaterialPass IShaderMaterialPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderMaterialPass IShaderMaterialPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			ShaderMaterial pass<br />
			See the [page:NgxShaderMaterialPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/ShaderMaterialPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IShaderPass">IShaderPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderPass IShaderPass](  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderPass IShaderPass](  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Shader pass<br />
			See the [page:NgxShaderPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/ShaderPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderPixelPass">IShaderPixelPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderPixelPass IShaderPixelPass](  [param:string textureId]? ) - Creates an instance of ngx Pixel pass.<br />
			[constructor:IShaderPixelPass IShaderPixelPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderPixelPass IShaderPixelPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Pixel pass<br />
			See the [page:NgxShaderPixelPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/PixelPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderRGBShiftPass">IShaderRGBShiftPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderRGBShiftPass IShaderRGBShiftPass](  [param:string textureId]? ) - Creates an instance of ngx RGBShift pass.<br />
			[constructor:IShaderRGBShiftPass IShaderRGBShiftPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderRGBShiftPass IShaderRGBShiftPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			RGBShift pass<br />
			See the [page:NgxShaderRGBShiftPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/RGBShiftPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderSepiaPass">IShaderSepiaPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderSepiaPass IShaderSepiaPass](  [param:string textureId]? ) - Creates an instance of ngx Sepia pass.<br />
			[constructor:IShaderSepiaPass IShaderSepiaPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderSepiaPass IShaderSepiaPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Sepia pass<br />
			See the [page:NgxShaderSepiaPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/SepiaPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="IShaderVignettePass">IShaderVignettePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShaderVignettePass IShaderVignettePass](  [param:string textureId]? ) - Creates an instance of ngx Vignette pass.<br />
			[constructor:IShaderVignettePass IShaderVignettePass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:IShaderVignettePass IShaderVignettePass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Vignette pass<br />
			See the [page:NgxShaderVignettePass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/VignettePass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IShadowMapViewer">IShadowMapViewer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShadowMapViewer IShadowMapViewer](  [param:ILight light] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean enabled] -  The enabled.<br />
			[property:IPosition position] -  The position.<br />
			[property:ISize size] -  The size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IRenderer renderer] ) <br />
			[method:void update](  ) <br />
			[method:void updateForWindowResize](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="IShadowMaterial">IShadowMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShadowMaterial IShadowMaterial](  [param:IShadowMaterialParameters parameters]? ) <br />
			[constructor:IShadowMaterial IShadowMaterial](  [param:IShadowMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] -  The transparent.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IShadowMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IShadowMaterial copy](  [param:IMaterial material] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IMaterialParameters values] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="IShadowMaterialParameters">IShadowMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IShadowMesh">IShadowMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShadowMesh IShadowMesh](  [param:IMesh mesh]? ) <br />
			[constructor:IShadowMesh IShadowMesh](  [param:IMesh mesh]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IShadowMesh IShadowMesh](  [param:IMesh mesh]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IShadowMesh add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IShadowMesh applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IShadowMesh attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IShadowMesh clear](  ) - Removes all child objects.<br />
			[method:IShadowMesh clone](  [param:boolean recursive]? ) <br />
			[method:IShadowMesh copy](  [param:IShadowMesh source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IShadowMesh remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IShadowMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IShadowMesh rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IShadowMesh rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IShadowMesh rotateX](  [param:number angle] ) <br />
			[method:IShadowMesh rotateY](  [param:number angle] ) <br />
			[method:IShadowMesh rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IShadowMesh translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IShadowMesh translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IShadowMesh translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IShadowMesh translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  [param:IPlane plane],  [param:IVector4 lightPosition4D] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr; [page:ICurvePath] &rarr; [page:IPath] &rarr;

		<h3 id="IShape">IShape <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShape IShape](  [param:any points]? ) <br />
			[constructor:IShape IShape](  [param:any points]?,  [param:any points]? ) <br />
			[constructor:IShape IShape](  [param:any points]?,  [param:any points]? ) <br />
			[constructor:IShape IShape](  [param:any points]?,  [param:any points]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:boolean autoClose] -  The auto close.<br />
			[property:IVector2|Vector2 currentPoint] -  The current point.<br />
			[property:ICurve[] curves] -  The curves.<br />
			[property:IPath[] holes] -  The holes.<br />
			[property:string type] -  The type.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IShape absarc](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[method:IShape absellipse](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[method:void add](  [param:ICurve curve] ) <br />
			[method:IShape arc](  [param:number aX],  [param:number aY],  [param:number aRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise] ) <br />
			[method:IShape bezierCurveTo](  [param:number aCP1x],  [param:number aCP1y],  [param:number aCP2x],  [param:number aCP2y],  [param:number aX],  [param:number aY] ) <br />
			[method:IShape clone](  ) <br />
			[method:void closePath](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:IShape copy](  [param:ICurve source] ) <br />
			[method:IShape ellipse](  [param:number aX],  [param:number aY],  [param:number xRadius],  [param:number yRadius],  [param:number aStartAngle],  [param:number aEndAngle],  [param:boolean aClockwise],  [param:number aRotation] ) <br />
			[method:void extractPoints](  [param:number divisions] ) <br />
			[method:IShape fromJSON](  [param:object json] ) <br />
			[method:IShape fromPoints](  [param:any vectors] ) <br />
			[method:number[] getCurveLengths](  ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector2|Vector2 getPoint](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getPointAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:void getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:void getPointsHoles](  [param:number divisions] ) <br />
			[method:void getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector2|Vector2 getTangent](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getTangentAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:IShape lineTo](  [param:number x],  [param:number y] ) <br />
			[method:IShape moveTo](  [param:number x],  [param:number y] ) <br />
			[method:IShape quadraticCurveTo](  [param:number aCPx],  [param:number aCPy],  [param:number aX],  [param:number aY] ) <br />
			[method:IShape setFromPoints](  [param:any vectors] ) <br />
			[method:IShape splineThru](  [param:any pts] ) <br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			Defines a 2d shape plane using paths.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IShapeGeometry">IShapeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShapeGeometry IShapeGeometry](  [param:IShape|IShape[] shapes]?,  [param:number curveSegments]? ) <br />
			[constructor:IShapeGeometry IShapeGeometry](  [param:IShape|IShape[] shapes]?,  [param:number curveSegments]?,  [param:IShape|IShape[] shapes]?,  [param:number curveSegments]? ) <br />
			[constructor:IShapeGeometry IShapeGeometry](  [param:IShape|IShape[] shapes]?,  [param:number curveSegments]?,  [param:IShape|IShape[] shapes]?,  [param:number curveSegments]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IShapeGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IShapePath">IShapePath <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IShapePath IShapePath](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IColor color] -  The color.<br />
			[property:any currentPath] -  The current path.<br />
			[property:any[] subPaths] -  The sub paths.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IShapePath bezierCurveTo](  [param:number aCP1x],  [param:number aCP1y],  [param:number aCP2x],  [param:number aCP2y],  [param:number aX],  [param:number aY] ) <br />
			[method:IShapePath lineTo](  [param:number x],  [param:number y] ) <br />
			[method:IShapePath moveTo](  [param:number x],  [param:number y] ) <br />
			[method:IShapePath quadraticCurveTo](  [param:number aCPx],  [param:number aCPy],  [param:number aX],  [param:number aY] ) <br />
			[method:IShapePath splineThru](  [param:any pts] ) <br />
			[method:IShape[] toShapes](  [param:boolean isCCW],  [param:boolean noHoles]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISimplifyModifier">ISimplifyModifier <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISimplifyModifier ISimplifyModifier](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry modify](  [param:IBufferGeometry geometry],  [param:number count] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISize">ISize <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number height] -  The height.<br />
			[property:number width] -  The width.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void set](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISkeleton">ISkeleton <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISkeleton ISkeleton](  [param:IBone[] bones],  [param:IMatrix4|Matrix4[] boneInverses]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IMatrix4|Matrix4[] boneInverses] -  The bone inverses.<br />
			[property:Float32Array boneMatrices] -  The bone matrices.<br />
			[property:IDataTexture boneTexture] -  The bone texture.<br />
			[property:number boneTextureSize] -  The bone texture size.<br />
			[property:IBone[] bones] -  The bones.<br />
			[property:number frame] -  The frame.<br />
			[property:boolean useVertexTexture] -  The use vertex texture.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void calculateInverses](  ) <br />
			[method:ISkeleton clone](  ) <br />
			[method:ISkeleton computeBoneTexture](  ) <br />
			[method:void dispose](  ) <br />
			[method:IBone getBoneByName](  [param:string name] ) <br />
			[method:void init](  ) <br />
			[method:void pose](  ) <br />
			[method:void update](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="ISkeletonHelper">ISkeletonHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISkeletonHelper ISkeletonHelper](  [param:IObject3D object] ) <br />
			[constructor:ISkeletonHelper ISkeletonHelper](  [param:IObject3D object],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:ISkeletonHelper ISkeletonHelper](  [param:IObject3D object],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:ISkeletonHelper ISkeletonHelper](  [param:IObject3D object],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:IBone[] bones] -  The bones.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isSkeletonHelper] -  The is skeleton helper.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IObject3D root] -  The root.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISkeletonHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ISkeletonHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ISkeletonHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ISkeletonHelper clear](  ) - Removes all child objects.<br />
			[method:ISkeletonHelper clone](  [param:boolean recursive]? ) <br />
			[method:ISkeletonHelper computeLineDistances](  ) <br />
			[method:ISkeletonHelper copy](  [param:ISkeletonHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IBone[] getBoneList](  [param:IObject3D object] ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ISkeletonHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ISkeletonHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ISkeletonHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ISkeletonHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ISkeletonHelper rotateX](  [param:number angle] ) <br />
			[method:ISkeletonHelper rotateY](  [param:number angle] ) <br />
			[method:ISkeletonHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ISkeletonHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ISkeletonHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ISkeletonHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ISkeletonHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="ISkinnedMesh">ISkinnedMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISkinnedMesh ISkinnedMesh](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:boolean useVertexTexture]? ) <br />
			[constructor:ISkinnedMesh ISkinnedMesh](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:boolean useVertexTexture]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) <br />
			[constructor:ISkinnedMesh ISkinnedMesh](  [param:TGeometry geometry]?,  [param:TMaterial material]?,  [param:boolean useVertexTexture]?,  [param:TGeometry geometry]?,  [param:TMaterial material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:IMatrix4|Matrix4 bindMatrix] -  The bind matrix.<br />
			[property:IMatrix4|Matrix4 bindMatrixInverse] -  The bind matrix inverse.<br />
			[property:string bindMode] -  The bind mode.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:TGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isSkinnedMesh] -  The is skinned mesh.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:TMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ISkeleton skeleton] -  The skeleton.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISkinnedMesh add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ISkinnedMesh applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ISkinnedMesh attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:void bind](  [param:ISkeleton skeleton],  [param:IMatrix4|Matrix4 bindMatrix]? ) <br />
			[method:IVector3 boneTransform](  [param:number index],  [param:IVector3|Vector3 target] ) <br />
			[method:ISkinnedMesh clear](  ) - Removes all child objects.<br />
			[method:ISkinnedMesh clone](  [param:boolean recursive]? ) <br />
			[method:ISkinnedMesh copy](  [param:ISkinnedMesh source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void normalizeSkinWeights](  ) <br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void pose](  ) <br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ISkinnedMesh remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ISkinnedMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ISkinnedMesh rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ISkinnedMesh rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ISkinnedMesh rotateX](  [param:number angle] ) <br />
			[method:ISkinnedMesh rotateY](  [param:number angle] ) <br />
			[method:ISkinnedMesh rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ISkinnedMesh translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ISkinnedMesh translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ISkinnedMesh translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ISkinnedMesh translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="ISky">ISky <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISky ISky](  ) <br />
			[constructor:ISky ISky](  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:ISky ISky](  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object SkyShader] -  The sky shader.<br />
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBoxGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISky add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ISky applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ISky attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ISky clear](  ) - Removes all child objects.<br />
			[method:ISky clone](  [param:boolean recursive]? ) <br />
			[method:ISky copy](  [param:ISky source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ISky remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ISky removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ISky rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ISky rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ISky rotateX](  [param:number angle] ) <br />
			[method:ISky rotateY](  [param:number angle] ) <br />
			[method:ISky rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ISky translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ISky translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ISky translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ISky translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:IShaderPass] &rarr;

		<h3 id="ISobelOperatorPass">ISobelOperatorPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISobelOperatorPass ISobelOperatorPass](  [param:string textureId]? ) - Creates an instance of ngx SobelOperator pass.<br />
			[constructor:ISobelOperatorPass ISobelOperatorPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) - Creates an instance of ngx shader pass.<br />
			[constructor:ISobelOperatorPass ISobelOperatorPass](  [param:string textureId]?,  [param:object shader],  [param:string textureId]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:string textureID] -  The texture i d.<br />
			[property:any uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			SobelOperator pass<br />
			See the [page:NgxSobelOperatorPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/SobelOperatorPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="ISpecularMIPLevelNode">ISpecularMIPLevelNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISpecularMIPLevelNode ISpecularMIPLevelNode](  [param:INode texture] ) <br />
			[constructor:ISpecularMIPLevelNode ISpecularMIPLevelNode](  [param:INode texture],  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ISpecularMIPLevelNode ISpecularMIPLevelNode](  [param:INode texture],  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:IMaxMIPLevelNode maxMIPLevel] -  The max m i p level.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:INode texture] -  The texture.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ISpecularMIPLevelNode copy](  [param:ISpecularMIPLevelNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ISpecularMIPLevelNode setLabel](  [param:string name] ) <br />
			[method:ISpecularMIPLevelNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISphere">ISphere <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISphere ISphere](  [param:IVector3|Vector3 center]?,  [param:number radius]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IVector3 center] -  The center.<br />
			[property:number radius] -  The radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISphere applyMatrix4](  [param:IMatrix4 matrix] ) <br />
			[method:IVector3 clampPoint](  [param:IVector3|Vector3 point],  [param:IVector3|Vector3 target] ) <br />
			[method:ISphere clone](  ) <br />
			[method:boolean containsPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:ISphere copy](  [param:ISphere sphere] ) <br />
			[method:number distanceToPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:any empty](  ) <br />
			[method:boolean equals](  [param:ISphere sphere] ) <br />
			[method:ISphere expandByPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:IBox3 getBoundingBox](  [param:IBox3 target] ) <br />
			[method:boolean intersectsBox](  [param:IBox3 box] ) <br />
			[method:boolean intersectsPlane](  [param:IPlane plane] ) <br />
			[method:boolean intersectsSphere](  [param:ISphere sphere] ) <br />
			[method:boolean isEmpty](  ) <br />
			[method:ISphere makeEmpty](  ) <br />
			[method:ISphere set](  [param:IVector3|Vector3 center],  [param:number radius] ) <br />
			[method:ISphere setFromPoints](  [param:any points],  [param:IVector3|Vector3 optionalCenter]? ) <br />
			[method:ISphere translate](  [param:IVector3|Vector3 offset] ) <br />
			[method:ISphere union](  [param:ISphere sphere] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ISphereGeometry">ISphereGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISphereGeometry ISphereGeometry](  [param:number radius]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:ISphereGeometry ISphereGeometry](  [param:number radius]?,  [param:number widthSegments]?,  [param:number heightSegments]?,  [param:number phiStart]?,  [param:number phiLength]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ISphereGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISpherical">ISpherical <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISpherical ISpherical](  [param:number radius]?,  [param:number phi]?,  [param:number theta]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number phi] -  The phi.<br />
			[property:number radius] -  The radius.<br />
			[property:number theta] -  The theta.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISpherical clone](  ) <br />
			[method:ISpherical copy](  [param:ISpherical other] ) <br />
			[method:ISpherical makeSafe](  ) <br />
			[method:ISpherical set](  [param:number radius],  [param:number phi],  [param:number theta] ) <br />
			[method:ISpherical setFromCartesianCoords](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:ISpherical setFromVector3](  [param:IVector3|Vector3 v] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISphericalHarmonics3">ISphericalHarmonics3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISphericalHarmonics3 ISphericalHarmonics3](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any coefficients] -  The coefficients.<br />
			[property:any isSphericalHarmonics3] -  The is spherical harmonics3.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISphericalHarmonics3 add](  [param:ISphericalHarmonics3 sh] ) <br />
			[method:ISphericalHarmonics3 addScaledSH](  [param:ISphericalHarmonics3 sh],  [param:number s] ) <br />
			[method:ISphericalHarmonics3 clone](  ) <br />
			[method:ISphericalHarmonics3 copy](  [param:ISphericalHarmonics3 sh] ) <br />
			[method:boolean equals](  [param:ISphericalHarmonics3 sh] ) <br />
			[method:ISphericalHarmonics3 fromArray](  [param:number[]|ArrayLike array],  [param:number offset]? ) - Sets the values of this spherical harmonics from the provided array or array-like.<br />
			[method:IVector3 getAt](  [param:IVector3|Vector3 normal],  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getIrradianceAt](  [param:IVector3|Vector3 normal],  [param:IVector3|Vector3 target] ) <br />
			[method:ISphericalHarmonics3 lerp](  [param:ISphericalHarmonics3 sh],  [param:number alpha] ) <br />
			[method:ISphericalHarmonics3 scale](  [param:number s] ) <br />
			[method:ISphericalHarmonics3 set](  [param:any coefficients] ) <br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns an array with the values of this spherical harmonics, or copies them into the provided array.<br />
			<br />
			Returns : The created or provided array.<br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:ArrayLike array],  [param:number offset]? ) - Returns an array with the values of this spherical harmonics, or copies them into the provided array-like.<br />
			<br />
			Returns : The provided array-like.<br />
			[method:ISphericalHarmonics3 zero](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ICurve] &rarr;

		<h3 id="ISplineCurve">ISplineCurve <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISplineCurve ISplineCurve](  [param:any points]? ) <br />
			[constructor:ISplineCurve ISplineCurve](  [param:any points]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number arcLengthDivisions] - This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.<br />
			To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.<br />
			[property:any points] -  The points.<br />
			[property:string type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISplineCurve clone](  ) <br />
			[method:void computeFrenetFrames](  [param:number segments],  [param:boolean closed]? ) - Generate Frenet frames of the curve<br />
			[method:ISplineCurve copy](  [param:ICurve source] ) <br />
			[method:ISplineCurve fromJSON](  [param:object json] ) <br />
			[method:number getLength](  ) - Get total curve arc length<br />
			[method:number[] getLengths](  [param:number divisions]? ) - Get list of cumulative segment lengths<br />
			[method:IVector2|Vector2 getPoint](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point t of the curve where t is between 0 and 1<br />
			getPoint(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getPointAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a vector for point at relative position in curve according to arc length<br />
			getPointAt(u: number, optionalTarget?: T): T;<br />
			[method:void getPoints](  [param:number divisions]? ) - Get sequence of points using getPoint( t )<br />
			getPoints(divisions?: number): T[];<br />
			[method:void getSpacedPoints](  [param:number divisions]? ) - Get sequence of equi-spaced points using getPointAt( u )<br />
			getSpacedPoints(divisions?: number): T[];<br />
			[method:IVector2|Vector2 getTangent](  [param:number t],  [param:IVector2|Vector2 optionalTarget]? ) - Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a<br />
			small delta apart will be used to find its gradient which seems to give a reasonable approximation<br />
			getTangent(t: number, optionalTarget?: T): T;<br />
			[method:IVector2|Vector2 getTangentAt](  [param:number u],  [param:IVector2|Vector2 optionalTarget]? ) - Returns tangent at equidistance point u on the curve<br />
			getTangentAt(u: number, optionalTarget?: T): T;<br />
			[method:number getUtoTmapping](  [param:number u],  [param:number distance] ) - Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance<br />
			[method:object toJSON](  ) <br />
			[method:void updateArcLengths](  ) - Update the cumlative segment distance cache
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ISplineUniform">ISplineUniform <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:IUniform flow] -  The flow.<br />
			[property:IUniform pathOffset] -  The path offset.<br />
			[property:IUniform pathSegment] -  The path segment.<br />
			[property:IUniform spineOffset] -  The spine offset.<br />
			[property:IUniform spineTexture] -  The spine texture.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILight] &rarr;

		<h3 id="ISpotLight">ISpotLight <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISpotLight ISpotLight](  [param:any color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number angle]?,  [param:number penumbra]?,  [param:number decay]? ) <br />
			[constructor:ISpotLight ISpotLight](  [param:any color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number angle]?,  [param:number penumbra]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) <br />
			[constructor:ISpotLight ISpotLight](  [param:any color]?,  [param:number intensity]?,  [param:number distance]?,  [param:number angle]?,  [param:number penumbra]?,  [param:number decay]?,  [param:string|number hex]?,  [param:number intensity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number angle] - Maximum extent of the spotlight, in radians, from its direction.<br />
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IColor color] -  The color.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number decay] -  The decay.<br />
			[property:number distance] - If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:number intensity] - Light's intensity.<br />
			[property:any isLight] -  The is light.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isSpotLight] -  The is spot light.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:number penumbra] -  The penumbra.<br />
			[property:IVector3 position] -  The position.<br />
			[property:number power] -  The power.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:ISpotLightShadow shadow] -  The shadow.<br />
			[property:any shadowBias] -  The shadow bias.<br />
			[property:any shadowCameraBottom] -  The shadow camera bottom.<br />
			[property:any shadowCameraFar] -  The shadow camera far.<br />
			[property:any shadowCameraFov] -  The shadow camera fov.<br />
			[property:any shadowCameraLeft] -  The shadow camera left.<br />
			[property:any shadowCameraNear] -  The shadow camera near.<br />
			[property:any shadowCameraRight] -  The shadow camera right.<br />
			[property:any shadowCameraTop] -  The shadow camera top.<br />
			[property:any shadowMapHeight] -  The shadow map height.<br />
			[property:any shadowMapWidth] -  The shadow map width.<br />
			[property:IObject3D target] - Spotlight focus points at target.position.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISpotLight add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ISpotLight applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ISpotLight attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ISpotLight clear](  ) - Removes all child objects.<br />
			[method:ISpotLight clone](  [param:boolean recursive]? ) <br />
			[method:ISpotLight copy](  [param:ISpotLight source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ISpotLight remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ISpotLight removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ISpotLight rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ISpotLight rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ISpotLight rotateX](  [param:number angle] ) <br />
			[method:ISpotLight rotateY](  [param:number angle] ) <br />
			[method:ISpotLight rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ISpotLight translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ISpotLight translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ISpotLight translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ISpotLight translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			A point light that can cast shadow in one direction.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ISpotLightHelper">ISpotLightHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISpotLightHelper ISpotLightHelper](  [param:ILight light],  [param:any color]? ) <br />
			[constructor:ISpotLightHelper ISpotLightHelper](  [param:ILight light],  [param:any color]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:any color] -  The color.<br />
			[property:ILineSegments cone] -  The cone.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:ILight light] -  The light.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISpotLightHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ISpotLightHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ISpotLightHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ISpotLightHelper clear](  ) - Removes all child objects.<br />
			[method:ISpotLightHelper clone](  [param:boolean recursive]? ) <br />
			[method:ISpotLightHelper copy](  [param:ISpotLightHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ISpotLightHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ISpotLightHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ISpotLightHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ISpotLightHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ISpotLightHelper rotateX](  [param:number angle] ) <br />
			[method:ISpotLightHelper rotateY](  [param:number angle] ) <br />
			[method:ISpotLightHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ISpotLightHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ISpotLightHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ISpotLightHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ISpotLightHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILightShadow] &rarr;

		<h3 id="ISpotLightShadow">ISpotLightShadow <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:number bias] -  The bias.<br />
			[property:number blurSamples] -  The blur samples.<br />
			[property:IPerspectiveCamera camera] -  The camera.<br />
			[property:number focus] -  The focus.<br />
			[property:any isSpotLightShadow] -  The is spot light shadow.<br />
			[property:IWebGLRenderTarget map] -  The map.<br />
			[property:IWebGLRenderTarget mapPass] -  The map pass.<br />
			[property:IVector2|Vector2 mapSize] -  The map size.<br />
			[property:IMatrix4 matrix] -  The matrix.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:number normalBias] -  The normal bias.<br />
			[property:number radius] -  The radius.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISpotLightShadow clone](  [param:boolean recursive]? ) <br />
			[method:ISpotLightShadow copy](  [param:ILightShadow source] ) <br />
			[method:void dispose](  ) <br />
			[method:IVector2 getFrameExtents](  ) <br />
			[method:number getFrustum](  ) <br />
			[method:IVector4 getViewport](  [param:number viewportIndex] ) <br />
			[method:any toJSON](  ) <br />
			[method:void updateMatrices](  [param:ILight light],  [param:number viewportIndex]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ISprite">ISprite <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISprite ISprite](  [param:ISpriteMaterial material]? ) <br />
			[constructor:ISprite ISprite](  [param:ISpriteMaterial material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isSprite] -  The is sprite.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:ISpriteMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ISprite add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ISprite applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ISprite attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ISprite clear](  ) - Removes all child objects.<br />
			[method:ISprite clone](  [param:boolean recursive]? ) <br />
			[method:ISprite copy](  [param:ISprite source] ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ISprite remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ISprite removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ISprite rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ISprite rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ISprite rotateX](  [param:number angle] ) <br />
			[method:ISprite rotateY](  [param:number angle] ) <br />
			[method:ISprite rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ISprite translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ISprite translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ISprite translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ISprite translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr;

		<h3 id="ISpriteMaterial">ISpriteMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISpriteMaterial ISpriteMaterial](  [param:ISpriteMaterialParameters parameters]? ) <br />
			[constructor:ISpriteMaterial ISpriteMaterial](  [param:ISpriteMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap] -  The alpha map.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:IColor color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defines] - Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.<br />
			The pairs are defined in both vertex and fragment shaders. Default is undefined.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:boolean fog] - Whether the material is affected by fog. Default is true.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:any isSpriteMaterial] -  The is sprite material.<br />
			[property:ITexture map] -  The map.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:number rotation] -  The rotation.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:boolean sizeAttenuation] -  The size attenuation.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] -  The transparent.<br />
			[property:string type] -  The type.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ISpriteMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:ISpriteMaterial copy](  [param:ISpriteMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:ISpriteMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta]? ) - Convert the material to three.js JSON format.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IMaterialParameters] &rarr;

		<h3 id="ISpriteMaterialParameters">ISpriteMaterialParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:ITexture alphaMap]? -  The alpha map.<br />
			[property:number alphaTest]? -  The alpha test.<br />
			[property:boolean alphaToCoverage]? -  The alpha to coverage.<br />
			[property:BlendingDstFactor blendDst]? -  The blend dst.<br />
			[property:number blendDstAlpha]? -  The blend dst alpha.<br />
			[property:BlendingEquation blendEquation]? -  The blend equation.<br />
			[property:number blendEquationAlpha]? -  The blend equation alpha.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc]? -  The blend src.<br />
			[property:number blendSrcAlpha]? -  The blend src alpha.<br />
			[property:Blending blending]? -  The blending.<br />
			[property:boolean clipIntersection]? -  The clip intersection.<br />
			[property:boolean clipShadows]? -  The clip shadows.<br />
			[property:IPlane[] clippingPlanes]? -  The clipping planes.<br />
			[property:any color]? -  The color.<br />
			[property:boolean colorWrite]? -  The color write.<br />
			[property:any defines]? -  The defines.<br />
			[property:DepthModes depthFunc]? -  The depth func.<br />
			[property:boolean depthTest]? -  The depth test.<br />
			[property:boolean depthWrite]? -  The depth write.<br />
			[property:boolean dithering]? -  The dithering.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:PixelFormat format]? -  The format.<br />
			[property:ITexture map]? -  The map.<br />
			[property:string name]? -  The name.<br />
			[property:number opacity]? -  The opacity.<br />
			[property:boolean polygonOffset]? -  The polygon offset.<br />
			[property:number polygonOffsetFactor]? -  The polygon offset factor.<br />
			[property:number polygonOffsetUnits]? -  The polygon offset units.<br />
			[property:'highp'|'mediump'|'lowp' precision]? -  The precision.<br />
			[property:boolean premultipliedAlpha]? -  The premultiplied alpha.<br />
			[property:number rotation]? -  The rotation.<br />
			[property:Side shadowSide]? -  The shadow side.<br />
			[property:Side side]? -  The side.<br />
			[property:boolean sizeAttenuation]? -  The size attenuation.<br />
			[property:StencilOp stencilFail]? -  The stencil fail.<br />
			[property:StencilFunc stencilFunc]? -  The stencil func.<br />
			[property:number stencilFuncMask]? -  The stencil func mask.<br />
			[property:number stencilRef]? -  The stencil ref.<br />
			[property:boolean stencilWrite]? -  The stencil write.<br />
			[property:number stencilWriteMask]? -  The stencil write mask.<br />
			[property:StencilOp stencilZFail]? -  The stencil z fail.<br />
			[property:StencilOp stencilZPass]? -  The stencil z pass.<br />
			[property:boolean toneMapped]? -  The tone mapped.<br />
			[property:boolean transparent]? -  The transparent.<br />
			[property:any userData]? -  The user data.<br />
			[property:boolean vertexColors]? -  The vertex colors.<br />
			[property:boolean visible]? -  The visible.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr;

		<h3 id="ISpriteNode">ISpriteNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISpriteNode ISpriteNode](  ) <br />
			[constructor:ISpriteNode ISpriteNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:any spherical] -  The spherical.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder] ) <br />
			[method:ISpriteNode copy](  [param:ISpriteNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:ISpriteNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr; [page:INodeMaterial] &rarr;

		<h3 id="ISpriteNodeMaterial">ISpriteNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISpriteNodeMaterial ISpriteNodeMaterial](  ) <br />
			[constructor:ISpriteNodeMaterial ISpriteNodeMaterial](  [param:INode vertex],  [param:INode fragment] ) <br />
			[constructor:ISpriteNodeMaterial ISpriteNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:ISpriteNodeMaterial ISpriteNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode alpha] -  The alpha.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:INode color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:INode|IRawNode fragment] -  The fragment.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:INode mask] -  The mask.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:INode position] -  The position.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:object properties] -  The properties.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:INode spherical] -  The spherical.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:INode|IRawNode vertex] -  The vertex.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ISpriteNodeMaterial build](  [param:INodeMaterialBuildParams params]? ) <br />
			[method:ISpriteNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:ISpriteNodeMaterial copy](  [param:INodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr;

		<h3 id="IStandardNode">IStandardNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IStandardNode IStandardNode](  ) <br />
			[constructor:IStandardNode IStandardNode](  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode color] -  The color.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:INode metalness] -  The metalness.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:INode roughness] -  The roughness.<br />
			[property:INode sheenColor] -  The sheen color.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder] ) <br />
			[method:IStandardNode copy](  [param:IStandardNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:IStandardNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IMaterial] &rarr; [page:IShaderMaterial] &rarr; [page:INodeMaterial] &rarr;

		<h3 id="IStandardNodeMaterial">IStandardNodeMaterial <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IStandardNodeMaterial IStandardNodeMaterial](  ) <br />
			[constructor:IStandardNodeMaterial IStandardNodeMaterial](  [param:INode vertex],  [param:INode fragment] ) <br />
			[constructor:IStandardNodeMaterial IStandardNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]? ) <br />
			[constructor:IStandardNodeMaterial IStandardNodeMaterial](  [param:INode vertex],  [param:INode fragment],  [param:IShaderMaterialParameters parameters]?,  [param:IMaterialParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode alpha] -  The alpha.<br />
			[property:number alphaTest] - Sets the alpha value to be used when running an alpha test. Default is 0.<br />
			[property:boolean alphaToCoverage] - Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.<br />
			[property:INode ambient] -  The ambient.<br />
			[property:INode ao] -  The ao.<br />
			[property:BlendingDstFactor blendDst] - Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.<br />
			[property:number blendDstAlpha] - The tranparency of the .blendDst. Default is null.<br />
			[property:BlendingEquation blendEquation] - Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.<br />
			[property:number blendEquationAlpha] - The tranparency of the .blendEquation. Default is null.<br />
			[property:BlendingDstFactor|BlendingSrcFactor blendSrc] - Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.<br />
			[property:number blendSrcAlpha] - The tranparency of the .blendSrc. Default is null.<br />
			[property:Blending blending] - Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.<br />
			[property:INode clearcoat] -  The clearcoat.<br />
			[property:INode clearcoatNormal] -  The clearcoat normal.<br />
			[property:INode clearcoatRoughness] -  The clearcoat roughness.<br />
			[property:boolean clipIntersection] - Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.<br />
			[property:boolean clipShadows] - Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.<br />
			[property:boolean clipping] -  The clipping.<br />
			[property:any clippingPlanes] - User-defined clipping planes specified as IPlane objects in world space.<br />
			These planes apply to the objects this material is attached to.<br />
			Points in space whose signed distance to the plane is negative are clipped (not rendered).<br />
			See the WebGL / clipping /intersection example. Default is null.<br />
			[property:INode color] -  The color.<br />
			[property:boolean colorWrite] - Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.<br />
			[property:any defaultAttributeValues] -  The default attribute values.<br />
			[property:any defines] -  The defines.<br />
			[property:DepthModes depthFunc] - Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.<br />
			[property:boolean depthTest] - Whether to have depth test enabled when rendering this material. Default is true.<br />
			[property:boolean depthWrite] - Whether rendering this material has any effect on the depth buffer. Default is true.<br />
			When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.<br />
			[property:any derivatives] -  The derivatives.<br />
			[property:boolean dithering] - Whether to apply dithering to the color to remove the appearance of banding. Default is false.<br />
			[property:INode emissive] -  The emissive.<br />
			[property:INode environment] -  The environment.<br />
			[property:any extensions] -  The extensions.<br />
			[property:boolean fog] -  The fog.<br />
			[property:PixelFormat format] - When this property is set to O3JS.RGBFormat, the material is considered to be opaque and alpha values are ignored.<br />
			[property:INode|IRawNode fragment] -  The fragment.<br />
			[property:string fragmentShader] -  The fragment shader.<br />
			[property:GLSLVersion glslVersion] -  The glsl version.<br />
			[property:number id] - Unique number of this material instance.<br />
			[property:string index0AttributeName] -  The index0 attribute name.<br />
			[property:any isMaterial] - Used to check whether this or derived classes are materials. Default is true.<br />
			You should not change this, as it used internally for optimisation.<br />
			[property:any isNodeMaterial] -  The is node material.<br />
			[property:boolean isShaderMaterial] -  The is shader material.<br />
			[property:INode light] -  The light.<br />
			[property:boolean lights] -  The lights.<br />
			[property:number linewidth] -  The linewidth.<br />
			[property:INode mask] -  The mask.<br />
			[property:INode metalness] -  The metalness.<br />
			[property:string name] - Material name. Default is an empty string.<br />
			[property:boolean needsUpdate] - Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.<br />
			This property is automatically set to true when instancing a new material.<br />
			[property:INode normal] -  The normal.<br />
			[property:number opacity] - Opacity. Default is 1.<br />
			[property:boolean polygonOffset] - Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.<br />
			[property:number polygonOffsetFactor] - Sets the polygon offset factor. Default is 0.<br />
			[property:number polygonOffsetUnits] - Sets the polygon offset units. Default is 0.<br />
			[property:INode position] -  The position.<br />
			[property:'highp'|'mediump'|'lowp' precision] - Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.<br />
			[property:boolean premultipliedAlpha] - Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.<br />
			[property:object properties] -  The properties.<br />
			[property:INode reflectivity] -  The reflectivity.<br />
			[property:INode roughness] -  The roughness.<br />
			[property:INode shadow] -  The shadow.<br />
			[property:Side shadowSide] - Defines which of the face sides will cast shadows. Default is *null*.<br />
			If *null*, the value is opposite that of side, above.<br />
			[property:INode sheenColor] -  The sheen color.<br />
			[property:Side side] - Defines which of the face sides will be rendered - front, back or both.<br />
			Default is O3JS.FrontSide. Other options are O3JS.BackSide and O3JS.DoubleSide.<br />
			[property:StencilOp stencilFail] - Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.<br />
			[property:StencilFunc stencilFunc] - The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.<br />
			[property:number stencilFuncMask] - The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.<br />
			[property:number stencilRef] - The value to use when performing stencil comparisons or stencil operations. Default is *0*.<br />
			[property:boolean stencilWrite] - Whether rendering this material has any effect on the stencil buffer. Default is *false*.<br />
			[property:number stencilWriteMask] - The bit mask to use when writing to the stencil buffer. Default is *0xFF*.<br />
			[property:StencilOp stencilZFail] - Which stencil operation to perform when the comparison function returns true but the depth test fails.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:StencilOp stencilZPass] - Which stencil operation to perform when the comparison function returns true and the depth test passes.<br />
			Default is {@link KeepStencilOp}.<br />
			See the stencil operation constants for all possible values.<br />
			[property:boolean toneMapped] - Defines whether this material is tone mapped according to the renderer's toneMapping setting.<br />
			Default is true.<br />
			[property:boolean transparent] - Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.<br />
			When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.<br />
			Default is false.<br />
			[property:string type] -  The type.<br />
			[property:any uniforms] -  The uniforms.<br />
			[property:boolean uniformsNeedUpdate] -  The uniforms need update.<br />
			[property:object[] updaters] -  The updaters.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] - UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.<br />
			[property:number version] - This starts at 0 and counts how many times .needsUpdate is set to true.<br />
			[property:INode|IRawNode vertex] -  The vertex.<br />
			[property:boolean vertexColors] - Defines whether vertex coloring is used. Default is false.<br />
			[property:string vertexShader] -  The vertex shader.<br />
			[property:boolean visible] - Defines whether this material is visible. Default is true.<br />
			[property:boolean wireframe] -  The wireframe.<br />
			[property:number wireframeLinewidth] -  The wireframe linewidth.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IStandardNodeMaterial build](  [param:INodeMaterialBuildParams params]? ) <br />
			[method:IStandardNodeMaterial clone](  ) - Return a new material with the same parameters as this material.<br />
			[method:IStandardNodeMaterial copy](  [param:INodeMaterial source] ) - Copy the parameters from the passed material into this material.<br />
			[method:string customProgramCacheKey](  ) - In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.<br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@line THREE.Texture}.<br />
			[method:string getHash](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onBeforeCompile](  [param:IShader shader],  [param:IWebGLRenderer renderer] ) - An optional callback that is executed immediately before the shader program is compiled.<br />
			This function is called with the shader source code as a parameter.<br />
			Useful for the modification of built-in materials.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setValues](  [param:IShaderMaterialParameters parameters] ) - Sets the properties based on the values.<br />
			[method:any toJSON](  [param:any meta] ) - Convert the material to three.js JSON format.<br />
			[method:void updateFrame](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IStarDepthGeometry">IStarDepthGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IStarDepthGeometry IStarDepthGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number depth]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number depthRate]? ) <br />
			[constructor:IStarDepthGeometry IStarDepthGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number depth]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number depthRate]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] - The Parameters of star depth geometry<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IStarDepthGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			The Star Depth geometry.<br />
			See the [page:NgxStarDepthGeometry ngx3js docs] page for details.<br />
			See the [example:ngx_geometry/StarDepthGeometry ngx geometey] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:ICircleGeometry] &rarr;

		<h3 id="IStarGeometry">IStarGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IStarGeometry IStarGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:IStarGeometry IStarGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) <br />
			[constructor:IStarGeometry IStarGeometry](  [param:number innerRadius]?,  [param:number outerRadius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]?,  [param:number radius]?,  [param:number segments]?,  [param:number thetaStart]?,  [param:number thetaLength]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IStarGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			The Star geometry.<br />
			See the [page:NgxStarGeometry ngx3js docs] page for details.<br />
			See the [example:ngx_geometry/StarGeometry ngx geometey] page for a live demo.
		</p>

		<hr class="interface-line"/>
		<h3 id="IStats">IStats <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number REVISION] -  The r e v i s i o n.<br />
			[property:HTMLDivElement dom] -  The dom.<br />
			[property:HTMLDivElement domElement] -  The dom element.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IPanel addPanel](  [param:IPanel panel] ) <br />
			[method:void begin](  ) <br />
			[method:void end](  ) <br />
			[method:void setMode](  [param:number id] ) <br />
			[method:void showPanel](  [param:number id] ) <br />
			[method:void update](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ICamera] &rarr;

		<h3 id="IStereoCamera">IStereoCamera <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IStereoCamera IStereoCamera](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:number aspect] -  The aspect.<br />
			[property:IPerspectiveCamera cameraL] -  The camera l.<br />
			[property:IPerspectiveCamera cameraR] -  The camera r.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:number eyeSep] -  The eye sep.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isCamera] -  The is camera.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:IMatrix4|Matrix4 matrixWorldInverse] - This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IMatrix4|Matrix4 projectionMatrix] - This is the matrix which contains the projection.<br />
			[property:IMatrix4|Matrix4 projectionMatrixInverse] - This is the inverse of projectionMatrix.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:any type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IStereoCamera add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IStereoCamera applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IStereoCamera attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IStereoCamera clear](  ) - Removes all child objects.<br />
			[method:IStereoCamera clone](  [param:boolean recursive]? ) <br />
			[method:IStereoCamera copy](  [param:IStereoCamera source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IStereoCamera remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IStereoCamera removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IStereoCamera rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IStereoCamera rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IStereoCamera rotateX](  [param:number angle] ) <br />
			[method:IStereoCamera rotateY](  [param:number angle] ) <br />
			[method:IStereoCamera rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IStereoCamera translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IStereoCamera translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IStereoCamera translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IStereoCamera translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  [param:IPerspectiveCamera camera] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IStormParams">IStormParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean isEternal]? -  The is eternal.<br />
			[property:IMaterial lightningMaterial]? -  The lightning material.<br />
			[property:number lightningMaxDuration]? -  The lightning max duration.<br />
			[property:number lightningMaxPeriod]? -  The lightning max period.<br />
			[property:number lightningMinDuration]? -  The lightning min duration.<br />
			[property:number lightningMinPeriod]? -  The lightning min period.<br />
			[property:IRayParameters lightningParameters]? -  The lightning parameters.<br />
			[property:number maxHeight]? -  The max height.<br />
			[property:number maxLightnings]? -  The max lightnings.<br />
			[property:number maxSlope]? -  The max slope.<br />
			[property:number minHeight]? -  The min height.<br />
			[property:number size]? -  The size.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void onLightningDown](  [param:ILightningStrike lightning] ) <br />
			[method:void onRayPosition](  [param:IVector3 source],  [param:IVector3 dest] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IKeyframeTrack] &rarr;

		<h3 id="IStringKeyframeTrack">IStringKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IStringKeyframeTrack IStringKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:ILinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:ICubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:IStringKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:IKeyframeTrack optimize](  ) <br />
			[method:IKeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:IKeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:IKeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:IKeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IStrokeStyle">IStrokeStyle <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string strokeColor] -  The stroke color.<br />
			[property:string strokeLineCap] -  The stroke line cap.<br />
			[property:string strokeLineJoin] -  The stroke line join.<br />
			[property:number strokeMiterLimit] -  The stroke miter limit.<br />
			[property:number strokeWidth] -  The stroke width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IStructNode">IStructNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IStructNode IStructNode](  [param:string src]? ) <br />
			[constructor:IStructNode IStructNode](  [param:string src]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IStructNode IStructNode](  [param:string src]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:IStructNodeInput[] inputs] -  The inputs.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string src] -  The src.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IStructNode copy](  [param:INode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:IStructNodeInput getInputByName](  [param:string name] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src] ) <br />
			[method:IStructNode setLabel](  [param:string name] ) <br />
			[method:IStructNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IStructNodeInput">IStructNodeInput <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:string name] -  The name.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr;

		<h3 id="ISwitchNode">ISwitchNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ISwitchNode ISwitchNode](  [param:INode node],  [param:string components]? ) <br />
			[constructor:ISwitchNode ISwitchNode](  [param:INode node],  [param:string components]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string components] -  The components.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:INode node] -  The node.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:ISwitchNode copy](  [param:ISwitchNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:ISwitchNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr; [page:ISSAARenderPass] &rarr;

		<h3 id="ITAARenderPass">ITAARenderPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITAARenderPass ITAARenderPass](  [param:IScene scene],  [param:ICamera camera],  [param:any clearColor],  [param:number clearAlpha] ) - Creates an instance of ngx taarender pass.<br />
			[constructor:ITAARenderPass ITAARenderPass](  [param:IScene scene],  [param:ICamera camera],  [param:any clearColor],  [param:number clearAlpha],  [param:IScene scene],  [param:ICamera camera],  [param:any clearColor],  [param:number clearAlpha] ) - Creates an instance of ngx ssaarender pass.<br />
			[constructor:ITAARenderPass ITAARenderPass](  [param:IScene scene],  [param:ICamera camera],  [param:any clearColor],  [param:number clearAlpha],  [param:IScene scene],  [param:ICamera camera],  [param:any clearColor],  [param:number clearAlpha] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean accumulate] -  The accumulate.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:boolean clear] -  The clear.<br />
			[property:number clearAlpha] -  The clear alpha.<br />
			[property:any clearColor] -  The clear color.<br />
			[property:IShaderMaterial copyMaterial] -  The copy material.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:number sampleLevel] -  The sample level.<br />
			[property:IWebGLRenderTarget sampleRenderTarget] -  The sample render target.<br />
			[property:IScene scene] -  The scene.<br />
			[property:boolean unbiased] -  The unbiased.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			TAARender pass<br />
			See the [page:NgxTAARenderPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/TAARenderPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ITDSLoader">ITDSLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITDSLoader ITDSLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:boolean debug] -  The debug.<br />
			[property:IGroup group] -  The group.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:IMaterial[] materials] -  The materials.<br />
			[property:IMesh[] meshes] -  The meshes.<br />
			[property:string path] -  The path.<br />
			[property:number position] -  The position.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void debugMessage](  [param:object message] ) <br />
			[method:void endChunk](  [param:object chunk] ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void nextChunk](  [param:DataView data],  [param:object chunk] ) <br />
			[method:IGroup parse](  [param:ArrayBuffer arraybuffer],  [param:string path] ) <br />
			[method:number readByte](  [param:DataView data] ) <br />
			[method:object readChunk](  [param:DataView data] ) <br />
			[method:IColor readColor](  [param:DataView data] ) <br />
			[method:number readDWord](  [param:DataView data] ) <br />
			[method:void readFaceArray](  [param:DataView data],  [param:IMesh mesh] ) <br />
			[method:void readFile](  [param:ArrayBuffer arraybuffer],  [param:string path] ) <br />
			[method:number readFloat](  [param:DataView data] ) <br />
			[method:number readInt](  [param:DataView data] ) <br />
			[method:ITexture readMap](  [param:DataView data],  [param:string path] ) <br />
			[method:void readMaterialEntry](  [param:DataView data],  [param:string path] ) <br />
			[method:object readMaterialGroup](  [param:DataView data] ) <br />
			[method:IMesh readMesh](  [param:DataView data] ) <br />
			[method:void readMeshData](  [param:DataView data],  [param:string path] ) <br />
			[method:void readNamedObject](  [param:DataView data] ) <br />
			[method:number readShort](  [param:DataView data] ) <br />
			[method:string readString](  [param:DataView data],  [param:number maxLength] ) <br />
			[method:number readWord](  [param:DataView data] ) <br />
			[method:void resetPosition](  ) <br />
			[method:ITDSLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ITDSLoader setPath](  [param:string path] ) <br />
			[method:ITDSLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ITDSLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ITDSLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr; [page:IDataTextureLoader] &rarr;

		<h3 id="ITGALoader">ITGALoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITGALoader ITGALoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDataTexture load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IDataTexture parse](  [param:ArrayBuffer data] ) <br />
			[method:ITGALoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ITGALoader setPath](  [param:string path] ) <br />
			[method:ITGALoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ITGALoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ITGALoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ITTFLoader">ITTFLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITTFLoader ITTFLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean reversed] -  The reversed.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:object parse](  [param:ArrayBuffer arraybuffer] ) <br />
			[method:ITTFLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ITTFLoader setPath](  [param:string path] ) <br />
			[method:ITTFLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ITTFLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ITTFLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ITeapotGeometry">ITeapotGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITeapotGeometry ITeapotGeometry](  [param:number size]?,  [param:number segments]?,  [param:boolean bottom]?,  [param:boolean lid]?,  [param:boolean body]?,  [param:boolean fitLid]?,  [param:boolean blinn]? ) <br />
			[constructor:ITeapotGeometry ITeapotGeometry](  [param:number size]?,  [param:number segments]?,  [param:boolean bottom]?,  [param:boolean lid]?,  [param:boolean body]?,  [param:boolean fitLid]?,  [param:boolean blinn]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ITeapotGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr;

		<h3 id="ITempNode">ITempNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITempNode ITempNode](  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ITempNode ITempNode](  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ITempNode copy](  [param:INode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ITempNode setLabel](  [param:string name] ) <br />
			[method:ITempNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ITempNodeParams">ITempNodeParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean shared]? -  The shared.<br />
			[property:boolean unique]? -  The unique.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ITessellateModifier">ITessellateModifier <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITessellateModifier ITessellateModifier](  [param:number maxEdgeLength]?,  [param:number maxIterations]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number maxEdgeLength] -  The max edge length.<br />
			[property:number maxIterations] -  The max iterations.
		</p>
		<h4>Methods</h4>
		<p>
			[method:TGeometry modify](  [param:TGeometry geometry] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IPolyhedronGeometry] &rarr;

		<h3 id="ITetrahedronGeometry">ITetrahedronGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITetrahedronGeometry ITetrahedronGeometry](  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:ITetrahedronGeometry ITetrahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) <br />
			[constructor:ITetrahedronGeometry ITetrahedronGeometry](  [param:number radius]?,  [param:number detail]?,  [param:number[] vertices]?,  [param:number[] indices]?,  [param:number radius]?,  [param:number detail]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ITetrahedronGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IExtrudeGeometry] &rarr;

		<h3 id="ITextGeometry">ITextGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITextGeometry ITextGeometry](  [param:string text],  [param:ITextGeometryParameters parameters] ) <br />
			[constructor:ITextGeometry ITextGeometry](  [param:string text],  [param:ITextGeometryParameters parameters],  [param:IShape|IShape[] shapes]?,  [param:IExtrudeGeometryOptions options]? ) <br />
			[constructor:ITextGeometry ITextGeometry](  [param:string text],  [param:ITextGeometryParameters parameters],  [param:IShape|IShape[] shapes]?,  [param:IExtrudeGeometryOptions options]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:void addShape](  [param:IShape shape],  [param:any options]? ) <br />
			[method:void addShapeList](  [param:IShape[] shapes],  [param:any options]? ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ITextGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ITextGeometryParameters">ITextGeometryParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean bevelEnabled]? -  The bevel enabled.<br />
			[property:number bevelOffset]? -  The bevel offset.<br />
			[property:number bevelSegments]? -  The bevel segments.<br />
			[property:number bevelSize]? -  The bevel size.<br />
			[property:number bevelThickness]? -  The bevel thickness.<br />
			[property:number curveSegments]? -  The curve segments.<br />
			[property:IFont font] -  The font.<br />
			[property:number height]? -  The height.<br />
			[property:number size]? -  The size.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="ITexture">ITexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITexture ITexture](  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:ITexture clone](  ) <br />
			[method:ITexture copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="ITextureCubeNode">ITextureCubeNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITextureCubeNode ITextureCubeNode](  [param:ITextureNode value],  [param:IFloatNode textureSize]? ) <br />
			[constructor:ITextureCubeNode ITextureCubeNode](  [param:ITextureNode value],  [param:IFloatNode textureSize]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ITextureCubeNode ITextureCubeNode](  [param:ITextureNode value],  [param:IFloatNode textureSize]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any irradianceCache] -  The irradiance cache.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:any radianceCache] -  The radiance cache.<br />
			[property:boolean shared] -  The shared.<br />
			[property:IFloatNode textureSize] -  The texture size.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:ITextureNode value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ITextureCubeNode copy](  [param:INode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateTextureCubeUV](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ITextureCubeNode setLabel](  [param:string name] ) <br />
			[method:ITextureCubeNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="ITextureCubeUVNode">ITextureCubeUVNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITextureCubeUVNode ITextureCubeUVNode](  [param:INode uv],  [param:IFloatNode textureSize] ) <br />
			[constructor:ITextureCubeUVNode ITextureCubeUVNode](  [param:INode uv],  [param:IFloatNode textureSize],  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ITextureCubeUVNode ITextureCubeUVNode](  [param:INode uv],  [param:IFloatNode textureSize],  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any Nodes] -  The nodes.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:IFloatNode textureSize] -  The texture size.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:INode uv] -  The uv.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ITextureCubeUVNode copy](  [param:INode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ITextureCubeUVNode setLabel](  [param:string name] ) <br />
			[method:ITextureCubeUVNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ITextureLoader">ITextureLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITextureLoader ITextureLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ITexture load](  [param:string url],  [param:any onLoad]?,  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:ITextureLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ITextureLoader setPath](  [param:string path] ) <br />
			[method:ITextureLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ITextureLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ITextureLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			Class for loading a texture.<br />
			Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="ITextureNode">ITextureNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITextureNode ITextureNode](  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]? ) <br />
			[constructor:ITextureNode ITextureNode](  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ITextureNode ITextureNode](  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ITextureNode ITextureNode](  [param:ITexture value],  [param:IUVNode|IUVTransformNode uv]?,  [param:INode bias]?,  [param:boolean project]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:INode bias] -  The bias.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean project] -  The project.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IUVNode|IUVTransformNode uv] -  The uv.<br />
			[property:ITexture value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ITextureNode copy](  [param:ITextureNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getTexture](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ITextureNode setLabel](  [param:string name] ) <br />
			[method:ITextureNode setName](  [param:string name] ) <br />
			[method:ITextureNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="ITexturePass">ITexturePass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITexturePass ITexturePass](  [param:ITexture map],  [param:number opacity]? ) - Creates an instance of ngx texture pass.<br />
			[constructor:ITexturePass ITexturePass](  [param:ITexture map],  [param:number opacity]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean clear] -  The clear.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:ITexture map] -  The map.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number opacity] -  The opacity.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:object uniforms] -  The uniforms.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			Texture pass<br />
			See the [page:NgxTexturePass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/TexturePass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IThreeMFLoader">IThreeMFLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IThreeMFLoader IThreeMFLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object[] availableExtensions] -  The available extensions.<br />
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addExtension](  [param:object extension] ) <br />
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IGroup parse](  [param:ArrayBuffer data] ) <br />
			[method:IThreeMFLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IThreeMFLoader setPath](  [param:string path] ) <br />
			[method:IThreeMFLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IThreeMFLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IThreeMFLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="ITiltLoader">ITiltLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITiltLoader ITiltLoader](  [param:ILoadingManager manager]?,  [param:string storePath]? ) <br />
			[constructor:ITiltLoader ITiltLoader](  [param:ILoadingManager manager]?,  [param:string storePath]?,  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IGroup parse](  [param:ArrayBuffer data] ) <br />
			[method:ITiltLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:ITiltLoader setPath](  [param:string path] ) <br />
			[method:ITiltLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:ITiltLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:ITiltLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr; [page:IFloatNode] &rarr;

		<h3 id="ITimerNode">ITimerNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITimerNode ITimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]? ) <br />
			[constructor:ITimerNode ITimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]?,  [param:number value]? ) <br />
			[constructor:ITimerNode ITimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]?,  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ITimerNode ITimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]?,  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:ITimerNode ITimerNode](  [param:number scale]?,  [param:string scope]?,  [param:boolean timeScale]?,  [param:number value]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string DELTA] -  The d e l t a.<br />
			[property:string GLOBAL] -  The g l o b a l.<br />
			[property:string LOCAL] -  The l o c a l.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:number scale] -  The scale.<br />
			[property:string scope] -  The scope.<br />
			[property:boolean shared] -  The shared.<br />
			[property:boolean timeScale] -  The time scale.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:ITimerNode copy](  [param:ITimerNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:ITimerNode setLabel](  [param:string name] ) <br />
			[method:ITimerNode setName](  [param:string name] ) <br />
			[method:ITimerNode setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ITorusGeometry">ITorusGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITorusGeometry ITorusGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number radialSegments]?,  [param:number tubularSegments]?,  [param:number arc]? ) <br />
			[constructor:ITorusGeometry ITorusGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number radialSegments]?,  [param:number tubularSegments]?,  [param:number arc]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ITorusGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ITorusKnotGeometry">ITorusKnotGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITorusKnotGeometry ITorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number tubularSegments]?,  [param:number radialSegments]?,  [param:number p]?,  [param:number q]? ) <br />
			[constructor:ITorusKnotGeometry ITorusKnotGeometry](  [param:number radius]?,  [param:number tube]?,  [param:number tubularSegments]?,  [param:number radialSegments]?,  [param:number p]?,  [param:number q]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ITorusKnotGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="ITrackballControls">ITrackballControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITrackballControls ITrackballControls](  [param:ICamera object],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:number dynamicDampingFactor] -  The dynamic damping factor.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:string[] keys] -  The keys.<br />
			[property:number maxDistance] -  The max distance.<br />
			[property:number minDistance] -  The min distance.<br />
			[property:any mouseButtons] -  The mouse buttons.<br />
			[property:boolean noPan] -  The no pan.<br />
			[property:boolean noRoll] -  The no roll.<br />
			[property:boolean noRotate] -  The no rotate.<br />
			[property:boolean noZoom] -  The no zoom.<br />
			[property:ICamera object] -  The object.<br />
			[property:number panSpeed] -  The pan speed.<br />
			[property:IVector3 position0] -  The position0.<br />
			[property:number rotateSpeed] -  The rotate speed.<br />
			[property:any screen] -  The screen.<br />
			[property:boolean staticMoving] -  The static moving.<br />
			[property:IVector3 target] -  The target.<br />
			[property:IVector3 target0] -  The target0.<br />
			[property:IVector3 up0] -  The up0.<br />
			[property:number zoomSpeed] -  The zoom speed.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void checkDistances](  ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:void handleResize](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void panCamera](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void reset](  ) <br />
			[method:void rotateCamera](  ) <br />
			[method:void update](  ) <br />
			[method:void zoomCamera](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr;

		<h3 id="ITransformControls">ITransformControls <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITransformControls ITransformControls](  [param:ICamera object],  [param:HTMLElement domElement]? ) <br />
			[constructor:ITransformControls ITransformControls](  [param:ICamera object],  [param:HTMLElement domElement]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:'X'|'Y'|'Z'|'E'|'XY'|'YZ'|'XZ'|'XYZ'|'XYZE' axis] -  The axis.<br />
			[property:ICamera camera] -  The camera.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:HTMLElement domElement] -  The dom element.<br />
			[property:boolean dragging] -  The dragging.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isTransformControls] -  The is transform controls.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:'translate'|'rotate'|'scale' mode] -  The mode.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any mouseButtons] -  The mouse buttons.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D object] -  The object.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:number rotationSnap] -  The rotation snap.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:boolean showX] -  The show x.<br />
			[property:boolean showY] -  The show y.<br />
			[property:boolean showZ] -  The show z.<br />
			[property:number size] -  The size.<br />
			[property:'local'|'world' space] -  The space.<br />
			[property:number translationSnap] -  The translation snap.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ITransformControls add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:ITransformControls applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:ITransformControls attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:ITransformControls clear](  ) - Removes all child objects.<br />
			[method:ITransformControls clone](  [param:boolean recursive]? ) <br />
			[method:ITransformControls copy](  [param:ITransformControls source],  [param:boolean recursive]? ) <br />
			[method:ITransformControls detach](  ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:void getMode](  ) <br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IRaycaster getRaycaster](  ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:ITransformControls remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:ITransformControls removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:ITransformControls rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:ITransformControls rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:ITransformControls rotateX](  [param:number angle] ) <br />
			[method:ITransformControls rotateY](  [param:number angle] ) <br />
			[method:ITransformControls rotateZ](  [param:number angle] ) <br />
			[method:void setMode](  [param:'translate'|'rotate'|'scale' mode] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:void setRotationSnap](  [param:number rotationSnap] ) <br />
			[method:void setScaleSnap](  [param:number scaleSnap] ) <br />
			[method:void setSize](  [param:number size] ) <br />
			[method:void setSpace](  [param:'local'|'world' space] ) <br />
			[method:void setTranslationSnap](  [param:number translationSnap] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:ITransformControls translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:ITransformControls translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:ITransformControls translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:ITransformControls translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ITriangle">ITriangle <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITriangle ITriangle](  [param:IVector3|Vector3 a]?,  [param:IVector3|Vector3 b]?,  [param:IVector3|Vector3 c]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IVector3 a] -  The a.<br />
			[property:IVector3 b] -  The b.<br />
			[property:IVector3 c] -  The c.
		</p>
		<h4>Methods</h4>
		<p>
			[method:ITriangle clone](  ) <br />
			[method:IVector3 closestPointToPoint](  [param:IVector3|Vector3 point],  [param:IVector3|Vector3 target] ) <br />
			[method:boolean containsPoint](  [param:IVector3|Vector3 point] ) <br />
			[method:ITriangle copy](  [param:ITriangle triangle] ) <br />
			[method:boolean equals](  [param:ITriangle triangle] ) <br />
			[method:number getArea](  ) <br />
			[method:IVector3 getBarycoord](  [param:IVector3|Vector3 point],  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getMidpoint](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getNormal](  [param:IVector3|Vector3 target] ) <br />
			[method:IPlane getPlane](  [param:IPlane target] ) <br />
			[method:IVector2 getUV](  [param:IVector3|Vector3 point],  [param:IVector2|Vector2 uv1],  [param:IVector2|Vector2 uv2],  [param:IVector2|Vector2 uv3],  [param:IVector2|Vector2 target] ) <br />
			[method:boolean intersectsBox](  [param:IBox3 box] ) <br />
			[method:boolean isFrontFacing](  [param:IVector3|Vector3 direction] ) <br />
			[method:ITriangle set](  [param:IVector3|Vector3 a],  [param:IVector3|Vector3 b],  [param:IVector3|Vector3 c] ) <br />
			[method:ITriangle setFromAttributeAndIndices](  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:number i0],  [param:number i1],  [param:number i2] ) <br />
			[method:ITriangle setFromPointsAndIndices](  [param:any points],  [param:number i0],  [param:number i1],  [param:number i2] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="ITubeGeometry">ITubeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITubeGeometry ITubeGeometry](  [param:ICurve path]?,  [param:number tubularSegments]?,  [param:number radius]?,  [param:number radiusSegments]?,  [param:boolean closed]? ) <br />
			[constructor:ITubeGeometry ITubeGeometry](  [param:ICurve path]?,  [param:number tubularSegments]?,  [param:number radius]?,  [param:number radiusSegments]?,  [param:boolean closed]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:any binormals] -  The binormals.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any normals] -  The normals.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:any tangents] -  The tangents.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:ITubeGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="ITubePainter">ITubePainter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:ITubePainter ITubePainter](  ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IMesh mesh] -  The mesh.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void stroke](  [param:IVector3 position1],  [param:IVector3 position2],  [param:IMatrix4 matrix1],  [param:IMatrix4 matrix2] ) <br />
			[method:void updateGeometry](  [param:number start],  [param:number end] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IUSDZExporter">IUSDZExporter <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IUSDZExporter IUSDZExporter](  ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:Promise parse](  [param:IObject3D scene] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IUVBoxes">IUVBoxes <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number h] -  The h.<br />
			[property:number index] -  The index.<br />
			[property:number w] -  The w.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IUVGenerator">IUVGenerator <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:void generateSideWallUV](  [param:IExtrudeGeometry geometry],  [param:number[] vertices],  [param:number indexA],  [param:number indexB],  [param:number indexC],  [param:number indexD] ) <br />
			[method:void generateTopUV](  [param:IExtrudeGeometry geometry],  [param:number[] vertices],  [param:number indexA],  [param:number indexB],  [param:number indexC] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr;

		<h3 id="IUVNode">IUVNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IUVNode IUVNode](  [param:number index]? ) <br />
			[constructor:IUVNode IUVNode](  [param:number index]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IUVNode IUVNode](  [param:number index]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:number index] -  The index.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IUVNode copy](  [param:IUVNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IUVNode setLabel](  [param:string name] ) <br />
			[method:IUVNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IFunctionNode] &rarr; [page:IExpressionNode] &rarr;

		<h3 id="IUVTransformNode">IUVTransformNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IUVTransformNode IUVTransformNode](  [param:IUVNode uv]?,  [param:IMatrix3Node position]? ) <br />
			[constructor:IUVTransformNode IUVTransformNode](  [param:IUVNode uv]?,  [param:IMatrix3Node position]?,  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]? ) <br />
			[constructor:IUVTransformNode IUVTransformNode](  [param:IUVNode uv]?,  [param:IMatrix3Node position]?,  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]? ) <br />
			[constructor:IUVTransformNode IUVTransformNode](  [param:IUVNode uv]?,  [param:IMatrix3Node position]?,  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IUVTransformNode IUVTransformNode](  [param:IUVNode uv]?,  [param:IMatrix3Node position]?,  [param:string src],  [param:string type]?,  [param:object keywords]?,  [param:object extensions]?,  [param:object[] includes]?,  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]?,  [param:string type]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:object extensions] -  The extensions.<br />
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:object[] includes] -  The includes.<br />
			[property:IFunctionNodeInput[] inputs] -  The inputs.<br />
			[property:boolean isMethod] -  The is method.<br />
			[property:any isNode] -  The is node.<br />
			[property:object keywords] -  The keywords.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:IMatrix3Node position] -  The position.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:boolean useKeywords] -  The use keywords.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IUVNode uv] -  The uv.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IUVTransformNode copy](  [param:IUVTransformNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getIncludeByName](  [param:string name] ) <br />
			[method:IFunctionNodeInput getInputByName](  [param:string name] ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder] ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:void parse](  [param:string src],  [param:object[] includes]?,  [param:object extensions]?,  [param:object keywords]? ) <br />
			[method:IUVTransformNode setLabel](  [param:string name] ) <br />
			[method:IUVTransformNode setName](  [param:string name] ) <br />
			[method:void setUvTransform](  [param:number tx],  [param:number ty],  [param:number sx],  [param:number sy],  [param:number rotation],  [param:number cx]?,  [param:number cy]? ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IUint16BufferAttribute">IUint16BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IUint16BufferAttribute IUint16BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IUint16BufferAttribute IUint16BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IUint16BufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IUint16BufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IUint16BufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IUint16BufferAttribute clone](  ) <br />
			[method:IUint16BufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IUint16BufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IUint16BufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IUint16BufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IUint16BufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IUint16BufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IUint16BufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IUint16BufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IUint16BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IUint16BufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IUint16BufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IUint16BufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IUint16BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IUint16BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IUint16BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IUint16BufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IUint16BufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IUint16BufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IUint32BufferAttribute">IUint32BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IUint32BufferAttribute IUint32BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IUint32BufferAttribute IUint32BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IUint32BufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IUint32BufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IUint32BufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IUint32BufferAttribute clone](  ) <br />
			[method:IUint32BufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IUint32BufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IUint32BufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IUint32BufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IUint32BufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IUint32BufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IUint32BufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IUint32BufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IUint32BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IUint32BufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IUint32BufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IUint32BufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IUint32BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IUint32BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IUint32BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IUint32BufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IUint32BufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IUint32BufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IUint8BufferAttribute">IUint8BufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IUint8BufferAttribute IUint8BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IUint8BufferAttribute IUint8BufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IUint8BufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IUint8BufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IUint8BufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IUint8BufferAttribute clone](  ) <br />
			[method:IUint8BufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IUint8BufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IUint8BufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IUint8BufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IUint8BufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IUint8BufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IUint8BufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IUint8BufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IUint8BufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IUint8BufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IUint8BufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IUint8BufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IUint8BufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IUint8BufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IUint8BufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IUint8BufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IUint8BufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IUint8BufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IBufferAttribute] &rarr;

		<h3 id="IUint8ClampedBufferAttribute">IUint8ClampedBufferAttribute <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IUint8ClampedBufferAttribute IUint8ClampedBufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]? ) <br />
			[constructor:IUint8ClampedBufferAttribute IUint8ClampedBufferAttribute](  [param:number|ArrayLike|ArrayBuffer|Iterable array],  [param:number itemSize],  [param:boolean normalized]?,  [param:ArrayLike array],  [param:number itemSize],  [param:boolean normalized]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:ArrayLike array] -  The array.<br />
			[property:number count] -  The count.<br />
			[property:any isBufferAttribute] -  The is buffer attribute.<br />
			[property:number itemSize] -  The item size.<br />
			[property:string name] -  The name.<br />
			[property:boolean normalized] -  The normalized.<br />
			[property:any updateRange] -  The update range.<br />
			[property:Usage usage] -  The usage.<br />
			[property:number version] -  The version.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IUint8ClampedBufferAttribute applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IUint8ClampedBufferAttribute applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IUint8ClampedBufferAttribute applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IUint8ClampedBufferAttribute clone](  ) <br />
			[method:IUint8ClampedBufferAttribute copy](  [param:IBufferAttribute source] ) <br />
			[method:IUint8ClampedBufferAttribute copyArray](  [param:ArrayLike array] ) <br />
			[method:IUint8ClampedBufferAttribute copyAt](  [param:number index1],  [param:IBufferAttribute attribute],  [param:number index2] ) <br />
			[method:IUint8ClampedBufferAttribute copyColorsArray](  [param:any colors] ) <br />
			[method:IUint8ClampedBufferAttribute copyVector2sArray](  [param:any vectors] ) <br />
			[method:IUint8ClampedBufferAttribute copyVector3sArray](  [param:any vectors] ) <br />
			[method:IUint8ClampedBufferAttribute copyVector4sArray](  [param:any vectors] ) <br />
			[method:number getW](  [param:number index] ) <br />
			[method:number getX](  [param:number index] ) <br />
			[method:number getY](  [param:number index] ) <br />
			[method:number getZ](  [param:number index] ) <br />
			[method:IUint8ClampedBufferAttribute onUpload](  [param:any callback] ) <br />
			[method:void onUploadCallback](  ) <br />
			[method:IUint8ClampedBufferAttribute set](  [param:ArrayLike|ArrayBufferView value],  [param:number offset]? ) <br />
			[method:IUint8ClampedBufferAttribute setUsage](  [param:Usage usage] ) <br />
			[method:IUint8ClampedBufferAttribute setW](  [param:number index],  [param:number z] ) <br />
			[method:IUint8ClampedBufferAttribute setX](  [param:number index],  [param:number x] ) <br />
			[method:IUint8ClampedBufferAttribute setXY](  [param:number index],  [param:number x],  [param:number y] ) <br />
			[method:IUint8ClampedBufferAttribute setXYZ](  [param:number index],  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IUint8ClampedBufferAttribute setXYZW](  [param:number index],  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) <br />
			[method:IUint8ClampedBufferAttribute setY](  [param:number index],  [param:number y] ) <br />
			[method:IUint8ClampedBufferAttribute setZ](  [param:number index],  [param:number z] ) <br />
			[method:void toJSON](  ) <br />
			[method:IUint8ClampedBufferAttribute transformDirection](  [param:IMatrix4|Matrix4 m] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IUniform">IUniform <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:TValue value] -  The value.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IUniformsLib">IUniformsLib <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:any aomap] -  The aomap.<br />
			[property:any bumpmap] -  The bumpmap.<br />
			[property:any common] -  The common.<br />
			[property:any displacementmap] -  The displacementmap.<br />
			[property:any emissivemap] -  The emissivemap.<br />
			[property:any envmap] -  The envmap.<br />
			[property:any fog] -  The fog.<br />
			[property:any gradientmap] -  The gradientmap.<br />
			[property:any lightmap] -  The lightmap.<br />
			[property:any lights] -  The lights.<br />
			[property:any metalnessmap] -  The metalnessmap.<br />
			[property:any normalmap] -  The normalmap.<br />
			[property:any points] -  The points.<br />
			[property:any roughnessmap] -  The roughnessmap.<br />
			[property:any specularmap] -  The specularmap.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IUniformsUtils">IUniformsUtils <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:any clone](  [param:any uniforms] ) <br />
			[method:any merge](  [param:any uniforms_src] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IPass] &rarr;

		<h3 id="IUnrealBloomPass">IUnrealBloomPass <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IUnrealBloomPass IUnrealBloomPass](  [param:IVector2 resolution],  [param:number strength],  [param:number radius],  [param:number threshold] ) - Creates an instance of ngx unreal bloom pass.<br />
			[constructor:IUnrealBloomPass IUnrealBloomPass](  [param:IVector2 resolution],  [param:number strength],  [param:number radius],  [param:number threshold] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IMeshBasicMaterial basic] -  The basic.<br />
			[property:IVector3[] bloomTintColors] -  The bloom tint colors.<br />
			[property:boolean clear] -  The clear.<br />
			[property:IColor clearColor] -  The clear color.<br />
			[property:IShaderMaterial compositeMaterial] -  The composite material.<br />
			[property:object copyUniforms] -  The copy uniforms.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:object fsQuad] -  The fs quad.<br />
			[property:object highPassUniforms] -  The high pass uniforms.<br />
			[property:IShaderMaterial materialCopy] -  The material copy.<br />
			[property:IShaderMaterial materialHighPassFilter] -  The material high pass filter.<br />
			[property:number nMips] -  The n mips.<br />
			[property:boolean needsSwap] -  The needs swap.<br />
			[property:number oldClearAlpha] -  The old clear alpha.<br />
			[property:IColor oldClearColor] -  The old clear color.<br />
			[property:number radius] -  The radius.<br />
			[property:IWebGLRenderTarget renderTargetBright] -  The render target bright.<br />
			[property:IWebGLRenderTarget[] renderTargetsHorizontal] -  The render targets horizontal.<br />
			[property:IWebGLRenderTarget[] renderTargetsVertical] -  The render targets vertical.<br />
			[property:boolean renderToScreen] -  The render to screen.<br />
			[property:IVector2 resolution] -  The resolution.<br />
			[property:IShaderMaterial[] separableBlurMaterials] -  The separable blur materials.<br />
			[property:number strength] -  The strength.<br />
			[property:number threshold] -  The threshold.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:IShaderMaterial getCompositeMaterial](  ) <br />
			[method:IShaderMaterial getSeperableBlurMaterial](  ) <br />
			[method:void render](  [param:IWebGLRenderer renderer],  [param:IWebGLRenderTarget writeBuffer],  [param:IWebGLRenderTarget readBuffer],  [param:number deltaTime],  [param:boolean maskActive] ) <br />
			[method:void setSize](  [param:number width],  [param:number height] ) 
		</p>

		<p class="desc">
			UnrealBloom pass<br />
			See the [page:NgxUnrealBloomPass ngx3js docs] page for details.<br />
			See the [example:ngx_effect/UnrealBloomPass ngx effect] page for a live demo.
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:ITexture] &rarr; [page:IDataTexture3D] &rarr;

		<h3 id="IVOXDataTexture3D">IVOXDataTexture3D <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVOXDataTexture3D IVOXDataTexture3D](  [param:IChunk chunk] ) <br />
			[constructor:IVOXDataTexture3D IVOXDataTexture3D](  [param:IChunk chunk],  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth] ) <br />
			[constructor:IVOXDataTexture3D IVOXDataTexture3D](  [param:IChunk chunk],  [param:BufferSource data],  [param:number width],  [param:number height],  [param:number depth],  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:any isDataTexture3D] -  The is data texture3 d.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:boolean wrapR] -  The wrap r.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IVOXDataTexture3D clone](  ) <br />
			[method:IVOXDataTexture3D copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IVOXLoader">IVOXLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVOXLoader IVOXLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:object[] parse](  [param:ArrayBuffer data] ) <br />
			[method:IVOXLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IVOXLoader setPath](  [param:string path] ) <br />
			[method:IVOXLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IVOXLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IVOXLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IVOXMesh">IVOXMesh <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVOXMesh IVOXMesh](  [param:IChunk chunk] ) <br />
			[constructor:IVOXMesh IVOXMesh](  [param:IChunk chunk],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IVOXMesh IVOXMesh](  [param:IChunk chunk],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IVOXMesh add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IVOXMesh applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IVOXMesh attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IVOXMesh clear](  ) - Removes all child objects.<br />
			[method:IVOXMesh clone](  [param:boolean recursive]? ) <br />
			[method:IVOXMesh copy](  [param:IVOXMesh source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IVOXMesh remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IVOXMesh removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IVOXMesh rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IVOXMesh rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IVOXMesh rotateX](  [param:number angle] ) <br />
			[method:IVOXMesh rotateY](  [param:number angle] ) <br />
			[method:IVOXMesh rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IVOXMesh translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IVOXMesh translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IVOXMesh translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IVOXMesh translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IVRMLLoader">IVRMLLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVRMLLoader IVRMLLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IScene parse](  [param:string data],  [param:string path] ) <br />
			[method:IVRMLLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IVRMLLoader setPath](  [param:string path] ) <br />
			[method:IVRMLLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IVRMLLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IVRMLLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IVRMLoader">IVRMLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVRMLoader IVRMLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:IGLTFLoader gltfLoader] -  The gltf loader.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:void parse](  [param:IGLTF gltf],  [param:any onLoad] ) <br />
			[method:IVRMLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IVRMLoader setDRACOLoader](  [param:IDRACOLoader dracoLoader] ) <br />
			[method:IVRMLoader setPath](  [param:string path] ) <br />
			[method:IVRMLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IVRMLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IVRMLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IVTKLoader">IVTKLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVTKLoader IVTKLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:IBufferGeometry parse](  [param:string|ArrayBuffer data],  [param:string path] ) <br />
			[method:IVTKLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IVTKLoader setPath](  [param:string path] ) <br />
			[method:IVTKLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IVTKLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IVTKLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr;

		<h3 id="IVarNode">IVarNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVarNode IVarNode](  [param:string type],  [param:any value]? ) <br />
			[constructor:IVarNode IVarNode](  [param:string type],  [param:any value]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:string type] -  The type.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:any value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]? ) <br />
			[method:IVarNode copy](  [param:IVarNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:string getType](  [param:INodeBuilder builder] ) <br />
			[method:IVarNode setName](  [param:string name] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IVector">IVector <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Methods</h4>
		<p>
			[method:IVector add](  [param:IVector v] ) - NOTE: The second argument is deprecated.<br />
			add(v:T):T;<br />
			[method:IVector addScalar](  [param:number scalar] ) - Adds the scalar value s to this vector's values.<br />
			[method:IVector addScaledVector](  [param:IVector vector],  [param:number scale] ) <br />
			[method:IVector addVectors](  [param:IVector a],  [param:IVector b] ) - addVectors(a:T, b:T):T;<br />
			[method:IVector clone](  ) - clone():T;<br />
			[method:IVector copy](  [param:IVector v] ) - copy(v:T):T;<br />
			[method:number distanceTo](  [param:IVector v] ) - NOTE: Vector4 doesn't have the property.<br />
			distanceTo(v:T):number;<br />
			[method:number distanceToSquared](  [param:IVector v] ) - NOTE: Vector4 doesn't have the property.<br />
			distanceToSquared(v:T):number;<br />
			[method:IVector divideScalar](  [param:number s] ) - divideScalar(s:number):T;<br />
			[method:number dot](  [param:IVector v] ) - dot(v:T):T;<br />
			[method:boolean equals](  [param:IVector v] ) - equals(v:T):boolean;<br />
			[method:number getComponent](  [param:number index] ) <br />
			[method:number length](  ) - length():number;<br />
			[method:number lengthSq](  ) - lengthSq():number;<br />
			[method:IVector lerp](  [param:IVector v],  [param:number alpha] ) - lerp(v:T, alpha:number):T;<br />
			[method:IVector multiplyScalar](  [param:number s] ) - multiplyScalar(s:number):T;<br />
			[method:IVector negate](  ) - negate():T;<br />
			[method:IVector normalize](  ) - normalize():T;<br />
			[method:IVector set](  [param:number[] args] ) <br />
			[method:IVector setComponent](  [param:number index],  [param:number value] ) <br />
			[method:IVector setLength](  [param:number l] ) - setLength(l:number):T;<br />
			[method:IVector setScalar](  [param:number scalar] ) <br />
			[method:IVector sub](  [param:IVector v] ) - sub(v:T):T;<br />
			[method:IVector subVectors](  [param:IVector a],  [param:IVector b] ) - subVectors(a:T, b:T):T;
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IVector] &rarr;

		<h3 id="IVector2">IVector2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVector2 IVector2](  [param:number x]?,  [param:number y]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number height] -  The height.<br />
			[property:any isVector2] -  The is vector2.<br />
			[property:number width] -  The width.<br />
			[property:number x] -  The x.<br />
			[property:number y] -  The y.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IVector2 add](  [param:IVector2|Vector2 v],  [param:IVector2|Vector2 w]? ) - Adds v to this vector.<br />
			[method:IVector2 addScalar](  [param:number s] ) - Adds the scalar value s to this vector's x and y values.<br />
			[method:IVector2 addScaledVector](  [param:IVector2|Vector2 v],  [param:number s] ) - Adds the multiple of v and s to this vector.<br />
			[method:IVector2 addVectors](  [param:IVector2|Vector2 a],  [param:IVector2|Vector2 b] ) - Sets this vector to a + b.<br />
			[method:number angle](  ) - computes the angle in radians with respect to the positive x-axis<br />
			[method:IVector2 applyMatrix3](  [param:IMatrix3|Matrix3 m] ) - Multiplies this vector (with an implicit 1 as the 3rd component) by m.<br />
			[method:IVector2 ceil](  ) - The x and y components of the vector are rounded up to the nearest integer value.<br />
			[method:IVector2 clamp](  [param:IVector2|Vector2 min],  [param:IVector2|Vector2 max] ) - If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value.<br />
			If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value.<br />
			[method:IVector2 clampLength](  [param:number min],  [param:number max] ) - If this vector's length is greater than the max value, it is replaced by the max value.<br />
			If this vector's length is less than the min value, it is replaced by the min value.<br />
			[method:IVector2 clampScalar](  [param:number min],  [param:number max] ) - If this vector's x or y values are greater than the max value, they are replaced by the max value.<br />
			If this vector's x or y values are less than the min value, they are replaced by the min value.<br />
			[method:IVector2 clone](  ) - Returns a new Vector2 instance with the same `x` and `y` values.<br />
			[method:IVector2 copy](  [param:IVector2|Vector2 v] ) - Copies value of v to this vector.<br />
			[method:number cross](  [param:IVector2|Vector2 v] ) - Computes cross product of this vector and v.<br />
			[method:number distanceTo](  [param:IVector2|Vector2 v] ) - Computes distance of this vector to v.<br />
			[method:number distanceToManhattan](  [param:IVector2|Vector2 v] ) <br />
			[method:number distanceToSquared](  [param:IVector2|Vector2 v] ) - Computes squared distance of this vector to v.<br />
			[method:IVector2 divide](  [param:IVector2|Vector2 v] ) - Divides this vector by v.<br />
			[method:IVector2 divideScalar](  [param:number s] ) - Divides this vector by scalar s.<br />
			Set vector to ( 0, 0 ) if s == 0.<br />
			[method:number dot](  [param:IVector2|Vector2 v] ) - Computes dot product of this vector and v.<br />
			[method:boolean equals](  [param:IVector2|Vector2 v] ) - Checks for strict equality of this vector and v.<br />
			[method:IVector2 floor](  ) - The components of the vector are rounded down to the nearest integer value.<br />
			[method:IVector2 fromArray](  [param:number[]|ArrayLike array],  [param:number offset]? ) - Sets this vector's x and y value from the provided array or array-like.<br />
			[method:IVector2 fromBufferAttribute](  [param:IBufferAttribute attribute],  [param:number index] ) - Sets this vector's x and y values from the attribute.<br />
			[method:number getComponent](  [param:number index] ) - Gets a component of this vector.<br />
			[method:number length](  ) - Computes length of this vector.<br />
			[method:number lengthManhattan](  ) <br />
			[method:number lengthSq](  ) - Computes squared length of this vector.<br />
			[method:IVector2 lerp](  [param:IVector2|Vector2 v],  [param:number alpha] ) - Linearly interpolates between this vector and v, where alpha is the distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v.<br />
			[method:IVector2 lerpVectors](  [param:IVector2|Vector2 v1],  [param:IVector2|Vector2 v2],  [param:number alpha] ) - Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2.<br />
			[method:number manhattanDistanceTo](  [param:IVector2|Vector2 v] ) - Computes the Manhattan length (distance) from this vector to the given vector v<br />
			see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}<br />
			[method:number manhattanLength](  ) - Computes the Manhattan length of this vector.<br />
			see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}<br />
			[method:IVector2 max](  [param:IVector2|Vector2 v] ) - If this vector's x or y value is less than v's x or y value, replace that value with the corresponding max value.<br />
			[method:IVector2 min](  [param:IVector2|Vector2 v] ) - If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding min value.<br />
			[method:IVector2 multiply](  [param:IVector2|Vector2 v] ) - Multiplies this vector by v.<br />
			[method:IVector2 multiplyScalar](  [param:number scalar] ) - Multiplies this vector by scalar s.<br />
			[method:IVector2 negate](  ) - Inverts this vector.<br />
			[method:IVector2 normalize](  ) - Normalizes this vector.<br />
			[method:IVector2 random](  ) - Sets this vector's x and y from Math.random<br />
			[method:IVector2 rotateAround](  [param:IVector2|Vector2 center],  [param:number angle] ) - Rotates the vector around center by angle radians.<br />
			[method:IVector2 round](  ) - The components of the vector are rounded to the nearest integer value.<br />
			[method:IVector2 roundToZero](  ) - The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value.<br />
			[method:IVector2 set](  [param:number x],  [param:number y] ) - Sets value of this vector.<br />
			[method:IVector2 setComponent](  [param:number index],  [param:number value] ) - Sets a component of this vector.<br />
			[method:IVector2 setLength](  [param:number length] ) - Normalizes this vector and multiplies it by l.<br />
			[method:IVector2 setScalar](  [param:number scalar] ) - Sets the x and y values of this vector both equal to scalar.<br />
			[method:IVector2 setX](  [param:number x] ) - Sets X component of this vector.<br />
			[method:IVector2 setY](  [param:number y] ) - Sets Y component of this vector.<br />
			[method:IVector2 sub](  [param:IVector2|Vector2 v] ) - Subtracts v from this vector.<br />
			[method:IVector2 subScalar](  [param:number s] ) - Subtracts s from this vector's x and y components.<br />
			[method:IVector2 subVectors](  [param:IVector2|Vector2 a],  [param:IVector2|Vector2 b] ) - Sets this vector to a - b.<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns an array [x, y], or copies x and y into the provided array.<br />
			<br />
			Returns : The created or provided array.<br />
			[method:TVector2Tuple toArray](  [param:number[] array]?,  [param:number offset]?,  [param:TVector2Tuple array]?,  [param:any offset]? ) <br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:TVector2Tuple array]?,  [param:any offset]?,  [param:ArrayLike array],  [param:number offset]? ) - Copies x and y into the provided array-like.<br />
			<br />
			Returns : The provided array-like.
		</p>

		<p class="desc">
			2D vector.<br />
			( class Vector2 implements Vector&lt;Vector2&gt; )
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IVector2Node">IVector2Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVector2Node IVector2Node](  [param:number|IVector2 x],  [param:number y]? ) <br />
			[constructor:IVector2Node IVector2Node](  [param:number|IVector2 x],  [param:number y]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IVector2Node IVector2Node](  [param:number|IVector2 x],  [param:number y]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IVector2Node IVector2Node](  [param:number|IVector2 x],  [param:number y]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IVector2 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IVector2Node copy](  [param:IVector2Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IVector2Node setLabel](  [param:string name] ) <br />
			[method:IVector2Node setName](  [param:string name] ) <br />
			[method:IVector2Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IVector] &rarr;

		<h3 id="IVector3">IVector3 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVector3 IVector3](  [param:number x]?,  [param:number y]?,  [param:number z]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isVector3] -  The is vector3.<br />
			[property:number x] -  The x.<br />
			[property:number y] -  The y.<br />
			[property:number z] -  The z.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IVector3 add](  [param:IVector3|Vector3 v] ) - Adds v to this vector.<br />
			[method:IVector3 addScalar](  [param:number s] ) - Adds the scalar value s to this vector's values.<br />
			[method:IVector3 addScaledVector](  [param:IVector3|Vector3 v],  [param:number s] ) <br />
			[method:IVector3 addVectors](  [param:IVector3|Vector3 a],  [param:IVector3|Vector3 b] ) - Sets this vector to a + b.<br />
			[method:number angleTo](  [param:IVector3|Vector3 v] ) <br />
			[method:IVector3 applyAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:IVector3 applyEuler](  [param:IEuler|Euler euler] ) <br />
			[method:IVector3 applyMatrix3](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IVector3 applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IVector3 applyNormalMatrix](  [param:IMatrix3|Matrix3 m] ) <br />
			[method:IVector3 applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IVector3 ceil](  ) <br />
			[method:IVector3 clamp](  [param:IVector3|Vector3 min],  [param:IVector3|Vector3 max] ) <br />
			[method:IVector3 clampLength](  [param:number min],  [param:number max] ) <br />
			[method:IVector3 clampScalar](  [param:number min],  [param:number max] ) <br />
			[method:IVector3 clone](  ) - Clones this vector.<br />
			[method:IVector3 copy](  [param:IVector3|Vector3 v] ) - Copies value of v to this vector.<br />
			[method:IVector3 cross](  [param:IVector3|Vector3 a] ) - Sets this vector to cross product of itself and v.<br />
			[method:IVector3 crossVectors](  [param:IVector3|Vector3 a],  [param:IVector3|Vector3 b] ) - Sets this vector to cross product of a and b.<br />
			[method:number distanceTo](  [param:IVector3|Vector3 v] ) - Computes distance of this vector to v.<br />
			[method:number distanceToManhattan](  [param:IVector3|Vector3 v] ) <br />
			[method:number distanceToSquared](  [param:IVector3|Vector3 v] ) - Computes squared distance of this vector to v.<br />
			[method:IVector3 divide](  [param:IVector3|Vector3 v] ) <br />
			[method:IVector3 divideScalar](  [param:number s] ) - Divides this vector by scalar s.<br />
			Set vector to ( 0, 0, 0 ) if s == 0.<br />
			[method:number dot](  [param:IVector3|Vector3 v] ) - Computes dot product of this vector and v.<br />
			[method:boolean equals](  [param:IVector3|Vector3 v] ) - Checks for strict equality of this vector and v.<br />
			[method:IVector3 floor](  ) <br />
			[method:IVector3 fromArray](  [param:number[]|ArrayLike array],  [param:number offset]? ) - Sets this vector's x, y and z value from the provided array or array-like.<br />
			[method:IVector3 fromBufferAttribute](  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:number index] ) <br />
			[method:number getComponent](  [param:number index] ) <br />
			[method:number length](  ) - Computes length of this vector.<br />
			[method:number lengthManhattan](  ) - Computes Manhattan length of this vector.<br />
			http://en.wikipedia.org/wiki/Taxicab_geometry<br />
			[method:number lengthSq](  ) - Computes squared length of this vector.<br />
			[method:IVector3 lerp](  [param:IVector3|Vector3 v],  [param:number alpha] ) - lerp(v:T, alpha:number):T;<br />
			[method:IVector3 lerpVectors](  [param:IVector3|Vector3 v1],  [param:IVector3|Vector3 v2],  [param:number alpha] ) <br />
			[method:number manhattanDistanceTo](  [param:IVector3|Vector3 v] ) - Computes the Manhattan length (distance) from this vector to the given vector v<br />
			see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}<br />
			[method:number manhattanLength](  ) - Computes the Manhattan length of this vector.<br />
			see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}<br />
			[method:IVector3 max](  [param:IVector3|Vector3 v] ) <br />
			[method:IVector3 min](  [param:IVector3|Vector3 v] ) <br />
			[method:IVector3 multiply](  [param:IVector3|Vector3 v] ) <br />
			[method:IVector3 multiplyScalar](  [param:number s] ) - Multiplies this vector by scalar s.<br />
			[method:IVector3 multiplyVectors](  [param:IVector3|Vector3 a],  [param:IVector3|Vector3 b] ) <br />
			[method:IVector3 negate](  ) - Inverts this vector.<br />
			[method:IVector3 normalize](  ) - Normalizes this vector.<br />
			[method:IVector3 project](  [param:ICamera camera] ) <br />
			[method:IVector3 projectOnPlane](  [param:IVector3|Vector3 planeNormal] ) <br />
			[method:IVector3 projectOnVector](  [param:IVector3|Vector3 v] ) <br />
			[method:IVector3 random](  ) - Sets this vector's x, y and z from Math.random<br />
			[method:IVector3 randomDirection](  ) <br />
			[method:IVector3 reflect](  [param:IVector3|Vector3 vector] ) <br />
			[method:IVector3 round](  ) <br />
			[method:IVector3 roundToZero](  ) <br />
			[method:IVector3 set](  [param:number x],  [param:number y],  [param:number z] ) - Sets value of this vector.<br />
			[method:IVector3 setComponent](  [param:number index],  [param:number value] ) <br />
			[method:IVector3 setFromCylindrical](  [param:ICylindrical s] ) <br />
			[method:IVector3 setFromCylindricalCoords](  [param:number radius],  [param:number theta],  [param:number y] ) <br />
			[method:IVector3 setFromMatrix3Column](  [param:IMatrix3|Matrix3 matrix],  [param:number index] ) <br />
			[method:IVector3 setFromMatrixColumn](  [param:IMatrix4 matrix],  [param:number index] ) <br />
			[method:IVector3 setFromMatrixPosition](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IVector3 setFromMatrixScale](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IVector3 setFromSpherical](  [param:ISpherical s] ) <br />
			[method:IVector3 setFromSphericalCoords](  [param:number r],  [param:number phi],  [param:number theta] ) <br />
			[method:IVector3 setLength](  [param:number l] ) - Normalizes this vector and multiplies it by l.<br />
			[method:IVector3 setScalar](  [param:number scalar] ) - Sets all values of this vector.<br />
			[method:IVector3 setX](  [param:number x] ) - Sets x value of this vector.<br />
			[method:IVector3 setY](  [param:number y] ) - Sets y value of this vector.<br />
			[method:IVector3 setZ](  [param:number z] ) - Sets z value of this vector.<br />
			[method:IVector3 sub](  [param:IVector3|Vector3 a] ) - Subtracts v from this vector.<br />
			[method:IVector3 subScalar](  [param:number s] ) <br />
			[method:IVector3 subVectors](  [param:IVector3|Vector3 a],  [param:IVector3|Vector3 b] ) - Sets this vector to a - b.<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns an array [x, y, z], or copies x, y and z into the provided array.<br />
			<br />
			Returns : The created or provided array.<br />
			[method:TVector3Tuple toArray](  [param:number[] array]?,  [param:number offset]?,  [param:TVector3Tuple array]?,  [param:any offset]? ) <br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:TVector3Tuple array]?,  [param:any offset]?,  [param:ArrayLike array],  [param:number offset]? ) - Copies x, y and z into the provided array-like.<br />
			<br />
			Returns : The provided array-like.<br />
			[method:IVector3 transformDirection](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IVector3 unproject](  [param:ICamera camera] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IVector3Node">IVector3Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVector3Node IVector3Node](  [param:number|IVector3 x],  [param:number y]?,  [param:number z]? ) <br />
			[constructor:IVector3Node IVector3Node](  [param:number|IVector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IVector3Node IVector3Node](  [param:number|IVector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IVector3Node IVector3Node](  [param:number|IVector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IVector3 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IVector3Node copy](  [param:IVector3Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IVector3Node setLabel](  [param:string name] ) <br />
			[method:IVector3Node setName](  [param:string name] ) <br />
			[method:IVector3Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IVector] &rarr;

		<h3 id="IVector4">IVector4 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVector4 IVector4](  [param:number x]?,  [param:number y]?,  [param:number z]?,  [param:number w]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number height] -  The height.<br />
			[property:any isVector4] -  The is vector4.<br />
			[property:number w] -  The w.<br />
			[property:number width] -  The width.<br />
			[property:number x] -  The x.<br />
			[property:number y] -  The y.<br />
			[property:number z] -  The z.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IVector4 add](  [param:IVector4|Vector4 v] ) - Adds v to this vector.<br />
			[method:IVector4 addScalar](  [param:number scalar] ) - Adds the scalar value s to this vector's values.<br />
			[method:IVector4 addScaledVector](  [param:IVector4|Vector4 v],  [param:number s] ) <br />
			[method:IVector4 addVectors](  [param:IVector4|Vector4 a],  [param:IVector4|Vector4 b] ) - Sets this vector to a + b.<br />
			[method:IVector4 applyMatrix4](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:IVector4 ceil](  ) <br />
			[method:IVector4 clamp](  [param:IVector4|Vector4 min],  [param:IVector4|Vector4 max] ) <br />
			[method:IVector4 clampScalar](  [param:number min],  [param:number max] ) <br />
			[method:IVector4 clone](  ) - Clones this vector.<br />
			[method:IVector4 copy](  [param:IVector4|Vector4 v] ) - Copies value of v to this vector.<br />
			[method:number distanceTo](  [param:IVector v] ) - NOTE: Vector4 doesn't have the property.<br />
			distanceTo(v:T):number;<br />
			[method:number distanceToSquared](  [param:IVector v] ) - NOTE: Vector4 doesn't have the property.<br />
			distanceToSquared(v:T):number;<br />
			[method:IVector4 divideScalar](  [param:number s] ) - Divides this vector by scalar s.<br />
			Set vector to ( 0, 0, 0 ) if s == 0.<br />
			[method:number dot](  [param:IVector4|Vector4 v] ) - Computes dot product of this vector and v.<br />
			[method:boolean equals](  [param:IVector4|Vector4 v] ) - Checks for strict equality of this vector and v.<br />
			[method:IVector4 floor](  ) <br />
			[method:IVector4 fromArray](  [param:number[]|ArrayLike array],  [param:number offset]? ) - Sets this vector's x, y, z and w value from the provided array or array-like.<br />
			[method:IVector4 fromBufferAttribute](  [param:IBufferAttribute attribute],  [param:number index] ) <br />
			[method:number getComponent](  [param:number index] ) <br />
			[method:number length](  ) - Computes length of this vector.<br />
			[method:number lengthSq](  ) - Computes squared length of this vector.<br />
			[method:IVector4 lerp](  [param:IVector4|Vector4 v],  [param:number alpha] ) - Linearly interpolate between this vector and v with alpha factor.<br />
			[method:IVector4 lerpVectors](  [param:IVector4|Vector4 v1],  [param:IVector4|Vector4 v2],  [param:number alpha] ) <br />
			[method:number manhattanLength](  ) - Computes the Manhattan length of this vector.<br />
			see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}<br />
			[method:IVector4 max](  [param:IVector4|Vector4 v] ) <br />
			[method:IVector4 min](  [param:IVector4|Vector4 v] ) <br />
			[method:IVector4 multiply](  [param:IVector4|Vector4 v] ) <br />
			[method:IVector4 multiplyScalar](  [param:number s] ) - Multiplies this vector by scalar s.<br />
			[method:IVector4 negate](  ) - Inverts this vector.<br />
			[method:IVector4 normalize](  ) - Normalizes this vector.<br />
			[method:IVector4 random](  ) - Sets this vector's x, y, z and w from Math.random<br />
			[method:IVector4 round](  ) <br />
			[method:IVector4 roundToZero](  ) <br />
			[method:IVector4 set](  [param:number x],  [param:number y],  [param:number z],  [param:number w] ) - Sets value of this vector.<br />
			[method:IVector4 setAxisAngleFromQuaternion](  [param:IQuaternion|Quaternion q] ) - http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm<br />
			[method:IVector4 setAxisAngleFromRotationMatrix](  [param:IMatrix4|Matrix4 m] ) - http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm<br />
			[method:IVector4 setComponent](  [param:number index],  [param:number value] ) <br />
			[method:IVector4 setLength](  [param:number length] ) - Normalizes this vector and multiplies it by l.<br />
			[method:IVector4 setScalar](  [param:number scalar] ) - Sets all values of this vector.<br />
			[method:IVector4 setW](  [param:number w] ) - Sets w component of this vector.<br />
			[method:IVector4 setX](  [param:number x] ) - Sets X component of this vector.<br />
			[method:IVector4 setY](  [param:number y] ) - Sets Y component of this vector.<br />
			[method:IVector4 setZ](  [param:number z] ) - Sets Z component of this vector.<br />
			[method:IVector4 sub](  [param:IVector4|Vector4 v] ) - Subtracts v from this vector.<br />
			[method:IVector4 subScalar](  [param:number s] ) <br />
			[method:IVector4 subVectors](  [param:IVector4|Vector4 a],  [param:IVector4|Vector4 b] ) - Sets this vector to a - b.<br />
			[method:number[] toArray](  [param:number[] array]?,  [param:number offset]? ) - Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.<br />
			<br />
			Returns : The created or provided array.<br />
			[method:Vector4Tuple toArray](  [param:number[] array]?,  [param:number offset]?,  [param:Vector4Tuple array]?,  [param:any offset]? ) <br />
			[method:ArrayLike toArray](  [param:number[] array]?,  [param:number offset]?,  [param:Vector4Tuple array]?,  [param:any offset]?,  [param:ArrayLike array],  [param:number offset]? ) - Copies x, y, z and w into the provided array-like.<br />
			<br />
			Returns : The provided array-like.
		</p>

		<p class="desc">
			4D vector.<br />
			( class Vector4 implements Vector&lt;Vector4&gt; )
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr;

		<h3 id="IVector4Node">IVector4Node <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVector4Node IVector4Node](  [param:number|IVector4 x],  [param:number y]?,  [param:number z]?,  [param:number w]? ) <br />
			[constructor:IVector4Node IVector4Node](  [param:number|IVector4 x],  [param:number y]?,  [param:number z]?,  [param:number w]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IVector4Node IVector4Node](  [param:number|IVector4 x],  [param:number y]?,  [param:number z]?,  [param:number w]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IVector4Node IVector4Node](  [param:number|IVector4 x],  [param:number y]?,  [param:number z]?,  [param:number w]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IVector4 value] -  The value.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IVector4Node copy](  [param:IVector4Node source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IVector4Node setLabel](  [param:string name] ) <br />
			[method:IVector4Node setName](  [param:string name] ) <br />
			[method:IVector4Node setReadonly](  [param:boolean value] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IKeyframeTrack] &rarr;

		<h3 id="IVectorKeyframeTrack">IVectorKeyframeTrack <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVectorKeyframeTrack IVectorKeyframeTrack](  [param:string name],  [param:any[] times],  [param:any[] values],  [param:InterpolationModes interpolation]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:InterpolationModes DefaultInterpolation] -  The default interpolation.<br />
			[property:Float32Array TimeBufferType] -  The time buffer type.<br />
			[property:Float32Array ValueBufferType] -  The value buffer type.<br />
			[property:string ValueTypeName] -  The value type name.<br />
			[property:string name] -  The name.<br />
			[property:Float32Array times] -  The times.<br />
			[property:Float32Array values] -  The values.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IDiscreteInterpolant InterpolantFactoryMethodDiscrete](  [param:any result] ) <br />
			[method:ILinearInterpolant InterpolantFactoryMethodLinear](  [param:any result] ) <br />
			[method:ICubicInterpolant InterpolantFactoryMethodSmooth](  [param:any result] ) <br />
			[method:IVectorKeyframeTrack clone](  ) <br />
			[method:InterpolationModes getInterpolation](  ) <br />
			[method:number getValueSize](  ) <br />
			[method:IKeyframeTrack optimize](  ) <br />
			[method:IKeyframeTrack scale](  [param:number timeScale] ) <br />
			[method:IKeyframeTrack setInterpolation](  [param:InterpolationModes interpolation] ) <br />
			[method:IKeyframeTrack shift](  [param:number timeOffset] ) <br />
			[method:IKeyframeTrack trim](  [param:number startTime],  [param:number endTime] ) <br />
			[method:boolean validate](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:INode] &rarr; [page:ITempNode] &rarr; [page:IInputNode] &rarr; [page:IVector3Node] &rarr;

		<h3 id="IVelocityNode">IVelocityNode <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVelocityNode IVelocityNode](  [param:IObject3D target],  [param:IVelocityNodeParams params]? ) <br />
			[constructor:IVelocityNode IVelocityNode](  [param:IObject3D target],  [param:IVelocityNodeParams params]?,  [param:number|IVector3 x],  [param:number y]?,  [param:number z]? ) <br />
			[constructor:IVelocityNode IVelocityNode](  [param:IObject3D target],  [param:IVelocityNodeParams params]?,  [param:number|IVector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IVelocityNode IVelocityNode](  [param:IObject3D target],  [param:IVelocityNodeParams params]?,  [param:number|IVector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]? ) <br />
			[constructor:IVelocityNode IVelocityNode](  [param:IObject3D target],  [param:IVelocityNodeParams params]?,  [param:number|IVector3 x],  [param:number y]?,  [param:number z]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type],  [param:ITempNodeParams params]?,  [param:string type]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number frameId] -  The frame id.<br />
			[property:string[] hashProperties] -  The hash properties.<br />
			[property:any isNode] -  The is node.<br />
			[property:string label] -  The label.<br />
			[property:IVector3 lastVelocity] -  The last velocity.<br />
			[property:IVector3 moment] -  The moment.<br />
			[property:string name] -  The name.<br />
			[property:string nodeType] -  The node type.<br />
			[property:boolean readonly] -  The readonly.<br />
			[property:boolean shared] -  The shared.<br />
			[property:IVector3 speed] -  The speed.<br />
			[property:IVector3 springVelocity] -  The spring velocity.<br />
			[property:string type] -  The type.<br />
			[property:boolean unique] -  The unique.<br />
			[property:object userData] -  The user data.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IVector3 value] -  The value.<br />
			[property:IVector3 velocity] -  The velocity.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void analyze](  [param:INodeBuilder builder],  [param:object settings]? ) <br />
			[method:INodeFlow analyzeAndFlow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:void appendDepsNode](  [param:INodeBuilder builder],  [param:object data],  [param:string output] ) <br />
			[method:string build](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string ns]? ) <br />
			[method:IVelocityNode copy](  [param:IVelocityNode source] ) <br />
			[method:object createJSONNode](  [param:string|object meta]? ) <br />
			[method:INodeFlow flow](  [param:INodeBuilder builder],  [param:string output],  [param:object settings]? ) <br />
			[method:string generate](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]? ) <br />
			[method:string generateReadonly](  [param:INodeBuilder builder],  [param:string output],  [param:string uuid]?,  [param:string type]?,  [param:string ns]?,  [param:boolean needsUpdate]? ) <br />
			[method:string getHash](  ) <br />
			[method:object getJSONNode](  [param:string|object meta]? ) <br />
			[method:string getLabel](  [param:INodeBuilder builder] ) <br />
			[method:string getName](  [param:INodeBuilder builder] ) <br />
			[method:boolean getReadonly](  [param:INodeBuilder builder] ) <br />
			[method:boolean getShared](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getTemp](  [param:INodeBuilder builder],  [param:string uuid] ) <br />
			[method:string getType](  [param:INodeBuilder builder],  [param:string output]? ) <br />
			[method:boolean getUnique](  [param:INodeBuilder builder],  [param:string output] ) <br />
			[method:string getUuid](  [param:boolean unique] ) <br />
			[method:IVelocityNode setLabel](  [param:string name] ) <br />
			[method:IVelocityNode setName](  [param:string name] ) <br />
			[method:void setParams](  [param:IVelocityNodeParams params] ) <br />
			[method:IVelocityNode setReadonly](  [param:boolean value] ) <br />
			[method:void setTarget](  [param:IObject3D target] ) <br />
			[method:object toJSON](  [param:string|object meta]? ) <br />
			[method:void updateFrame](  [param:INodeFrame frame] ) <br />
			[method:void updateFrameVelocity](  [param:INodeFrame frame] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IVelocityNodeParams">IVelocityNodeParams <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number damping] -  The damping.<br />
			[property:number spring] -  The spring.<br />
			[property:string type] -  The type.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="IVertexNormalsHelper">IVertexNormalsHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVertexNormalsHelper IVertexNormalsHelper](  [param:IObject3D object],  [param:number size]?,  [param:number hex]? ) <br />
			[constructor:IVertexNormalsHelper IVertexNormalsHelper](  [param:IObject3D object],  [param:number size]?,  [param:number hex]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IVertexNormalsHelper IVertexNormalsHelper](  [param:IObject3D object],  [param:number size]?,  [param:number hex]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IVertexNormalsHelper IVertexNormalsHelper](  [param:IObject3D object],  [param:number size]?,  [param:number hex]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D object] -  The object.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:number size] -  The size.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IVertexNormalsHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IVertexNormalsHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IVertexNormalsHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IVertexNormalsHelper clear](  ) - Removes all child objects.<br />
			[method:IVertexNormalsHelper clone](  [param:boolean recursive]? ) <br />
			[method:IVertexNormalsHelper computeLineDistances](  ) <br />
			[method:IVertexNormalsHelper copy](  [param:IVertexNormalsHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IVertexNormalsHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IVertexNormalsHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IVertexNormalsHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IVertexNormalsHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IVertexNormalsHelper rotateX](  [param:number angle] ) <br />
			[method:IVertexNormalsHelper rotateY](  [param:number angle] ) <br />
			[method:IVertexNormalsHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IVertexNormalsHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IVertexNormalsHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IVertexNormalsHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IVertexNormalsHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:ILine] &rarr; [page:ILineSegments] &rarr;

		<h3 id="IVertexTangentsHelper">IVertexTangentsHelper <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVertexTangentsHelper IVertexTangentsHelper](  [param:IObject3D object],  [param:number size]?,  [param:number hex]? ) <br />
			[constructor:IVertexTangentsHelper IVertexTangentsHelper](  [param:IObject3D object],  [param:number size]?,  [param:number hex]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IVertexTangentsHelper IVertexTangentsHelper](  [param:IObject3D object],  [param:number size]?,  [param:number hex]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IVertexTangentsHelper IVertexTangentsHelper](  [param:IObject3D object],  [param:number size]?,  [param:number hex]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isLine] -  The is line.<br />
			[property:any isLineSegments] -  The is line segments.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D object] -  The object.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:number size] -  The size.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IVertexTangentsHelper add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IVertexTangentsHelper applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IVertexTangentsHelper attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IVertexTangentsHelper clear](  ) - Removes all child objects.<br />
			[method:IVertexTangentsHelper clone](  [param:boolean recursive]? ) <br />
			[method:IVertexTangentsHelper computeLineDistances](  ) <br />
			[method:IVertexTangentsHelper copy](  [param:IVertexTangentsHelper source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IVertexTangentsHelper remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IVertexTangentsHelper removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IVertexTangentsHelper rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IVertexTangentsHelper rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IVertexTangentsHelper rotateX](  [param:number angle] ) <br />
			[method:IVertexTangentsHelper rotateY](  [param:number angle] ) <br />
			[method:IVertexTangentsHelper rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IVertexTangentsHelper translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IVertexTangentsHelper translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IVertexTangentsHelper translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IVertexTangentsHelper translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void update](  ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:ITexture] &rarr;

		<h3 id="IVideoTexture">IVideoTexture <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVideoTexture IVideoTexture](  [param:HTMLVideoElement video],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]? ) <br />
			[constructor:IVideoTexture IVideoTexture](  [param:HTMLVideoElement video],  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:HTMLCanvasElement|HTMLVideoElement|HTMLImageElement image]?,  [param:Mapping mapping]?,  [param:Wrapping wrapS]?,  [param:Wrapping wrapT]?,  [param:TextureFilter magFilter]?,  [param:TextureFilter minFilter]?,  [param:PixelFormat format]?,  [param:TextureDataType type]?,  [param:number anisotropy]?,  [param:TextureEncoding encoding]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy] -  The anisotropy.<br />
			[property:IVector2|Vector2 center] -  The center.<br />
			[property:TextureEncoding encoding] -  The encoding.<br />
			[property:boolean flipY] -  The flip y.<br />
			[property:PixelFormat format] -  The format.<br />
			[property:boolean generateMipmaps] -  The generate mipmaps.<br />
			[property:number id] -  The id.<br />
			[property:any image] -  The image.<br />
			[property:PixelFormatGPU internalFormat] -  The internal format.<br />
			[property:boolean isRenderTargetTexture] -  The is render target texture.<br />
			[property:any isTexture] -  The is texture.<br />
			[property:any isVideoTexture] -  The is video texture.<br />
			[property:TextureFilter magFilter] -  The mag filter.<br />
			[property:Mapping mapping] -  The mapping.<br />
			[property:IMatrix3|Matrix3 matrix] -  The matrix.<br />
			[property:boolean matrixAutoUpdate] -  The matrix auto update.<br />
			[property:TextureFilter minFilter] -  The min filter.<br />
			[property:any[] mipmaps] -  The mipmaps.<br />
			[property:string name] -  The name.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:IVector2|Vector2 offset] -  The offset.<br />
			[property:boolean premultiplyAlpha] -  The premultiply alpha.<br />
			[property:IVector2|Vector2 repeat] -  The repeat.<br />
			[property:number rotation] -  The rotation.<br />
			[property:string sourceFile] -  The source file.<br />
			[property:TextureDataType type] -  The type.<br />
			[property:number unpackAlignment] -  The unpack alignment.<br />
			[property:any userData] - An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:number version] -  The version.<br />
			[property:Wrapping wrapS] -  The wrap s.<br />
			[property:Wrapping wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IVideoTexture clone](  ) <br />
			[method:IVideoTexture copy](  [param:ITexture source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void onUpdate](  ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:any toJSON](  [param:any meta] ) <br />
			[method:IVector2 transformUv](  [param:IVector2|Vector2 uv] ) <br />
			[method:void updateMatrix](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IVolume">IVolume <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVolume IVolume](  [param:number xLength]?,  [param:number yLength]?,  [param:number zLength]?,  [param:string type]?,  [param:ArrayLike arrayBuffer]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any axisOrder] -  The axis order.<br />
			[property:ArrayLike data] -  The data.<br />
			[property:number lowerThreshold] -  The lower threshold.<br />
			[property:IMatrix3 matrix] -  The matrix.<br />
			[property:number[] offset] -  The offset.<br />
			[property:IVolumeSlice[] sliceList] -  The slice list.<br />
			[property:number[] spacing] -  The spacing.<br />
			[property:number upperThreshold] -  The upper threshold.<br />
			[property:number xLength] -  The x length.<br />
			[property:number yLength] -  The y length.<br />
			[property:number zLength] -  The z length.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number access](  [param:number i],  [param:number j],  [param:number k] ) <br />
			[method:number[] computeMinMax](  ) <br />
			[method:object extractPerpendicularPlane](  [param:string axis],  [param:number RASIndex] ) <br />
			[method:IVolumeSlice extractSlice](  [param:string axis],  [param:number index] ) <br />
			[method:number getData](  [param:number i],  [param:number j],  [param:number k] ) <br />
			[method:IVolume map](  [param:any functionToMap],  [param:IVolume context] ) <br />
			[method:IVolume repaintAllSlices](  ) <br />
			[method:number[] reverseAccess](  [param:number index] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IVolumeSlice">IVolumeSlice <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IVolumeSlice IVolumeSlice](  [param:IVolume volume],  [param:number index]?,  [param:string axis]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string axis] -  The axis.<br />
			[property:HTMLCanvasElement canvas] -  The canvas.<br />
			[property:HTMLCanvasElement canvasBuffer] -  The canvas buffer.<br />
			[property:CanvasRenderingContext2D ctx] -  The ctx.<br />
			[property:CanvasRenderingContext2D ctxBuffer] -  The ctx buffer.<br />
			[property:boolean geometryNeedsUpdate] -  The geometry needs update.<br />
			[property:number iLength] -  The i length.<br />
			[property:number index] -  The index.<br />
			[property:number jLength] -  The j length.<br />
			[property:IMatrix3 matrix] -  The matrix.<br />
			[property:IMesh mesh] -  The mesh.<br />
			[property:number sliceAccess] -  The slice access.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void repaint](  ) <br />
			[method:void updateGeometry](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IWater">IWater <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWater IWater](  [param:IBufferGeometry geometry],  [param:IWaterOptions options] ) <br />
			[constructor:IWater IWater](  [param:IBufferGeometry geometry],  [param:IWaterOptions options],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IWater IWater](  [param:IBufferGeometry geometry],  [param:IWaterOptions options],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IWater add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IWater applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IWater attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IWater clear](  ) - Removes all child objects.<br />
			[method:IWater clone](  [param:boolean recursive]? ) <br />
			[method:IWater copy](  [param:IWater source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IWater remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IWater removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IWater rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IWater rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IWater rotateX](  [param:number angle] ) <br />
			[method:IWater rotateY](  [param:number angle] ) <br />
			[method:IWater rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IWater translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IWater translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IWater translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IWater translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IWater2">IWater2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWater2 IWater2](  [param:IBufferGeometry geometry],  [param:IWater2Options options] ) <br />
			[constructor:IWater2 IWater2](  [param:IBufferGeometry geometry],  [param:IWater2Options options],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IWater2 IWater2](  [param:IBufferGeometry geometry],  [param:IWater2Options options],  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IShaderMaterial material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IWater2 add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IWater2 applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IWater2 attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IWater2 clear](  ) - Removes all child objects.<br />
			[method:IWater2 clone](  [param:boolean recursive]? ) <br />
			[method:IWater2 copy](  [param:IWater2 source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IWater2 remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IWater2 removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IWater2 rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IWater2 rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IWater2 rotateX](  [param:number angle] ) <br />
			[method:IWater2 rotateY](  [param:number angle] ) <br />
			[method:IWater2 rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IWater2 translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IWater2 translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IWater2 translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IWater2 translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IWater2Options">IWater2Options <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number clipBias]? -  The clip bias.<br />
			[property:any color]? -  The color.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:IVector2 flowDirection]? -  The flow direction.<br />
			[property:ITexture flowMap]? -  The flow map.<br />
			[property:number flowSpeed]? -  The flow speed.<br />
			[property:ITexture normalMap0]? -  The normal map0.<br />
			[property:ITexture normalMap1]? -  The normal map1.<br />
			[property:number reflectivity]? -  The reflectivity.<br />
			[property:number scale]? -  The scale.<br />
			[property:object shader]? -  The shader.<br />
			[property:number textureHeight]? -  The texture height.<br />
			[property:number textureWidth]? -  The texture width.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IWaterOptions">IWaterOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number alpha]? -  The alpha.<br />
			[property:number clipBias]? -  The clip bias.<br />
			[property:number distortionScale]? -  The distortion scale.<br />
			[property:IVector3 eye]? -  The eye.<br />
			[property:boolean fog]? -  The fog.<br />
			[property:Side side]? -  The side.<br />
			[property:any sunColor]? -  The sun color.<br />
			[property:IVector3 sunDirection]? -  The sun direction.<br />
			[property:number textureHeight]? -  The texture height.<br />
			[property:number textureWidth]? -  The texture width.<br />
			[property:number time]? -  The time.<br />
			[property:any waterColor]? -  The water color.<br />
			[property:ITexture waterNormals]? -  The water normals.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IRenderer] &rarr; [page:IWebGLRenderer] &rarr;

		<h3 id="IWebGL1Renderer">IWebGL1Renderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWebGL1Renderer IWebGL1Renderer](  [param:IWebGLRendererParameters parameters]? ) <br />
			[constructor:IWebGL1Renderer IWebGL1Renderer](  [param:IWebGLRendererParameters parameters]?,  [param:IWebGLRendererParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoClear] - Defines whether the renderer should automatically clear its output before rendering.<br />
			[property:boolean autoClearColor] - If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.<br />
			[property:boolean autoClearDepth] - If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.<br />
			[property:boolean autoClearStencil] - If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.<br />
			[property:WebGLCapabilities capabilities] -  The capabilities.<br />
			[property:any[] clippingPlanes] -  The clipping planes.<br />
			[property:WebGLRenderingContext context] - The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw.<br />
			[property:IWebGLDebug debug] - Debug configurations.<br />
			[property:HTMLCanvasElement domElement] - A Canvas where the renderer draws its output.<br />
			This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.<br />
			[property:WebGLExtensions extensions] -  The extensions.<br />
			[property:number gammaFactor] -  The gamma factor.<br />
			[property:WebGLInfo info] -  The info.<br />
			[property:any isWebGL1Renderer] -  The is web g l1 renderer.<br />
			[property:boolean localClippingEnabled] -  The local clipping enabled.<br />
			[property:TextureEncoding outputEncoding] - Default is LinearEncoding.<br />
			[property:boolean physicallyCorrectLights] -  The physically correct lights.<br />
			[property:number pixelRatio] -  The pixel ratio.<br />
			[property:WebGLProperties properties] -  The properties.<br />
			[property:WebGLRenderLists renderLists] -  The render lists.<br />
			[property:WebGLShadowMap shadowMap] -  The shadow map.<br />
			[property:CullFace shadowMapCullFace] -  The shadow map cull face.<br />
			[property:boolean shadowMapEnabled] -  The shadow map enabled.<br />
			[property:ShadowMapType shadowMapType] -  The shadow map type.<br />
			[property:boolean sortObjects] - Defines whether the renderer should sort objects. Default is true.<br />
			[property:WebGLState state] -  The state.<br />
			[property:ToneMapping toneMapping] -  The tone mapping.<br />
			[property:number toneMappingExposure] -  The tone mapping exposure.<br />
			[property:boolean vr] -  The vr.<br />
			[property:WebXRManager xr] -  The xr.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void animate](  [param:any callback] ) <br />
			[method:void clear](  [param:boolean color]?,  [param:boolean depth]?,  [param:boolean stencil]? ) - Tells the renderer to clear its color, depth or stencil drawing buffer(s).<br />
			Arguments default to true<br />
			[method:void clearColor](  ) <br />
			[method:void clearDepth](  ) <br />
			[method:void clearStencil](  ) <br />
			[method:void clearTarget](  [param:IWebGLRenderTarget renderTarget],  [param:boolean color],  [param:boolean depth],  [param:boolean stencil] ) <br />
			[method:void compile](  [param:IObject3D scene],  [param:ICamera camera] ) - Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering.<br />
			[method:void copyFramebufferToTexture](  [param:IVector2|Vector2 position],  [param:ITexture texture],  [param:number level]? ) - Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.<br />
			This region is defined by the size of the destination texture's mip level, offset by the input position.<br />
			[method:void copyTextureToTexture](  [param:IVector2|Vector2 position],  [param:ITexture srcTexture],  [param:ITexture dstTexture],  [param:number level]? ) - Copies srcTexture to the specified level of dstTexture, offset by the input position.<br />
			[method:void copyTextureToTexture3D](  [param:IBox3 sourceBox],  [param:IVector3 position],  [param:ITexture srcTexture],  [param:IDataTexture3D|IDataTexture2DArray dstTexture],  [param:number level]? ) - Copies the pixels of a texture in the bounds sourceBox in the desination texture starting from the given position.<br />
			[method:void dispose](  ) <br />
			[method:any enableScissorTest](  [param:any boolean] ) <br />
			[method:void forceContextLoss](  ) <br />
			[method:void forceContextRestore](  ) <br />
			[method:number getActiveCubeFace](  ) - Returns the current active cube face.<br />
			[method:number getActiveMipmapLevel](  ) - Returns the current active mipmap level.<br />
			[method:number getClearAlpha](  ) - Returns a float with the current clear alpha. Ranges from 0 to 1.<br />
			[method:IColor getClearColor](  [param:IColor target] ) - Returns a O3JS.Color instance with the current clear color.<br />
			[method:WebGLRenderingContext getContext](  ) - Return the WebGL context.<br />
			[method:any getContextAttributes](  ) <br />
			[method:IWebGLRenderTarget getCurrentRenderTarget](  ) <br />
			[method:IVector4 getCurrentViewport](  [param:IVector4|Vector4 target] ) <br />
			[method:IVector2 getDrawingBufferSize](  [param:IVector2|Vector2 target] ) <br />
			[method:number getMaxAnisotropy](  ) <br />
			[method:number getPixelRatio](  ) <br />
			[method:string getPrecision](  ) <br />
			[method:IWebGLRenderTarget getRenderTarget](  ) - Returns the current render target. If no render target is set, null is returned.<br />
			[method:IVector4 getScissor](  [param:IVector4|Vector4 target] ) - Copies the scissor area into target.<br />
			[method:boolean getScissorTest](  ) - Returns true if scissor test is enabled; returns false otherwise.<br />
			[method:IVector2 getSize](  [param:IVector2|Vector2 target] ) <br />
			[method:IVector4 getViewport](  [param:IVector4|Vector4 target] ) - Copies the viewport into target.<br />
			[method:void initTexture](  [param:ITexture texture] ) - Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).<br />
			[method:void readRenderTargetPixels](  [param:IWebGLRenderTarget|IWebGLMultipleRenderTargets renderTarget],  [param:number x],  [param:number y],  [param:number width],  [param:number height],  [param:any buffer],  [param:number activeCubeFaceIndex]? ) <br />
			[method:void render](  [param:IObject3D scene],  [param:ICamera camera] ) - Render a scene or an object using a camera.<br />
			The render is done to a previously specified {@line THREE.WebGLRenderTarget#renderTarget .renderTarget} set by calling<br />
			{@line THREE.WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.<br />
			By default render buffers are cleared before rendering but you can prevent this by setting the property<br />
			{@line THREE.WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared<br />
			you can set either the {@line THREE.WebGLRenderer#autoClearColor autoClearColor},<br />
			{@line THREE.WebGLRenderer#autoClearStencil autoClearStencil} or {@line THREE.WebGLRenderer#autoClearDepth autoClearDepth}<br />
			properties to false. To forcibly clear one ore more buffers call {@line THREE.WebGLRenderer#clear .clear}.<br />
			[method:void renderBufferDirect](  [param:ICamera camera],  [param:IScene scene],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IObject3D object],  [param:any geometryGroup] ) <br />
			[method:void resetGLState](  ) <br />
			[method:void resetState](  ) - Can be used to reset the internal WebGL state.<br />
			[method:void setAnimationLoop](  [param:TXRAnimationLoopCallback callback] ) - A build in function that can be used instead of requestAnimationFrame. For WebXR projects this function must be used.<br />
			[method:void setClearAlpha](  [param:number alpha] ) <br />
			[method:void setClearColor](  [param:any color],  [param:number alpha]? ) - Sets the clear color, using color for the color and alpha for the opacity.<br />
			[method:void setDrawingBufferSize](  [param:number width],  [param:number height],  [param:number pixelRatio] ) <br />
			[method:void setOpaqueSort](  [param:any method] ) - Sets the custom opaque sort function for the WebGLRenderLists. Pass null to use the default painterSortStable function.<br />
			[method:void setPixelRatio](  [param:number value] ) <br />
			[method:void setRenderTarget](  [param:IWebGLRenderTarget|IWebGLMultipleRenderTargets renderTarget],  [param:number activeCubeFace]?,  [param:number activeMipmapLevel]? ) - Sets the active render target.<br />
			[method:void setScissor](  [param:number|IVector4|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) - Sets the scissor area from (x, y) to (x + width, y + height).<br />
			[method:void setScissorTest](  [param:boolean enable] ) - Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:boolean updateStyle]? ) - Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).<br />
			[method:void setTransparentSort](  [param:any method] ) - Sets the custom transparent sort function for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.<br />
			[method:void setViewport](  [param:number|IVector4|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) - Sets the viewport to render from (x, y) to (x + width, y + height).<br />
			(x, y) is the lower-left corner of the region.<br />
			[method:any supportsBlendMinMax](  ) <br />
			[method:any supportsCompressedTexturePVRTC](  ) <br />
			[method:any supportsCompressedTextureS3TC](  ) <br />
			[method:any supportsFloatTextures](  ) <br />
			[method:any supportsHalfFloatTextures](  ) <br />
			[method:any supportsInstancedArrays](  ) <br />
			[method:any supportsStandardDerivatives](  ) <br />
			[method:any supportsVertexTextures](  ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IWebGLCapabilities">IWebGLCapabilities <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWebGLCapabilities IWebGLCapabilities](  [param:WebGLRenderingContext gl],  [param:any extensions],  [param:IWebGLCapabilitiesParameters parameters] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean floatFragmentTextures] -  The float fragment textures.<br />
			[property:boolean floatVertexTextures] -  The float vertex textures.<br />
			[property:boolean isWebGL2] -  The is web g l2.<br />
			[property:boolean logarithmicDepthBuffer] -  The logarithmic depth buffer.<br />
			[property:number maxAttributes] -  The max attributes.<br />
			[property:number maxCubemapSize] -  The max cubemap size.<br />
			[property:number maxFragmentUniforms] -  The max fragment uniforms.<br />
			[property:number maxTextureSize] -  The max texture size.<br />
			[property:number maxTextures] -  The max textures.<br />
			[property:number maxVaryings] -  The max varyings.<br />
			[property:number maxVertexTextures] -  The max vertex textures.<br />
			[property:number maxVertexUniforms] -  The max vertex uniforms.<br />
			[property:string precision] -  The precision.<br />
			[property:boolean vertexTextures] -  The vertex textures.
		</p>
		<h4>Methods</h4>
		<p>
			[method:number getMaxAnisotropy](  ) <br />
			[method:string getMaxPrecision](  [param:string precision] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IWebGLCapabilitiesParameters">IWebGLCapabilitiesParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean logarithmicDepthBuffer]? -  The logarithmic depth buffer.<br />
			[property:string precision]? -  The precision.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IWebGLRenderTarget] &rarr;

		<h3 id="IWebGLCubeRenderTarget">IWebGLCubeRenderTarget <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWebGLCubeRenderTarget IWebGLCubeRenderTarget](  [param:number size],  [param:IWebGLRenderTargetOptions options]? ) <br />
			[constructor:IWebGLCubeRenderTarget IWebGLCubeRenderTarget](  [param:number size],  [param:IWebGLRenderTargetOptions options]?,  [param:number width],  [param:number height],  [param:IWebGLRenderTargetOptions options]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any anisotropy] -  The anisotropy.<br />
			[property:number depth] -  The depth.<br />
			[property:boolean depthBuffer] -  The depth buffer.<br />
			[property:IDepthTexture depthTexture] -  The depth texture.<br />
			[property:any format] -  The format.<br />
			[property:any generateMipmaps] -  The generate mipmaps.<br />
			[property:number height] -  The height.<br />
			[property:any isWebGLRenderTarget] -  The is web g l render target.<br />
			[property:any magFilter] -  The mag filter.<br />
			[property:any minFilter] -  The min filter.<br />
			[property:any offset] -  The offset.<br />
			[property:any repeat] -  The repeat.<br />
			[property:IVector4 scissor] -  The scissor.<br />
			[property:boolean scissorTest] -  The scissor test.<br />
			[property:boolean stencilBuffer] -  The stencil buffer.<br />
			[property:ICubeTexture texture] -  The texture.<br />
			[property:any type] -  The type.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IVector4 viewport] -  The viewport.<br />
			[property:number width] -  The width.<br />
			[property:any wrapS] -  The wrap s.<br />
			[property:any wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void clear](  [param:IWebGLRenderer renderer],  [param:boolean color],  [param:boolean depth],  [param:boolean stencil] ) <br />
			[method:IWebGLCubeRenderTarget clone](  ) <br />
			[method:IWebGLCubeRenderTarget copy](  [param:IWebGLRenderTarget source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:IWebGLCubeRenderTarget fromEquirectangularTexture](  [param:IWebGLRenderer renderer],  [param:ITexture texture] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:number depth]? ) <br />
			[method:void setTexture](  [param:ITexture texture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IWebGLDebug">IWebGLDebug <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean checkShaderErrors] - Enables error checking and reporting when shader programs are being compiled.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IWebGLMultipleRenderTargets">IWebGLMultipleRenderTargets <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWebGLMultipleRenderTargets IWebGLMultipleRenderTargets](  [param:number width],  [param:number height],  [param:number count] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any isWebGLMultipleRenderTargets] -  The is web g l multiple render targets.<br />
			[property:ITexture[] texture] -  The texture.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IWebGLMultipleRenderTargets clone](  ) <br />
			[method:IWebGLMultipleRenderTargets copy](  [param:IWebGLMultipleRenderTargets source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IWebGLMultipleRenderTargets setSize](  [param:number width],  [param:number height],  [param:number depth]? ) <br />
			[method:void setTexture](  [param:ITexture texture] ) 
		</p>

		<p class="desc">
			This class originall extended WebGLMultipleRenderTarget<br />
			However, there are some issues with this method as documented below
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IWebGLRenderTarget] &rarr;

		<h3 id="IWebGLMultisampleRenderTarget">IWebGLMultisampleRenderTarget <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWebGLMultisampleRenderTarget IWebGLMultisampleRenderTarget](  [param:number width],  [param:number height],  [param:IWebGLRenderTargetOptions options]? ) <br />
			[constructor:IWebGLMultisampleRenderTarget IWebGLMultisampleRenderTarget](  [param:number width],  [param:number height],  [param:IWebGLRenderTargetOptions options]?,  [param:number width],  [param:number height],  [param:IWebGLRenderTargetOptions options]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any anisotropy] -  The anisotropy.<br />
			[property:number depth] -  The depth.<br />
			[property:boolean depthBuffer] -  The depth buffer.<br />
			[property:IDepthTexture depthTexture] -  The depth texture.<br />
			[property:any format] -  The format.<br />
			[property:any generateMipmaps] -  The generate mipmaps.<br />
			[property:number height] -  The height.<br />
			[property:any isWebGLMultisampleRenderTarget] -  The is web g l multisample render target.<br />
			[property:any isWebGLRenderTarget] -  The is web g l render target.<br />
			[property:any magFilter] -  The mag filter.<br />
			[property:any minFilter] -  The min filter.<br />
			[property:any offset] -  The offset.<br />
			[property:any repeat] -  The repeat.<br />
			[property:number samples] - Specifies the number of samples to be used for the renderbuffer storage.However, the maximum supported size for multisampling is platform dependent and defined via gl.MAX_SAMPLES.<br />
			[property:IVector4 scissor] -  The scissor.<br />
			[property:boolean scissorTest] -  The scissor test.<br />
			[property:boolean stencilBuffer] -  The stencil buffer.<br />
			[property:ITexture texture] -  The texture.<br />
			[property:any type] -  The type.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IVector4 viewport] -  The viewport.<br />
			[property:number width] -  The width.<br />
			[property:any wrapS] -  The wrap s.<br />
			[property:any wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IWebGLMultisampleRenderTarget clone](  ) <br />
			[method:IWebGLMultisampleRenderTarget copy](  [param:IWebGLRenderTarget source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:number depth]? ) <br />
			[method:void setTexture](  [param:ITexture texture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IWebGLObjects">IWebGLObjects <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWebGLObjects IWebGLObjects](  [param:WebGLRenderingContext gl],  [param:any geometries],  [param:any attributes],  [param:any info] ) 
		</p>
		<h4>Methods</h4>
		<p>
			[method:void dispose](  ) <br />
			[method:any update](  [param:any object] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr;

		<h3 id="IWebGLRenderTarget">IWebGLRenderTarget <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWebGLRenderTarget IWebGLRenderTarget](  [param:number width],  [param:number height],  [param:IWebGLRenderTargetOptions options]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any anisotropy] -  The anisotropy.<br />
			[property:number depth] -  The depth.<br />
			[property:boolean depthBuffer] -  The depth buffer.<br />
			[property:IDepthTexture depthTexture] -  The depth texture.<br />
			[property:any format] -  The format.<br />
			[property:any generateMipmaps] -  The generate mipmaps.<br />
			[property:number height] -  The height.<br />
			[property:any isWebGLRenderTarget] -  The is web g l render target.<br />
			[property:any magFilter] -  The mag filter.<br />
			[property:any minFilter] -  The min filter.<br />
			[property:any offset] -  The offset.<br />
			[property:any repeat] -  The repeat.<br />
			[property:IVector4 scissor] -  The scissor.<br />
			[property:boolean scissorTest] -  The scissor test.<br />
			[property:boolean stencilBuffer] -  The stencil buffer.<br />
			[property:ITexture texture] -  The texture.<br />
			[property:any type] -  The type.<br />
			[property:string uuid] -  The uuid.<br />
			[property:IVector4 viewport] -  The viewport.<br />
			[property:number width] -  The width.<br />
			[property:any wrapS] -  The wrap s.<br />
			[property:any wrapT] -  The wrap t.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:IWebGLRenderTarget clone](  ) <br />
			[method:IWebGLRenderTarget copy](  [param:IWebGLRenderTarget source] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:number depth]? ) <br />
			[method:void setTexture](  [param:ITexture texture] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IWebGLRenderTargetOptions">IWebGLRenderTargetOptions <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:number anisotropy]? -  The anisotropy.<br />
			[property:boolean depthBuffer]? -  The depth buffer.<br />
			[property:IDepthTexture depthTexture]? -  The depth texture.<br />
			[property:TextureEncoding encoding]? -  The encoding.<br />
			[property:number format]? -  The format.<br />
			[property:boolean generateMipmaps]? -  The generate mipmaps.<br />
			[property:TextureFilter magFilter]? -  The mag filter.<br />
			[property:TextureFilter minFilter]? -  The min filter.<br />
			[property:boolean stencilBuffer]? -  The stencil buffer.<br />
			[property:TextureDataType type]? -  The type.<br />
			[property:Wrapping wrapS]? -  The wrap s.<br />
			[property:Wrapping wrapT]? -  The wrap t.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IRenderer] &rarr;

		<h3 id="IWebGLRenderer">IWebGLRenderer <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWebGLRenderer IWebGLRenderer](  [param:IWebGLRendererParameters parameters]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoClear] - Defines whether the renderer should automatically clear its output before rendering.<br />
			[property:boolean autoClearColor] - If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.<br />
			[property:boolean autoClearDepth] - If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.<br />
			[property:boolean autoClearStencil] - If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.<br />
			[property:WebGLCapabilities capabilities] -  The capabilities.<br />
			[property:any[] clippingPlanes] -  The clipping planes.<br />
			[property:WebGLRenderingContext context] - The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw.<br />
			[property:IWebGLDebug debug] - Debug configurations.<br />
			[property:HTMLCanvasElement domElement] - A Canvas where the renderer draws its output.<br />
			This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.<br />
			[property:WebGLExtensions extensions] -  The extensions.<br />
			[property:number gammaFactor] -  The gamma factor.<br />
			[property:WebGLInfo info] -  The info.<br />
			[property:boolean localClippingEnabled] -  The local clipping enabled.<br />
			[property:TextureEncoding outputEncoding] - Default is LinearEncoding.<br />
			[property:boolean physicallyCorrectLights] -  The physically correct lights.<br />
			[property:number pixelRatio] -  The pixel ratio.<br />
			[property:WebGLProperties properties] -  The properties.<br />
			[property:WebGLRenderLists renderLists] -  The render lists.<br />
			[property:WebGLShadowMap shadowMap] -  The shadow map.<br />
			[property:CullFace shadowMapCullFace] -  The shadow map cull face.<br />
			[property:boolean shadowMapEnabled] -  The shadow map enabled.<br />
			[property:ShadowMapType shadowMapType] -  The shadow map type.<br />
			[property:boolean sortObjects] - Defines whether the renderer should sort objects. Default is true.<br />
			[property:WebGLState state] -  The state.<br />
			[property:ToneMapping toneMapping] -  The tone mapping.<br />
			[property:number toneMappingExposure] -  The tone mapping exposure.<br />
			[property:boolean vr] -  The vr.<br />
			[property:WebXRManager xr] -  The xr.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void animate](  [param:any callback] ) <br />
			[method:void clear](  [param:boolean color]?,  [param:boolean depth]?,  [param:boolean stencil]? ) - Tells the renderer to clear its color, depth or stencil drawing buffer(s).<br />
			Arguments default to true<br />
			[method:void clearColor](  ) <br />
			[method:void clearDepth](  ) <br />
			[method:void clearStencil](  ) <br />
			[method:void clearTarget](  [param:IWebGLRenderTarget renderTarget],  [param:boolean color],  [param:boolean depth],  [param:boolean stencil] ) <br />
			[method:void compile](  [param:IObject3D scene],  [param:ICamera camera] ) - Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering.<br />
			[method:void copyFramebufferToTexture](  [param:IVector2|Vector2 position],  [param:ITexture texture],  [param:number level]? ) - Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.<br />
			This region is defined by the size of the destination texture's mip level, offset by the input position.<br />
			[method:void copyTextureToTexture](  [param:IVector2|Vector2 position],  [param:ITexture srcTexture],  [param:ITexture dstTexture],  [param:number level]? ) - Copies srcTexture to the specified level of dstTexture, offset by the input position.<br />
			[method:void copyTextureToTexture3D](  [param:IBox3 sourceBox],  [param:IVector3 position],  [param:ITexture srcTexture],  [param:IDataTexture3D|IDataTexture2DArray dstTexture],  [param:number level]? ) - Copies the pixels of a texture in the bounds sourceBox in the desination texture starting from the given position.<br />
			[method:void dispose](  ) <br />
			[method:any enableScissorTest](  [param:any boolean] ) <br />
			[method:void forceContextLoss](  ) <br />
			[method:void forceContextRestore](  ) <br />
			[method:number getActiveCubeFace](  ) - Returns the current active cube face.<br />
			[method:number getActiveMipmapLevel](  ) - Returns the current active mipmap level.<br />
			[method:number getClearAlpha](  ) - Returns a float with the current clear alpha. Ranges from 0 to 1.<br />
			[method:IColor getClearColor](  [param:IColor target] ) - Returns a O3JS.Color instance with the current clear color.<br />
			[method:WebGLRenderingContext getContext](  ) - Return the WebGL context.<br />
			[method:any getContextAttributes](  ) <br />
			[method:IWebGLRenderTarget getCurrentRenderTarget](  ) <br />
			[method:IVector4 getCurrentViewport](  [param:IVector4|Vector4 target] ) <br />
			[method:IVector2 getDrawingBufferSize](  [param:IVector2|Vector2 target] ) <br />
			[method:number getMaxAnisotropy](  ) <br />
			[method:number getPixelRatio](  ) <br />
			[method:string getPrecision](  ) <br />
			[method:IWebGLRenderTarget getRenderTarget](  ) - Returns the current render target. If no render target is set, null is returned.<br />
			[method:IVector4 getScissor](  [param:IVector4|Vector4 target] ) - Copies the scissor area into target.<br />
			[method:boolean getScissorTest](  ) - Returns true if scissor test is enabled; returns false otherwise.<br />
			[method:IVector2 getSize](  [param:IVector2|Vector2 target] ) <br />
			[method:IVector4 getViewport](  [param:IVector4|Vector4 target] ) - Copies the viewport into target.<br />
			[method:void initTexture](  [param:ITexture texture] ) - Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).<br />
			[method:void readRenderTargetPixels](  [param:IWebGLRenderTarget|IWebGLMultipleRenderTargets renderTarget],  [param:number x],  [param:number y],  [param:number width],  [param:number height],  [param:any buffer],  [param:number activeCubeFaceIndex]? ) <br />
			[method:void render](  [param:IObject3D scene],  [param:ICamera camera] ) - Render a scene or an object using a camera.<br />
			The render is done to a previously specified {@line THREE.WebGLRenderTarget#renderTarget .renderTarget} set by calling<br />
			{@line THREE.WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.<br />
			By default render buffers are cleared before rendering but you can prevent this by setting the property<br />
			{@line THREE.WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared<br />
			you can set either the {@line THREE.WebGLRenderer#autoClearColor autoClearColor},<br />
			{@line THREE.WebGLRenderer#autoClearStencil autoClearStencil} or {@line THREE.WebGLRenderer#autoClearDepth autoClearDepth}<br />
			properties to false. To forcibly clear one ore more buffers call {@line THREE.WebGLRenderer#clear .clear}.<br />
			[method:void renderBufferDirect](  [param:ICamera camera],  [param:IScene scene],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IObject3D object],  [param:any geometryGroup] ) <br />
			[method:void resetGLState](  ) <br />
			[method:void resetState](  ) - Can be used to reset the internal WebGL state.<br />
			[method:void setAnimationLoop](  [param:TXRAnimationLoopCallback callback] ) - A build in function that can be used instead of requestAnimationFrame. For WebXR projects this function must be used.<br />
			[method:void setClearAlpha](  [param:number alpha] ) <br />
			[method:void setClearColor](  [param:any color],  [param:number alpha]? ) - Sets the clear color, using color for the color and alpha for the opacity.<br />
			[method:void setDrawingBufferSize](  [param:number width],  [param:number height],  [param:number pixelRatio] ) <br />
			[method:void setOpaqueSort](  [param:any method] ) - Sets the custom opaque sort function for the WebGLRenderLists. Pass null to use the default painterSortStable function.<br />
			[method:void setPixelRatio](  [param:number value] ) <br />
			[method:void setRenderTarget](  [param:IWebGLRenderTarget|IWebGLMultipleRenderTargets renderTarget],  [param:number activeCubeFace]?,  [param:number activeMipmapLevel]? ) - Sets the active render target.<br />
			[method:void setScissor](  [param:number|IVector4|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) - Sets the scissor area from (x, y) to (x + width, y + height).<br />
			[method:void setScissorTest](  [param:boolean enable] ) - Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.<br />
			[method:void setSize](  [param:number width],  [param:number height],  [param:boolean updateStyle]? ) - Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).<br />
			[method:void setTransparentSort](  [param:any method] ) - Sets the custom transparent sort function for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.<br />
			[method:void setViewport](  [param:number|IVector4|Vector4 x],  [param:number y]?,  [param:number width]?,  [param:number height]? ) - Sets the viewport to render from (x, y) to (x + width, y + height).<br />
			(x, y) is the lower-left corner of the region.<br />
			[method:any supportsBlendMinMax](  ) <br />
			[method:any supportsCompressedTexturePVRTC](  ) <br />
			[method:any supportsCompressedTextureS3TC](  ) <br />
			[method:any supportsFloatTextures](  ) <br />
			[method:any supportsHalfFloatTextures](  ) <br />
			[method:any supportsInstancedArrays](  ) <br />
			[method:any supportsStandardDerivatives](  ) <br />
			[method:any supportsVertexTextures](  ) 
		</p>

		<p class="desc">
			The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.<br />
			This renderer has way better performance than CanvasRenderer.<br />
			see {@link https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js|src/renderers/WebGLRenderer.js}
		</p>

		<hr class="interface-line"/>
		<h3 id="IWebGLRendererParameters">IWebGLRendererParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Properties</h4>
		<p>
			[property:boolean alpha]? - default is false.<br />
			[property:boolean antialias]? - default is false.<br />
			[property:HTMLCanvasElement|IOffscreenCanvas canvas]? - A Canvas where the renderer draws its output.<br />
			[property:WebGLRenderingContext context]? - A WebGL Rendering Context.<br />
			(https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)<br />
			Default is null<br />
			[property:boolean depth]? - default is true.<br />
			[property:boolean failIfMajorPerformanceCaveat]? - default is false.<br />
			[property:boolean logarithmicDepthBuffer]? - default is false.<br />
			[property:string powerPreference]? - Can be "high-performance", "low-power" or "default"<br />
			[property:string precision]? - shader precision. Can be "highp", "mediump" or "lowp".<br />
			[property:boolean premultipliedAlpha]? - default is true.<br />
			[property:boolean preserveDrawingBuffer]? - default is false.<br />
			[property:boolean stencil]? - default is true.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IWebGLShadowMap">IWebGLShadowMap <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWebGLShadowMap IWebGLShadowMap](  [param:IWebGLRenderer _renderer],  [param:IWebGLObjects _objects],  [param:IWebGLCapabilities _capabilities] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:boolean autoUpdate] -  The auto update.<br />
			[property:boolean enabled] -  The enabled.<br />
			[property:boolean needsUpdate] -  The needs update.<br />
			[property:ShadowMapType type] -  The type.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void render](  [param:ILight[] shadowsArray],  [param:IScene scene],  [param:ICamera camera] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IObject3D] &rarr; [page:IMesh] &rarr;

		<h3 id="IWireframe">IWireframe <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWireframe IWireframe](  [param:ILineSegmentsGeometry geometry]?,  [param:ILineMaterial material]? ) <br />
			[constructor:IWireframe IWireframe](  [param:ILineSegmentsGeometry geometry]?,  [param:ILineMaterial material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) <br />
			[constructor:IWireframe IWireframe](  [param:ILineSegmentsGeometry geometry]?,  [param:ILineMaterial material]?,  [param:IBufferGeometry geometry]?,  [param:IMaterial|IMaterial[] material]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:IAnimationClip[] animations] - Array with animation clips.<br />
			[property:boolean castShadow] - Gets rendered into shadow map.<br />
			[property:IObject3D[] children] - Array with object's children.<br />
			[property:IMaterial customDepthMaterial] - Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.<br />
			When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in<br />
			the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a<br />
			transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.<br />
			[property:IMaterial customDistanceMaterial] - Same as customDepthMaterial, but used with PointLight.<br />
			[property:boolean frustumCulled] - When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.<br />
			If set to false the object gets rendered every frame even if it is not in the frustum of the camera.<br />
			[property:IBufferGeometry geometry] -  The geometry.<br />
			[property:number id] - Unique number of this object instance.<br />
			[property:any isMesh] -  The is mesh.<br />
			[property:any isObject3D] - Used to check whether this or derived classes are Object3Ds. Default is true.<br />
			You should not change this, as it is used internally for optimisation.<br />
			[property:any isWireframe] -  The is wireframe.<br />
			[property:ILayers layers] -  The layers.<br />
			[property:IMaterial|IMaterial[] material] -  The material.<br />
			[property:IMatrix4 matrix] - Local transform.<br />
			[property:boolean matrixAutoUpdate] - When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also<br />
			recalculates the matrixWorld property.<br />
			[property:IMatrix4 matrixWorld] - The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.<br />
			[property:boolean matrixWorldNeedsUpdate] - When this is set, it calculates the matrixWorld in that frame and resets this property to false.<br />
			[property:IMatrix4 modelViewMatrix] -  The model view matrix.<br />
			[property:any morphTargetDictionary]? -  The morph target dictionary.<br />
			[property:number[] morphTargetInfluences]? -  The morph target influences.<br />
			[property:string name] - Optional name of the object (doesn't need to be unique).<br />
			[property:IMatrix3 normalMatrix] -  The normal matrix.<br />
			[property:IObject3D parent] - Object's parent in the scene graph.<br />
			[property:IVector3 position] - Object's local position.<br />
			[property:IQuaternion quaternion] - Object's local rotation as a Quaternion.<br />
			[property:boolean receiveShadow] - Material gets baked in shadow receiving.<br />
			[property:number renderOrder] - Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder.<br />
			Opaque and transparent objects remain sorted independently though.<br />
			When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.<br />
			[property:IEuler rotation] - Object's local rotation (Euler angles), in radians.<br />
			[property:IVector3 scale] - Object's local scale.<br />
			[property:string type] -  The type.<br />
			[property:IVector3 up] - Up direction.<br />
			[property:any userData] - An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.<br />
			[property:string uuid] -  The uuid.<br />
			[property:boolean visible] - Object gets rendered if true.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IWireframe add](  [param:IObject3D[] object] ) - Adds object as child of this object.<br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void applyMatrix4](  [param:IMatrix4 matrix] ) - This updates the position, rotation and scale with the matrix.<br />
			[method:IWireframe applyQuaternion](  [param:IQuaternion|Quaternion quaternion] ) <br />
			[method:IWireframe attach](  [param:IObject3D object] ) - Adds object as a child of this, while maintaining the object's world transform.<br />
			[method:IWireframe clear](  ) - Removes all child objects.<br />
			[method:IWireframe clone](  [param:boolean recursive]? ) <br />
			[method:IWireframe computeLineDistances](  ) <br />
			[method:IWireframe copy](  [param:IWireframe source],  [param:boolean recursive]? ) <br />
			[method:void dispatchEvent](  [param:IEvent event] ) - Fire an event type.<br />
			[method:IObject3D getObjectById](  [param:number id] ) - Searches through the object's children and returns the first with a matching id.<br />
			[method:IObject3D getObjectByName](  [param:string name] ) - Searches through the object's children and returns the first with a matching name.<br />
			[method:IObject3D getObjectByProperty](  [param:string name],  [param:string value] ) <br />
			[method:IVector3 getWorldDirection](  [param:IVector3|Vector3 target] ) <br />
			[method:IVector3 getWorldPosition](  [param:IVector3|Vector3 target] ) <br />
			[method:IQuaternion|Quaternion getWorldQuaternion](  [param:IQuaternion|Quaternion target] ) <br />
			[method:IVector3 getWorldScale](  [param:IVector3|Vector3 target] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:IVector3 localToWorld](  [param:IVector3|Vector3 vector] ) - Updates the vector from local space to world space.<br />
			[method:void lookAt](  [param:number|IVector3|Vector3 vector],  [param:number y]?,  [param:number z]? ) - Rotates object to face point in space.<br />
			[method:void onAfterRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls after rendering object<br />
			[method:void onBeforeRender](  [param:IWebGLRenderer renderer],  [param:IScene scene],  [param:ICamera camera],  [param:IBufferGeometry geometry],  [param:IMaterial material],  [param:IGroup group] ) - Calls before rendering object<br />
			[method:void raycast](  [param:IRaycaster raycaster],  [param:IIntersection[] intersects] ) <br />
			[method:IWireframe remove](  [param:IObject3D[] object] ) - Removes object as child of this object.<br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IWireframe removeFromParent](  ) - Removes this object from its current parent.<br />
			[method:IWireframe rotateOnAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in object space. The axis is assumed to be normalized.<br />
			[method:IWireframe rotateOnWorldAxis](  [param:IVector3|Vector3 axis],  [param:number angle] ) - Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.<br />
			[method:IWireframe rotateX](  [param:number angle] ) <br />
			[method:IWireframe rotateY](  [param:number angle] ) <br />
			[method:IWireframe rotateZ](  [param:number angle] ) <br />
			[method:void setRotationFromAxisAngle](  [param:IVector3|Vector3 axis],  [param:number angle] ) <br />
			[method:void setRotationFromEuler](  [param:IEuler|Euler euler] ) <br />
			[method:void setRotationFromMatrix](  [param:IMatrix4|Matrix4 m] ) <br />
			[method:void setRotationFromQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:any toJSON](  [param:any meta]? ) <br />
			[method:IWireframe translateOnAxis](  [param:IVector3|Vector3 axis],  [param:number distance] ) <br />
			[method:IWireframe translateX](  [param:number distance] ) - Translates object along x axis by distance.<br />
			[method:IWireframe translateY](  [param:number distance] ) - Translates object along y axis by distance.<br />
			[method:IWireframe translateZ](  [param:number distance] ) - Translates object along z axis by distance.<br />
			[method:void traverse](  [param:any callback] ) <br />
			[method:void traverseAncestors](  [param:any callback] ) <br />
			[method:void traverseVisible](  [param:any callback] ) <br />
			[method:void updateMatrix](  ) - Updates local transform.<br />
			[method:void updateMatrixWorld](  [param:boolean force]? ) - Updates global transform of the object and its children.<br />
			[method:void updateMorphTargets](  ) <br />
			[method:void updateWorldMatrix](  [param:boolean updateParents],  [param:boolean updateChildren] ) <br />
			[method:IVector3 worldToLocal](  [param:IVector3|Vector3 vector] ) - Updates the vector from world space to local space.
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr;

		<h3 id="IWireframeGeometry">IWireframeGeometry <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWireframeGeometry IWireframeGeometry](  [param:TBufferGeometry geometry]? ) <br />
			[constructor:IWireframeGeometry IWireframeGeometry](  [param:TBufferGeometry geometry]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:any parameters] -  The parameters.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number materialIndex]? ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IBufferGeometry applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IWireframeGeometry copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:IEventDispatcher] &rarr; [page:IBufferGeometry] &rarr; [page:IInstancedBufferGeometry] &rarr; [page:ILineSegmentsGeometry] &rarr;

		<h3 id="IWireframeGeometry2">IWireframeGeometry2 <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IWireframeGeometry2 IWireframeGeometry2](  [param:IBufferGeometry geometry] ) <br />
			[constructor:IWireframeGeometry2 IWireframeGeometry2](  [param:IBufferGeometry geometry],  [param:IBufferGeometry geometry] ) <br />
			[constructor:IWireframeGeometry2 IWireframeGeometry2](  [param:IBufferGeometry geometry],  [param:IBufferGeometry geometry] ) <br />
			[constructor:IWireframeGeometry2 IWireframeGeometry2](  [param:IBufferGeometry geometry],  [param:IBufferGeometry geometry] ) <br />
			[constructor:IWireframeGeometry2 IWireframeGeometry2](  [param:IBufferGeometry geometry],  [param:IBufferGeometry geometry] ) <br />
			[constructor:IWireframeGeometry2 IWireframeGeometry2](  [param:IBufferGeometry geometry],  [param:IBufferGeometry geometry] ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:any attributes] -  The attributes.<br />
			[property:IBox3 boundingBox] -  The bounding box.<br />
			[property:ISphere boundingSphere] -  The bounding sphere.<br />
			[property:any drawRange] -  The draw range.<br />
			[property:any drawcalls] -  The drawcalls.<br />
			[property:any groups] -  The groups.<br />
			[property:number id] - Unique number of this buffergeometry instance<br />
			[property:IBufferAttribute index] -  The index.<br />
			[property:number instanceCount] -  The instance count.<br />
			[property:any isBufferGeometry] -  The is buffer geometry.<br />
			[property:boolean isInstancedBufferGeometry] -  The is instanced buffer geometry.<br />
			[property:any isLineSegmentsGeometry] -  The is line segments geometry.<br />
			[property:any morphAttributes] -  The morph attributes.<br />
			[property:boolean morphTargetsRelative] -  The morph targets relative.<br />
			[property:string name] -  The name.<br />
			[property:any offsets] -  The offsets.<br />
			[property:boolean sWireframeGeometry2] -  The s wireframe geometry2.<br />
			[property:string type] -  The type.<br />
			[property:any userData] -  The user data.<br />
			[property:string uuid] -  The uuid.
		</p>
		<h4>Methods</h4>
		<p>
			[method:IBufferGeometry addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:any addAttribute](  [param:string name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] ) <br />
			[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? ) <br />
			[method:void addEventListener](  [param:T type],  [param:IEventListener listener] ) - Adds a listener to an event type.<br />
			[method:void addGroup](  [param:number start],  [param:number count],  [param:number instances] ) <br />
			[method:void addIndex](  [param:any index] ) <br />
			[method:IWireframeGeometry2 applyMatrix4](  [param:IMatrix4 matrix] ) - Bakes matrix transform directly into vertex coordinates.<br />
			[method:IBufferGeometry applyQuaternion](  [param:IQuaternion|Quaternion q] ) <br />
			[method:IBufferGeometry center](  ) <br />
			[method:void clearDrawCalls](  ) <br />
			[method:void clearGroups](  ) <br />
			[method:IBufferGeometry clone](  ) <br />
			[method:void computeBoundingBox](  ) - Computes bounding box of the geometry, updating Geometry.boundingBox attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeBoundingSphere](  ) - Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.<br />
			Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.<br />
			[method:void computeTangents](  ) - Computes and adds tangent attribute to this geometry.<br />
			[method:void computeVertexNormals](  ) - Computes vertex normals by averaging face normals.<br />
			[method:IWireframeGeometry2 copy](  [param:IBufferGeometry source] ) <br />
			[method:IBufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:void dispatchEvent](  [param:Event event] ) - Fire an event type.<br />
			[method:void dispose](  ) - Disposes the object from memory.<br />
			You need to call this when you want the bufferGeometry removed while the application is running.<br />
			[method:IWireframeGeometry2 fromEdgesGeometry](  [param:IEdgesGeometry geometry] ) <br />
			[method:IWireframeGeometry2 fromLineSegments](  [param:ILineSegments lineSegments] ) <br />
			[method:IWireframeGeometry2 fromMesh](  [param:IMesh mesh] ) <br />
			[method:IWireframeGeometry2 fromWireframeGeometry](  [param:IWireframeGeometry geometry] ) <br />
			[method:IBufferAttribute|IInterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:IBufferAttribute getIndex](  ) <br />
			[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] ) <br />
			[method:boolean hasEventListener](  [param:T type],  [param:IEventListener listener] ) - Checks if listener is added to an event type.<br />
			[method:void lookAt](  [param:IVector3|Vector3 v] ) <br />
			[method:IBufferGeometry merge](  [param:IBufferGeometry geometry],  [param:number offset]? ) <br />
			[method:void normalizeNormals](  ) <br />
			[method:IBufferGeometry removeAttribute](  [param:string name] ) <br />
			[method:void removeEventListener](  [param:T type],  [param:IEventListener listener] ) - Removes a listener from an event type.<br />
			[method:IBufferGeometry rotateX](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateY](  [param:number angle] ) <br />
			[method:IBufferGeometry rotateZ](  [param:number angle] ) <br />
			[method:IBufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] ) <br />
			[method:IBufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:IBufferAttribute|IInterleavedBufferAttribute attribute] ) <br />
			[method:IWireframeGeometry2 setColors](  [param:Float32Array|number[] array] ) <br />
			[method:void setDrawRange](  [param:number start],  [param:number count] ) <br />
			[method:IBufferGeometry setFromPoints](  [param: points] ) <br />
			[method:IBufferGeometry setIndex](  [param:number[]|IBufferAttribute index] ) <br />
			[method:IWireframeGeometry2 setPositions](  [param:Float32Array|number[] array] ) <br />
			[method:any toJSON](  ) <br />
			[method:IBufferGeometry toNonIndexed](  ) <br />
			[method:IBufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		[page:ILoader] &rarr;

		<h3 id="IXYZLoader">IXYZLoader <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>Constructor</h4>
		<p>
			[constructor:IXYZLoader IXYZLoader](  [param:ILoadingManager manager]? ) 
		</p>
		<h4>Properties</h4>
		<p>
			[property:string crossOrigin] -  The cross origin.<br />
			[property:ILoadingManager manager] -  The manager.<br />
			[property:string path] -  The path.<br />
			[property:any requestHeader] -  The request header.<br />
			[property:string resourcePath] -  The resource path.<br />
			[property:boolean withCredentials] -  The with credentials.
		</p>
		<h4>Methods</h4>
		<p>
			[method:void load](  [param:string url],  [param:any onLoad],  [param:any onProgress]?,  [param:any onError]? ) <br />
			[method:Promise loadAsync](  [param:string url],  [param:any onProgress]? ) <br />
			[method:object parse](  [param:string data],  [param:any onLoad] ) <br />
			[method:IXYZLoader setCrossOrigin](  [param:string crossOrigin] ) <br />
			[method:IXYZLoader setPath](  [param:string path] ) <br />
			[method:IXYZLoader setRequestHeader](  [param:any requestHeader] ) <br />
			[method:IXYZLoader setResourcePath](  [param:string resourcePath] ) <br />
			[method:IXYZLoader setWithCredentials](  [param:boolean value] ) 
		</p>

		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="IEventListener">IEventListener <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:any event] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:any event] -  The event.
		</p>
		<p>
			
		</p>



		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TArcballControlsMouseActionMouse">TArcballControlsMouseActionMouse <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'0'|'1'|'2'|'WHEEL' TArcballControlsMouseActionMouse]</h3>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TCSS2DParameters">TCSS2DParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TCSS3DParameters">TCSS3DParameters <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TColorRepresentation">TColorRepresentation <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:THREE.ColorRepresentation|any TColorRepresentation]</h3>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TGLTFReferenceType">TGLTFReferenceType <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h3>[property:'materials'|'nodes'|'textures'|'meshes' TGLTFReferenceType]</h3>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TXRAnimationLoopCallback">TXRAnimationLoopCallback <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:number time],  [param:THREE.XRFrame frame]? )</h4>
		<h4>Parameters</h4>
		<p>
			[property:number time] -  The time.<br />
			[property:THREE.XRFrame frame]? -  The frame.
		</p>
		<p>
			
		</p>



		<p class="desc">
			
		</p>

		<hr class="interface-line"/>
		<h3 id="TXRFrameRequestCallback">TXRFrameRequestCallback <i class="modifier modifier-interface">Interface</i></h3>
		<hr class="interface-line"/>
		<h4>[method:void function](  [param:number time],  [param:THREE.XRFrame frame] )</h4>
		<h4>Parameters</h4>
		<p>
			[property:number time] -  The time.<br />
			[property:THREE.XRFrame frame] -  The frame.
		</p>
		<p>
			
		</p>



		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<br /><br />
		<h2>Source</h2>
		<p>[link:https://github.com/outmindkjg/ngx3js-module/tree/master/projects/ngx3js/src/lib/threejs-library/three-interface.ts /threejs-library/three-interface.ts]</p>
	</body>
</html>