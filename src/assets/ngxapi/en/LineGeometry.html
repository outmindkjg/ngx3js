<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		[page:EventDispatcher] &rarr; [page:BufferGeometry] &rarr; [page:InstancedBufferGeometry] &rarr; [page:LineSegmentsGeometry] &rarr;

		<h1>LineGeometry</h1>

		<p class="desc">
			
		</p>

		<h2>Constructor</h2>
		<h3>[constructor:LineGeometry LineGeometry](  )</h3>
		<p>
			Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
		</p>

		<h2>Properties</h2>
		<p>
			See the base [page:EventDispatcher EventDispatcher] class for common properties.
		</p>
		<p>
			See the base [page:BufferGeometry BufferGeometry] class for common properties.
		</p>
		<p>
			See the base [page:InstancedBufferGeometry InstancedBufferGeometry] class for common properties.
		</p>
		<p>
			See the base [page:LineSegmentsGeometry LineSegmentsGeometry] class for common properties.
		</p>

		<h3>[property:number MaxIndex]</h3>
		<p>
			
		</p>

		<h3>[property:any attributes]</h3>
		<p>
			This hashmap has as id the name of the attribute to be set and as value the [page:BufferAttribute buffer] to set it to.<br />
			Rather than accessing this property directly, use *.setAttribute* and *.getAttribute* to access attributes of this geometry.
		</p>

		<h3>[property:Box3 boundingBox]</h3>
		<p>
			Bounding box for the bufferGeometry, which can be calculated with *.computeBoundingBox*(). Default is *null*.
		</p>

		<h3>[property:Sphere boundingSphere]</h3>
		<p>
			Bounding sphere for the bufferGeometry, which can be calculated with *.computeBoundingSphere*(). Default is *null*.
		</p>

		<h3>[property:any drawRange]</h3>
		<p>
			Determines the part of the geometry to render. This should not be set directly, instead use *.setDrawRange*. Default is { start: 0, count: Infinity }<br />
			For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.
		</p>

		<h3>[property:any drawcalls]</h3>
		<p>
			deprecated - Use {@link BufferGeometry#groups .groups} instead.
		</p>

		<h3>[property:any groups]</h3>
		<p>
			Split the geometry into groups, each of which will be rendered in a separate WebGL draw call.<br />
			This allows an array of materials to be used with the bufferGeometry.<br />
			Each group is an object of the form: { start: Integer, count: Integer, materialIndex: Integer }<br />
			where start specifies the first element in this draw call â€“ the first vertex for non-indexed geometry, otherwise the first triangle index. Count specifies how many vertices (or indices) are included, and materialIndex specifies the material array index to use.<br />
			Use *.addGroup* to add groups, rather than modifying this array directly.
		</p>

		<h3>[property:number id]</h3>
		<p>
			Unique number for this bufferGeometry instance.
		</p>

		<h3>[property:BufferAttribute index]</h3>
		<p>
			Allows for vertices to be re-used across multiple triangles; this is called using "indexed triangles".<br />
			Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face.<br />
			If this attribute is not set, the [page:WebGLRenderer renderer] assumes that each three contiguous positions represent a single triangle.<br />
			Default is *null*.
		</p>

		<h3>[property:number instanceCount]</h3>
		<p>
			Default is *Infinity*.
		</p>

		<h3>[property:any isBufferGeometry]</h3>
		<p>
			
		</p>

		<h3>[property:boolean isInstancedBufferGeometry]</h3>
		<p>
			
		</p>

		<h3>[property:any isLineGeometry]</h3>
		<p>
			
		</p>

		<h3>[property:any isLineSegmentsGeometry]</h3>
		<p>
			
		</p>

		<h3>[property:any morphAttributes]</h3>
		<p>
			Hashmap of [page:BufferAttribute BufferAttribute]s holding details of the geometry's morph targets.
		</p>

		<h3>[property:boolean morphTargetsRelative]</h3>
		<p>
			Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals.<br />
			Default is *false*.
		</p>

		<h3>[property:string name]</h3>
		<p>
			Optional name for this bufferGeometry instance. Default is an empty string.
		</p>

		<h3>[property:any offsets]</h3>
		<p>
			deprecated - Use {@link BufferGeometry#groups .groups} instead.
		</p>

		<h3>[property:string type]</h3>
		<p>
			
		</p>

		<h3>[property:any userData]</h3>
		<p>
			An object that can be used to store custom data about the BufferGeometry. It should not hold references to functions as these will not be cloned.
		</p>

		<h3>[property:string uuid]</h3>
		<p>
			[link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID] of this object instance.<br />
			This gets automatically assigned and shouldn't be edited.
		</p>

		<h2>Methods</h2>
		<p>
			See the base [page:EventDispatcher EventDispatcher] class for common methods.
		</p>
		<p>
			See the base [page:BufferGeometry BufferGeometry] class for common methods.
		</p>
		<p>
			See the base [page:InstancedBufferGeometry InstancedBufferGeometry] class for common methods.
		</p>
		<p>
			See the base [page:LineSegmentsGeometry LineSegmentsGeometry] class for common methods.
		</p>

		<h3>[method:any addAttribute](  [param:string name],  [param:BufferAttribute|InterleavedBufferAttribute attribute],  [param:any name],  [param:any array],  [param:any itemSize] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:string name] - The name.<br />
			[parameter:BufferAttribute|InterleavedBufferAttribute attribute] - The attribute.<br />
			[parameter:any name] - The name.<br />
			[parameter:any array] - The array.<br />
			[parameter:any itemSize] - The item size.
		</p>
		<p>
			Returns : attribute
		</p>

		<h3>[method:void addDrawCall](  [param:any start],  [param:any count],  [param:any indexOffset]? )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:any start] - The start.<br />
			[parameter:any count] - The count.<br />
			[parameter:any indexOffset] - (optional) The index offset.
		</p>
		<p>
			deprecated - Use {@link BufferGeometry#addGroup .addGroup()} instead.
		</p>

		<h3>[method:void addEventListener](  [param:T type],  [param:EventListener listener] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:T type] - The type of event to listen to.<br />
			[parameter:EventListener listener] - The that gets called when the event is fired.
		</p>
		<p>
			Adds a listener to an event type.
		</p>

		<h3>[method:void addGroup](  [param:number start],  [param:number count],  [param:number instances] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:number start] - The start.<br />
			[parameter:number count] - The count.<br />
			[parameter:number instances] - The instances.
		</p>
		<p>
			Adds a group to this geometry; see the [page:BufferGeometry.groups groups]<br />
			property for details.
		</p>

		<h3>[method:void addIndex](  [param:any index] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:any index] - The index.
		</p>
		<p>
			deprecated - Use {@link BufferGeometry#setIndex .setIndex()} instead.
		</p>

		<h3>[method:LineGeometry applyMatrix4](  [param:Matrix4 matrix] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:Matrix4 matrix] - The matrix.
		</p>
		<p>
			Applies the matrix transform to the geometry.
		</p>

		<h3>[method:BufferGeometry applyQuaternion](  [param:Quaternion q] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:Quaternion q] - The q.
		</p>
		<p>
			Applies the rotation represented by the quaternion to the geometry.
		</p>

		<h3>[method:BufferGeometry center](  )</h3>
		<p>
			Center the geometry based on the bounding box.
		</p>

		<h3>[method:void clearDrawCalls](  )</h3>
		<p>
			deprecated - Use {@link BufferGeometry#clearGroups .clearGroups()} instead.
		</p>

		<h3>[method:void clearGroups](  )</h3>
		<p>
			Clears all groups.
		</p>

		<h3>[method:BufferGeometry clone](  )</h3>
		<p>
			Creates a clone of this BufferGeometry.
		</p>

		<h3>[method:void computeBoundingBox](  )</h3>
		<p>
			Computes bounding box of the geometry, updating *.boundingBox* attribute.<br />
			Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*.
		</p>

		<h3>[method:void computeBoundingSphere](  )</h3>
		<p>
			Computes bounding sphere of the geometry, updating *.boundingSphere* attribute.<br />
			Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*.
		</p>

		<h3>[method:void computeTangents](  )</h3>
		<p>
			Calculates and adds a tangent attribute to this geometry.<br />
			The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined.
		</p>

		<h3>[method:void computeVertexNormals](  )</h3>
		<p>
			Computes vertex normals by averaging face normals.
		</p>

		<h3>[method:LineGeometry copy](  [param:BufferGeometry source] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:BufferGeometry source] - The source.
		</p>
		<p>
			Copies another BufferGeometry to this BufferGeometry.
		</p>

		<h3>[method:BufferGeometry deleteAttribute](  [param:BuiltinShaderAttributeName name] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:BuiltinShaderAttributeName name] - The name.
		</p>
		<p>
			Deletes the [page:BufferAttribute attribute] with the specified name.
		</p>

		<h3>[method:void dispatchEvent](  [param:Event event] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:Event event] - The event.
		</p>
		<p>
			Fire an event type.
		</p>

		<h3>[method:void dispose](  )</h3>
		<p>
			Disposes the object from memory.<br />
			You need to call this when you want the BufferGeometry removed while the application is running.
		</p>

		<h3>[method:LineGeometry fromEdgesGeometry](  [param:EdgesGeometry geometry] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:EdgesGeometry geometry] - The geometry.
		</p>
		<p>
			
		</p>

		<h3>[method:LineGeometry fromLine](  [param:Line line] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:Line line] - The line.
		</p>
		<p>
			
		</p>

		<h3>[method:LineGeometry fromLineSegments](  [param:LineSegments lineSegments] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:LineSegments lineSegments] - The line segments.
		</p>
		<p>
			
		</p>

		<h3>[method:LineGeometry fromMesh](  [param:Mesh mesh] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:Mesh mesh] - The mesh.
		</p>
		<p>
			
		</p>

		<h3>[method:LineGeometry fromWireframeGeometry](  [param:WireframeGeometry geometry] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:WireframeGeometry geometry] - The geometry.
		</p>
		<p>
			
		</p>

		<h3>[method:BufferAttribute|InterleavedBufferAttribute getAttribute](  [param:BuiltinShaderAttributeName name] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:BuiltinShaderAttributeName name] - The name.
		</p>
		<p>
			Returns : Returns the [page:BufferAttribute attribute] with the specified name.
		</p>

		<h3>[method:BufferAttribute getIndex](  )</h3>
		<p>
			Returns : Return the *.index* buffer.
		</p>

		<h3>[method:boolean hasAttribute](  [param:BuiltinShaderAttributeName name] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:BuiltinShaderAttributeName name] - The name.
		</p>
		<p>
			Returns : Returns *true* if the attribute with the specified name exists.
		</p>

		<h3>[method:boolean hasEventListener](  [param:T type],  [param:EventListener listener] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:T type] - The type of event to listen to.<br />
			[parameter:EventListener listener] - The that gets called when the event is fired.
		</p>
		<p>
			Checks if listener is added to an event type.
		</p>

		<h3>[method:void lookAt](  [param:Vector3 v] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:Vector3 v] - The v.
		</p>
		<p>
			vector - A world vector to look at.<br />
			Rotates the geometry to face a point in space. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.lookAt Object3D.lookAt] for typical real-time mesh usage.
		</p>

		<h3>[method:BufferGeometry merge](  [param:BufferGeometry geometry],  [param:number offset]? )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:BufferGeometry geometry] - The geometry.<br />
			[parameter:number offset] - (optional) The offset.
		</p>
		<p>
			Merge in another BufferGeometry with an optional offset of where to start merging in.
		</p>

		<h3>[method:void normalizeNormals](  )</h3>
		<p>
			Every normal vector in a geometry will have a magnitude of 1.<br />
			This will correct lighting on the geometry surfaces.
		</p>

		<h3>[method:BufferGeometry removeAttribute](  [param:string name] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:string name] - The name.
		</p>
		<p>
			deprecated - Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.
		</p>

		<h3>[method:void removeEventListener](  [param:T type],  [param:EventListener listener] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:T type] - The type of the listener that gets removed.<br />
			[parameter:EventListener listener] - The listener that gets removed.
		</p>
		<p>
			Removes a listener from an event type.
		</p>

		<h3>[method:BufferGeometry rotateX](  [param:number angle] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:number angle] - The angle.
		</p>
		<p>
			Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.
		</p>

		<h3>[method:BufferGeometry rotateY](  [param:number angle] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:number angle] - The angle.
		</p>
		<p>
			Rotate the geometry about the Y axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.
		</p>

		<h3>[method:BufferGeometry rotateZ](  [param:number angle] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:number angle] - The angle.
		</p>
		<p>
			Rotate the geometry about the Z axis. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.rotation Object3D.rotation] for typical real-time mesh rotation.
		</p>

		<h3>[method:BufferGeometry scale](  [param:number x],  [param:number y],  [param:number z] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:number x] - The x.<br />
			[parameter:number y] - The y.<br />
			[parameter:number z] - The z.
		</p>
		<p>
			Scale the geometry data. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.scale Object3D.scale] for typical real-time mesh scaling.
		</p>

		<h3>[method:BufferGeometry setAttribute](  [param:BuiltinShaderAttributeName name],  [param:BufferAttribute|InterleavedBufferAttribute attribute] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:BuiltinShaderAttributeName name] - The name.<br />
			[parameter:BufferAttribute|InterleavedBufferAttribute attribute] - The attribute.
		</p>
		<p>
			Sets an attribute to this geometry. Use this rather than the attributes property, because an internal hashmap of *.attributes* is maintained to speed up iterating over attributes.
		</p>

		<h3>[method:LineGeometry setColors](  [param:Float32Array|number[] array] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:Float32Array|number[] array] - The array.
		</p>
		<p>
			
		</p>

		<h3>[method:void setDrawRange](  [param:number start],  [param:number count] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:number start] - The start.<br />
			[parameter:number count] - The count.
		</p>
		<p>
			Set the *.drawRange* property. For non-indexed BufferGeometry, count is the number of vertices to render.<br />
			For indexed BufferGeometry, count is the number of indices to render.
		</p>

		<h3>[method:BufferGeometry setFromPoints](  [param:Vector3[]|Vector2[] points] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:Vector3[]|Vector2[] points] - The points.
		</p>
		<p>
			Sets the attributes for this BufferGeometry from an array of points.
		</p>

		<h3>[method:BufferGeometry setIndex](  [param:BufferAttribute|number[] index] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:BufferAttribute|number[] index] - The index.
		</p>
		<p>
			Set the *.index* buffer.
		</p>

		<h3>[method:LineGeometry setPositions](  [param:Float32Array|number[] array] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:Float32Array|number[] array] - The array.
		</p>
		<p>
			
		</p>

		<h3>[method:any toJSON](  )</h3>
		<p>
			Convert the buffer geometry to three.js [link:https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 JSON Object/Scene format].
		</p>

		<h3>[method:BufferGeometry toNonIndexed](  )</h3>
		<p>
			Returns : Return a non-index version of an indexed BufferGeometry.
		</p>

		<h3>[method:BufferGeometry translate](  [param:number x],  [param:number y],  [param:number z] )</h3>
		<h4>Parameters</h4>
		<p>
			[parameter:number x] - The x.<br />
			[parameter:number y] - The y.<br />
			[parameter:number z] - The z.
		</p>
		<p>
			Translate the geometry. This is typically done as a one time operation, and not during a loop.<br />
			Use [page:Object3D.position Object3D.position] for typical real-time mesh translation.
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>


		<p class="desc">
			
		</p>

		<br /><br />
		<h2>Source</h2>
		<p>[link:https://github.com/outmindkjg/ngx3js-module/tree/master/projects/ngx3js/src/lib/threejs-library/types/three/examples/lines.ts /threejs-library/types/three/examples/lines.ts]</p>
	</body>
</html>